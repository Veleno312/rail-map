<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Railway Network Simulator (Cities + Clusters)</title>

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; overflow: hidden; }
    #map { height: 100%; width: 100%; }

    .panel{
      position:absolute; top:16px; right:16px; z-index:1000;
      background:rgba(255,255,255,0.96); backdrop-filter: blur(16px);
      padding:14px; border-radius:14px; box-shadow:0 8px 24px rgba(0,0,0,0.22);
      width:420px; max-height:86vh; overflow:auto; border:1px solid rgba(0,0,0,0.06);
    }
    .tabs{ display:flex; gap:6px; background:#f1f5f9; padding:6px; border-radius:12px; margin-bottom:12px; }
    .tab{ flex:1; text-align:center; padding:10px 8px; border-radius:10px; font-weight:900; cursor:pointer; user-select:none; color:#64748b; }
    .tab.active{ background:white; color:#2b6cff; box-shadow:0 2px 8px rgba(0,0,0,0.08); }

    .section{ padding-bottom:12px; margin-bottom:12px; border-bottom:1px solid #e2e8f0; }
    .section:last-child{ border-bottom:none; margin-bottom:0; padding-bottom:0; }
    .title{ font-weight:1000; color:#0f172a; margin:0 0 4px 0; }
    .sub{ color:#64748b; font-weight:800; font-size:12px; margin:0 0 10px 0; }

    .btn{
      width:100%; padding:12px; border:0; border-radius:10px; cursor:pointer; font-weight:1000;
      background:linear-gradient(135deg,#2b6cff,#1a56db); color:white; user-select:none;
      margin-top:8px;
    }
    .btn.secondary{ background:#f1f5f9; color:#0f172a; }
    .btn.success{ background:linear-gradient(135deg,#10b981,#059669); }
    .btn.warning{ background:linear-gradient(135deg,#f59e0b,#d97706); }
    .btn.danger{ background:linear-gradient(135deg,#ef4444,#b91c1c); }
    .row{ display:flex; gap:8px; }
    .row .btn{ margin-top:0; }

    .field{ width:100%; padding:10px 12px; border:2px solid #e2e8f0; border-radius:10px; font-weight:900; }
    .field:focus{ outline:none; border-color:#2b6cff; box-shadow:0 0 0 3px rgba(43,108,255,0.08); }

    .hint{
      background:#f8fafc; border:1px solid #e2e8f0; border-radius:10px;
      padding:10px 12px; color:#334155; font-weight:850; font-size:12px;
    }

    .toast{
      position:fixed; right:18px; bottom:18px; z-index:99999;
      background:#0f172a; color:white; padding:12px 14px; border-radius:12px;
      box-shadow:0 6px 20px rgba(0,0,0,0.25); font-weight:950; display:none;
    }

    .k{ color:#64748b; font-weight:900; }
    .v{ color:#0f172a; font-weight:1000; }

    .list{ border:1px solid #e2e8f0; border-radius:12px; overflow:hidden; background:white; max-height:240px; overflow:auto; }
    .item{ padding:10px 12px; border-bottom:1px solid #f1f5f9; cursor:pointer; user-select:none; }
    .item:last-child{ border-bottom:none; }
    .item:hover{ background:#f8fafc; }
    .item.active{ background:#e0f2fe; border-left:4px solid #2b6cff; }

    .badge{
      display:inline-block; padding:2px 8px; border-radius:999px; font-weight:1000; font-size:11px;
      background:#e2e8f0; color:#0f172a; margin-left:8px;
    }

    /* Bottom-left cluster exit */
    #clusterBar{
      position:absolute; left:16px; bottom:16px; z-index:1200;
      background:rgba(255,255,255,0.96); backdrop-filter: blur(16px);
      padding:10px 12px; border-radius:14px;
      box-shadow:0 8px 24px rgba(0,0,0,0.22);
      border:1px solid rgba(0,0,0,0.06);
      display:none;
      width:320px;
    }
    #clusterBar .rowTop{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    #clusterBar .name{ font-weight:1000; color:#0f172a; font-size:13px; }
    #clusterBar .btnTiny{
      border:0; border-radius:10px; padding:8px 10px; cursor:pointer; font-weight:1000;
      background:#f1f5f9; color:#0f172a;
    }

    /* Cluster dots (same size always) */
    .cluster-dot {
      width: 14px;
      height: 14px;
      border-radius: 999px;
      background: rgba(0,0,0,0.9);
      box-shadow: 0 8px 18px rgba(0,0,0,0.18);
      border: 2px solid rgba(255,255,255,0.85);
    }
    .cluster-dot.active {
      outline: 4px solid rgba(16,185,129,0.35);
      border-color: rgba(255,255,255,1);
    }

    /* Track lane label at midpoint */
    .lane-label{
      background: rgba(0,0,0,0.85);
      color: white;
      border-radius: 10px;
      padding: 2px 6px;
      font-weight: 1000;
      font-size: 12px;
      line-height: 1;
      border: 1px solid rgba(255,255,255,0.25);
      box-shadow: 0 8px 18px rgba(0,0,0,0.20);
      pointer-events: none;
    }
  </style>
</head>

<body>
  <div id="map"></div>
  <div id="controlPanel" class="panel"></div>
  <div id="clusterBar"></div>
  <div id="toast" class="toast"></div>

<script type="module">
  import { computeEconomy } from "./economy.js";

  // ======================
  // Config
  // ======================
  const CONFIG = {
    CLUSTER_RADIUS_KM: 30,
    CLUSTER_VIEW_MAX_ZOOM: 7,
    SPAIN_VIEW: { center: [40.0, -3.7], zoom: 6 },

    // Infra
    TRACK_COST_PER_KM: 5_000_000,
    TRACK_MAINTENANCE_PER_KM: 250_000,

    STARTING_BUDGET: 1_000_000_000,
    ANNUAL_BUDGET: 100_000_000,

    // production proxy (until real stats)
    PROD_EUR_PER_PERSON_MIN: 900,
    PROD_EUR_PER_PERSON_MAX: 2200,

    // auto-track settings
    AUTO_TRACK_LANES_PASSENGER: 2,
    AUTO_TRACK_LANES_CARGO: 3,
    AUTO_TRACK_LANES_MIXED: 2,
  };

  // ======================
  // Helpers
  // ======================
  function fmtNum(x){
    if (x === null || x === undefined || Number.isNaN(Number(x))) return "—";
    return Number(x).toLocaleString();
  }
  function formatCurrency(amount){
    if (amount === null || amount === undefined || Number.isNaN(Number(amount))) return "—";
    const a = Number(amount);
    if (a >= 1e12) return '€' + (a/1e12).toFixed(2) + 'T';
    if (a >= 1e9)  return '€' + (a/1e9).toFixed(2) + 'B';
    if (a >= 1e6)  return '€' + (a/1e6).toFixed(2) + 'M';
    if (a >= 1e3)  return '€' + (a/1e3).toFixed(0) + 'K';
    return '€' + a.toFixed(0);
  }
  function showToast(msg, type="info"){
    const t = document.getElementById("toast");
    t.textContent = msg;
    t.style.display = "block";
    t.style.background =
      type==="error" ? "#ef4444" :
      type==="success" ? "#10b981" :
      type==="warning" ? "#f59e0b" : "#0f172a";
    setTimeout(()=> t.style.display="none", 2200);
  }
  async function loadJSON(url){
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`Failed to load ${url} (${res.status})`);
    return await res.json();
  }
  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

  // deterministic hash -> 0..1
  function hash01(str){
    let h = 2166136261;
    for (let i=0;i<str.length;i++){
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return ((h >>> 0) % 1000000) / 1000000;
  }

  function edgeKey(a,b){
    a=String(a); b=String(b);
    return a<b ? `${a}—${b}` : `${b}—${a}`;
  }

  // ======================
  // State
  // ======================
  const state = {
    nodes: new Map(),   // id -> {id,name,lat,lon,kind,population,production,clusterId?}
    cities: [],
    clusters: new Map(),// clusterId -> {id, hubCityId, hubName, lat, lon, population, cityIds:Set, bounds, totalProduction, biggestProduction}

    tracks: new Map(),  // trackId -> {id, from, to, lanes, cost, _layer, _label}
    lines: new Map(),   // lineId -> {id,name,type,color,stops:[],circular, frequencyPerDay, vehicleCapacity, speedKmh}

    year: 2024,
    budget: CONFIG.STARTING_BUDGET,
    annualBudget: CONFIG.ANNUAL_BUDGET,
    revenue: 0,
    costs: 0,
    profit: 0,

    activeTab: "network",
    activeLine: null,

    // modes
    trackBuildMode: false,
    pendingTrackNode: null,
    pendingTrackLanes: 1,

    // clustering UX
    activeClusterId: null,
    selectedNode: null,

    // line building toggle
    lineBuildMode: true,
  };

  // ======================
  // Map + Layers
  // ======================
  let map;
  const layers = {
    clusters: L.layerGroup(),
    cities: L.layerGroup(),
    tracks: L.layerGroup(),
    trackLabels: L.layerGroup(),
    lines: L.layerGroup(),
  };

  function initMap(){
    map = L.map("map").setView(CONFIG.SPAIN_VIEW.center, CONFIG.SPAIN_VIEW.zoom);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: "© OpenStreetMap contributors"
    }).addTo(map);

    layers.clusters.addTo(map);
    layers.cities.addTo(map);
    layers.tracks.addTo(map);
    layers.trackLabels.addTo(map);
    layers.lines.addTo(map);

    map.on("zoomend moveend", () => {
      syncMarkerVisibility();
      if (state.activeClusterId && map.getZoom() <= CONFIG.CLUSTER_VIEW_MAX_ZOOM) {
        leaveCluster(true);
      }
    });
  }

  // ======================
  // Production proxy
  // ======================
  function estimateCityProductionEUR(city){
    const pop = Number(city.population || 0);
    const t = hash01(String(city.id || city.name || "x"));
    const perPerson = CONFIG.PROD_EUR_PER_PERSON_MIN +
      (CONFIG.PROD_EUR_PER_PERSON_MAX - CONFIG.PROD_EUR_PER_PERSON_MIN) * t;
    return Math.round(pop * perPerson);
  }

  // ======================
  // Clustering (greedy by population)
  // ======================
  function buildClusters(cities){
    state.clusters.clear();

    const usable = cities
      .filter(c => Number(c?.lat) && Number(c?.lon) && Number(c?.population) >= 5000)
      .map(c => ({
        id: String(c.id),
        name: c.name,
        lat: Number(c.lat),
        lon: Number(c.lon),
        population: Number(c.population) || 0
      }));

    usable.sort((a,b) => (b.population||0) - (a.population||0));

    const assigned = new Set();
    const radiusM = CONFIG.CLUSTER_RADIUS_KM * 1000;

    const cityProd = new Map();
    for (const c of usable) cityProd.set(c.id, estimateCityProductionEUR(c));

    for (const hub of usable) {
      if (assigned.has(hub.id)) continue;

      const clusterId = `CL-${hub.id}`;
      const cityIds = new Set([hub.id]);
      assigned.add(hub.id);

      const bounds = L.latLngBounds([[hub.lat, hub.lon],[hub.lat, hub.lon]]);
      let popSum = hub.population || 0;

      let totalProduction = cityProd.get(hub.id) || 0;
      let biggestProduction = cityProd.get(hub.id) || 0;

      for (const c of usable) {
        if (assigned.has(c.id)) continue;
        const d = map.distance([hub.lat, hub.lon], [c.lat, c.lon]);
        if (d <= radiusM) {
          assigned.add(c.id);
          cityIds.add(c.id);
          popSum += c.population || 0;
          bounds.extend([c.lat, c.lon]);

          const p = cityProd.get(c.id) || 0;
          totalProduction += p;
          if (p > biggestProduction) biggestProduction = p;
        }
      }

      state.clusters.set(clusterId, {
        id: clusterId,
        hubCityId: hub.id,
        hubName: hub.name,
        lat: hub.lat,
        lon: hub.lon,
        population: popSum,
        cityIds,
        bounds,
        totalProduction,
        biggestProduction
      });
    }

    // Build nodes (clusters + cities)
    state.nodes.clear();

    for (const cl of state.clusters.values()) {
      state.nodes.set(cl.id, {
        id: cl.id,
        name: cl.hubName,
        lat: cl.lat,
        lon: cl.lon,
        kind: "cluster",
        population: cl.population,
        production: cl.totalProduction,
        biggestProduction: cl.biggestProduction,
        hubCityId: cl.hubCityId
      });
    }

    for (const c of usable) {
      let clusterId = null;
      for (const cl of state.clusters.values()) {
        if (cl.cityIds.has(c.id)) { clusterId = cl.id; break; }
      }

      state.nodes.set(c.id, {
        id: c.id,
        name: c.name,
        lat: c.lat,
        lon: c.lon,
        kind: "city",
        population: c.population,
        production: cityProd.get(c.id) || 0,
        clusterId
      });
    }
  }

  // ======================
  // Rendering: clusters + cities
  // ======================
  function makeClusterDotIcon(cluster) {
    const active = state.selectedNode?.id === cluster.id;
    return L.divIcon({
      className: "",
      iconSize: [14, 14],
      iconAnchor: [7, 7],
      html: `<div class="cluster-dot ${active ? "active" : ""}"></div>`
    });
  }

  function renderClusterMarkers(){
    layers.clusters.clearLayers();

    for (const cl of state.clusters.values()) {
      const marker = L.marker([cl.lat, cl.lon], {
        icon: makeClusterDotIcon(cl),
        keyboard: false
      });

      marker.bindTooltip(
        `<strong>${cl.hubName}</strong><br>` +
        `Cluster pop: ${fmtNum(cl.population)}<br>` +
        `Cities: ${fmtNum(cl.cityIds.size)}<br>` +
        `Production (proxy): ${formatCurrency(cl.totalProduction)}<br>` +
        `Biggest city prod (proxy): ${formatCurrency(cl.biggestProduction)}`
      );

      // Left click: select node (for lines/tracks)
      marker.on("click", () => selectNode(cl.id));

      // Right click: zoom into cluster
      marker.on("contextmenu", (e) => {
        L.DomEvent.preventDefault(e);
        enterCluster(cl.id);
      });

      marker.addTo(layers.clusters);
    }
  }

  function renderCityMarkers(cityIds){
    layers.cities.clearLayers();

    for (const id of cityIds) {
      const n = state.nodes.get(id);
      if (!n || n.kind !== "city") continue;

      // Cities stay normal small dots (for realism and performance)
      const pop = n.population || 0;
      const r = Math.max(3, Math.min(9, Math.log10(Math.max(1,pop)) * 2.1));
      const fill =
        pop >= 500000 ? "#ef4444" :
        pop >= 100000 ? "#f59e0b" : "#10b981";

      const m = L.circleMarker([n.lat, n.lon], {
        radius: r,
        color: "#0f172a",
        weight: 1,
        fillColor: fill,
        fillOpacity: 0.78
      });

      m.bindTooltip(
        `<strong>${n.name}</strong><br>` +
        `Pop: ${fmtNum(pop)}<br>` +
        `Production (proxy): ${formatCurrency(n.production || 0)}`
      );

      m.on("click", () => selectNode(n.id));
      m.addTo(layers.cities);
    }
  }

  function syncMarkerVisibility(){
    const z = map.getZoom();

    if (z <= CONFIG.CLUSTER_VIEW_MAX_ZOOM) {
      layers.clusters.addTo(map);
      layers.cities.clearLayers();
      return;
    }

    layers.clusters.removeFrom(map);

    if (state.activeClusterId && state.clusters.has(state.activeClusterId)) {
      const cl = state.clusters.get(state.activeClusterId);
      renderCityMarkers(cl.cityIds);
      return;
    }

    const b = map.getBounds();
    const visible = [];
    for (const n of state.nodes.values()) {
      if (n.kind !== "city") continue;
      if (b.contains([n.lat, n.lon])) visible.push(n.id);
      if (visible.length >= 1800) break;
    }
    renderCityMarkers(visible);
  }

  // ======================
  // Cluster enter/leave UX
  // ======================
  function enterCluster(clusterId){
    const cl = state.clusters.get(clusterId);
    if (!cl) return;

    state.activeClusterId = clusterId;
    map.fitBounds(cl.bounds.pad(0.25), { maxZoom: 11 });

    updateClusterBar();
    syncMarkerVisibility();
    updateUI();
    showToast(`Entered cluster: ${cl.hubName}`, "success");
    renderClusterMarkers();
  }

  function leaveCluster(silent=false){
    state.activeClusterId = null;
    updateClusterBar();

    map.setView(CONFIG.SPAIN_VIEW.center, CONFIG.SPAIN_VIEW.zoom);

    syncMarkerVisibility();
    updateUI();
    if (!silent) showToast("Left cluster view", "info");
    renderClusterMarkers();
  }

  function updateClusterBar(){
    const bar = document.getElementById("clusterBar");
    if (!state.activeClusterId) {
      bar.style.display = "none";
      bar.innerHTML = "";
      return;
    }
    const cl = state.clusters.get(state.activeClusterId);
    if (!cl) { bar.style.display="none"; bar.innerHTML=""; return; }

    bar.style.display = "block";
    bar.innerHTML = `
      <div class="rowTop">
        <div>
          <div class="name">Zoomed in: ${cl.hubName}</div>
          <div style="font-size:12px;color:#64748b;font-weight:900;">
            Cities: ${fmtNum(cl.cityIds.size)} • Pop: ${fmtNum(cl.population)}
          </div>
        </div>
        <button class="btnTiny" id="leaveClusterBtn">Leave</button>
      </div>
      <div style="margin-top:8px;" class="hint">
        <b>Global:</b> connect to the cluster hub. <b>Zoomed:</b> target real cities.
      </div>
    `;
    document.getElementById("leaveClusterBtn").onclick = () => leaveCluster(false);
  }

  // ======================
  // Tracks (black line + white lane number label)
  // ======================
  function calculateTrackCost(a, b, lanes=1){
    const km = (map.distance([a.lat,a.lon],[b.lat,b.lon]) / 1000) || 0;
    const constructionCost = km * CONFIG.TRACK_COST_PER_KM * lanes;
    const maintenanceCost = km * CONFIG.TRACK_MAINTENANCE_PER_KM * lanes;
    return { distanceKm: km, terrainDifficulty: 1.0, constructionCost, maintenanceCost, lanes };
  }

  function addTrack(fromId, toId, lanes=1, {silent=false} = {}){
    const a = state.nodes.get(fromId);
    const b = state.nodes.get(toId);
    if (!a || !b) return null;

    const key = edgeKey(fromId, toId);
    const trackId = `TK-${key}`;

    // remove existing visual if overwriting
    if (state.tracks.has(trackId)) {
      const old = state.tracks.get(trackId);
      if (old?._layer) layers.tracks.removeLayer(old._layer);
      if (old?._label) layers.trackLabels.removeLayer(old._label);
      state.tracks.delete(trackId);
    }

    const cost = calculateTrackCost(a, b, lanes);

    // allow budget to go negative (gameplay choice) but warn
    state.budget -= cost.constructionCost;

    const line = L.polyline([[a.lat,a.lon],[b.lat,b.lon]], {
      color: "#000",
      weight: 2.5 + lanes * 1.2,
      opacity: 0.92,
      lineCap: "round"
    }).addTo(layers.tracks);

    // midpoint label
    const mid = [(a.lat + b.lat)/2, (a.lon + b.lon)/2];
    const label = L.marker(mid, {
      interactive: false,
      icon: L.divIcon({
        className: "",
        iconSize: [18, 18],
        iconAnchor: [9, 9],
        html: `<div class="lane-label">${lanes}</div>`
      })
    }).addTo(layers.trackLabels);

    line.on("click", () => {
      if (confirm("Delete this track segment?")) {
        layers.tracks.removeLayer(line);
        layers.trackLabels.removeLayer(label);
        state.tracks.delete(trackId);
        updateUI();
        renderLines();
        showToast("Track deleted", "warning");
      }
    });

    state.tracks.set(trackId, {
      id: trackId,
      from: String(fromId),
      to: String(toId),
      lanes,
      cost,
      built: true,
      _layer: line,
      _label: label
    });

    if (!silent) showToast(`Built track: ${a.name} → ${b.name}`, "success");
    updateUI();
    renderLines();
    return trackId;
  }

  // Track build mode now CHAINS:
  // click A, click B => builds A→B, keeps B as next start.
  function handleTrackBuildClick(node){
    if (!state.pendingTrackNode) {
      state.pendingTrackNode = node;
      showToast(`Track: start = ${node.name}`, "info");
      updateUI();
      return;
    }

    const a = state.pendingTrackNode;
    const b = node;

    if (a.id === b.id) {
      showToast("Pick a different node", "warning");
      updateUI();
      return;
    }

    addTrack(a.id, b.id, state.pendingTrackLanes || 1);
    state.pendingTrackNode = b;
    showToast(`Track: next start = ${b.name}`, "info");
    updateUI();
  }

  // ======================
  // Lines (smart ordering + auto-track creation)
  // ======================
  function lineDefaults(type){
    if (type === "cargo") return { frequencyPerDay: 4, vehicleCapacity: 900, speedKmh: 80, color: "#ef4444" };
    if (type === "mixed") return { frequencyPerDay: 10, vehicleCapacity: 280, speedKmh: 120, color: "#6b7280" };
    return { frequencyPerDay: 18, vehicleCapacity: 360, speedKmh: 160, color: "#2b6cff" };
  }

  function addLine(name, type="passenger", circular=false){
    const id = `LN-${Date.now()}`;
    const d = lineDefaults(type);
    state.lines.set(id, {
      id,
      name,
      type,
      color: d.color,
      stops: [],
      circular: !!circular,
      frequencyPerDay: d.frequencyPerDay,
      vehicleCapacity: d.vehicleCapacity,
      speedKmh: d.speedKmh,
    });
    state.activeLine = id;
    showToast(`Created line: ${name}`, "success");
    updateUI();
    renderLines();
  }

  function pathLength(ids){
    let sum = 0;
    for (let i=0;i<ids.length-1;i++){
      const A = state.nodes.get(ids[i]);
      const B = state.nodes.get(ids[i+1]);
      if (!A || !B) continue;
      sum += map.distance([A.lat,A.lon],[B.lat,B.lon]);
    }
    return sum;
  }

  // 2-opt improvement to reduce criss-cross and shorten

// ======================
// Smart line geometry helpers (NO criss-cross, minimize detours)
// ======================

function segLen(aId, bId){
  const A = state.nodes.get(aId), B = state.nodes.get(bId);
  if (!A || !B) return 0;
  return map.distance([A.lat, A.lon], [B.lat, B.lon]);
}

// Proper segment intersection test (in screen space for stability)
function segmentsIntersect(aId,bId,cId,dId){
  const A = state.nodes.get(aId), B = state.nodes.get(bId);
  const C = state.nodes.get(cId), D = state.nodes.get(dId);
  if (!A||!B||!C||!D) return false;

  const a = map.latLngToLayerPoint([A.lat,A.lon]);
  const b = map.latLngToLayerPoint([B.lat,B.lon]);
  const c = map.latLngToLayerPoint([C.lat,C.lon]);
  const d = map.latLngToLayerPoint([D.lat,D.lon]);

  function ccw(p1,p2,p3){
    return (p3.y - p1.y) * (p2.x - p1.x) > (p2.y - p1.y) * (p3.x - p1.x);
  }

  // share endpoints => ignore
  const shared =
    (aId===cId)||(aId===dId)||(bId===cId)||(bId===dId);
  if (shared) return false;

  return (ccw(a,c,d) !== ccw(b,c,d)) && (ccw(a,b,c) !== ccw(a,b,d));
}

function countCrossings(stops){
  let x = 0;
  for (let i=0;i<stops.length-1;i++){
    for (let j=i+2;j<stops.length-1;j++){
      // skip adjacent and skip first-last adjacency
      if (i===0 && j===stops.length-2) continue;
      if (segmentsIntersect(stops[i],stops[i+1],stops[j],stops[j+1])) x++;
    }
  }
  return x;
}

// Score = total length + huge penalty for crossings
function lineScore(stops){
  let len = 0;
  for (let i=0;i<stops.length-1;i++) len += segLen(stops[i], stops[i+1]);
  const crossings = countCrossings(stops);
  return len + crossings * 1e12; // crossings are basically forbidden
}

// 2-opt improvement to remove crossings + shorten route
function improveLineOrder(line){
  if (!line || !Array.isArray(line.stops) || line.stops.length < 4) return;

  let improved = true;
  let guard = 0;

  while (improved && guard < 80){
    improved = false;
    guard++;

    for (let i=0;i<line.stops.length-3;i++){
      for (let k=i+2;k<line.stops.length-1;k++){
        // don't break adjacency
        if (i===0 && k===line.stops.length-2) continue;

        const A = line.stops[i],     B = line.stops[i+1];
        const C = line.stops[k],     D = line.stops[k+1];

        const before = segLen(A,B) + segLen(C,D);
        const after  = segLen(A,C) + segLen(B,D);

        // If swapping reduces length OR fixes an intersection, do it
        const hadX = segmentsIntersect(A,B,C,D);
        if (after + 1e-6 < before || hadX) {
          // reverse the segment between B..C
          const middle = line.stops.slice(i+1, k+1).reverse();
          line.stops.splice(i+1, k - i, ...middle);
          improved = true;
        }
      }
    }
  }
}

// ======================
// FIXED: Smart add stop (prepend/append/insert + 2-opt cleanup)
// ======================
function addStopSmart(line, nodeId){
  if (!line || !Array.isArray(line.stops)) return;
  if (line.stops.includes(nodeId)) return;

  // 0-1 stops: just append
  if (line.stops.length < 2) {
    line.stops.push(nodeId);
    return;
  }

  let best = null;
  let bestScore = Infinity;

  // Candidate A: prepend
  {
    const cand = [nodeId, ...line.stops];
    const s = lineScore(cand);
    if (s < bestScore) { bestScore = s; best = cand; }
  }

  // Candidate B: append
  {
    const cand = [...line.stops, nodeId];
    const s = lineScore(cand);
    if (s < bestScore) { bestScore = s; best = cand; }
  }

  // Candidate C: insert between every pair
  for (let i = 0; i < line.stops.length - 1; i++) {
    const cand = line.stops.slice();
    cand.splice(i + 1, 0, nodeId);

    const s = lineScore(cand);
    if (s < bestScore) { bestScore = s; best = cand; }
  }

  line.stops = best || [...line.stops, nodeId];
  improveLineOrder(line);
}

  function autoLanesForLineType(type){
    if (type === "cargo") return CONFIG.AUTO_TRACK_LANES_CARGO;
    if (type === "mixed") return CONFIG.AUTO_TRACK_LANES_MIXED;
    return CONFIG.AUTO_TRACK_LANES_PASSENGER;
  }

  function ensureLineTracks(line){
    if (!line || !Array.isArray(line.stops) || line.stops.length < 2) return;

    const lanes = autoLanesForLineType(line.type);

    const pairs = [];
    for (let i=0;i<line.stops.length-1;i++) pairs.push([line.stops[i], line.stops[i+1]]);
    if (line.circular && line.stops.length >= 3) pairs.push([line.stops[line.stops.length-1], line.stops[0]]);

    for (const [a,b] of pairs){
      const key = edgeKey(a,b);
      const id = `TK-${key}`;
      if (!state.tracks.has(id)) addTrack(a,b,lanes, {silent:true});
    }
  }

  function renderLines(){
    layers.lines.clearLayers();

    for (const line of state.lines.values()){
      if (!Array.isArray(line.stops) || line.stops.length < 2) continue;

      ensureLineTracks(line); // AUTO BUILD INFRA for this service

      const latlngs = [];
      for (const id of line.stops){
        const n = state.nodes.get(id);
        if (n) latlngs.push([n.lat,n.lon]);
      }
      if (latlngs.length < 2) continue;

      if (line.circular && latlngs.length >= 3) latlngs.push(latlngs[0]);

      L.polyline(latlngs, {
        color: line.color,
        weight: line.id === state.activeLine ? 5 : 3.5,
        opacity: line.id === state.activeLine ? 0.90 : 0.62,
        dashArray: line.type === "cargo" ? "10,10" : null
      }).addTo(layers.lines)
        .bindTooltip(`${line.name} (${line.type}) • freq ${line.frequencyPerDay}/day • cap ${line.vehicleCapacity}${line.type==="cargo"?"t":" pax"}${line.circular ? " ⟳" : ""}`);
    }
  }

  // ======================
  // Node selection logic
  // ======================
  function selectNode(nodeId){
    const node = state.nodes.get(nodeId);
    if (!node) return;

    state.selectedNode = node;

    // Refresh cluster active styling if relevant
    if (map.getZoom() <= CONFIG.CLUSTER_VIEW_MAX_ZOOM) renderClusterMarkers();

    // Track build mode
    if (state.activeTab === "tracks" && state.trackBuildMode) {
      handleTrackBuildClick(node);
      return;
    }

    // Line build mode
if (state.activeLine && state.lines.has(state.activeLine) && state.lineBuildMode) {
  const line = state.lines.get(state.activeLine);
  addStopSmart(line, nodeId);
  showToast(`Added stop: ${node.name}`, "success");
  renderLines();
  updateUI();
  return;
}


    map.setView([node.lat, node.lon], Math.max(map.getZoom(), 8));
  }

  // ======================
  // Simulation
  // ======================
  function simulateYear(){
    try {
      state.year++;
      state.budget += state.annualBudget;

      // Economy: uses tracks + lines properties (freq/cap/speed)
      computeEconomy(state, map);

      showToast(
        `Year ${state.year} simulated. Profit: ${formatCurrency(state.profit)}`,
        state.profit >= 0 ? "success" : "error"
      );

      updateUI();
    } catch (e) {
      console.error(e);
      showToast("Simulation crashed", "error");
      // If user can't open DevTools, show error text in panel footer:
      const panel = document.getElementById("controlPanel");
      panel.insertAdjacentHTML("beforeend", `<div class="hint" style="margin-top:10px;border-color:#fecaca;color:#991b1b;">${String(e)}</div>`);
    }
  }

  // ======================
  // UI actions
  // ======================
  function switchTab(tab){
    state.activeTab = tab;
    if (tab !== "tracks") {
      state.trackBuildMode = false;
      state.pendingTrackNode = null;
    }
    updateUI();
  }

  function setTrackBuildMode(on){
    state.trackBuildMode = !!on;
    state.pendingTrackNode = null;
    updateUI();
    showToast(on ? "Track mode ON: click nodes to chain-build" : "Track mode OFF", on ? "success" : "warning");
  }

  function setTrackLanes(n){
    state.pendingTrackLanes = clamp(Number(n)||1, 1, 8);
    updateUI();
  }

  function createNewLine(){
    const name = document.getElementById("lineName")?.value?.trim() || "New Line";
    const type = document.getElementById("lineType")?.value || "passenger";
    const circular = !!document.getElementById("lineCircular")?.checked;

    addLine(name, type, circular);

    // override defaults if user set
    const ln = state.lines.get(state.activeLine);
    if (ln) {
      ln.frequencyPerDay = clamp(Number(document.getElementById("lineFreq")?.value || ln.frequencyPerDay), 0, 200);
      ln.vehicleCapacity = clamp(Number(document.getElementById("lineCap")?.value || ln.vehicleCapacity), 1, 5000);
      ln.speedKmh = clamp(Number(document.getElementById("lineSpeed")?.value || ln.speedKmh), 40, 320);
    }

    renderLines();
    updateUI();
  }

  function selectLine(id){
    state.activeLine = id;
    renderLines();
    updateUI();
  }

  function toggleCircularActive(){
    const line = state.lines.get(state.activeLine);
    if (!line) return;
    line.circular = !line.circular;
    renderLines();
    updateUI();
    showToast(line.circular ? "Line set to circular" : "Line set to non-circular", "success");
  }

  function toggleLineBuildMode(){
    state.lineBuildMode = !state.lineBuildMode;
    updateUI();
    showToast(state.lineBuildMode ? "Line building ON" : "Line building OFF", "info");
  }

  function deleteActiveLine(){
    const id = state.activeLine;
    if (!id) return;
    if (!confirm("Delete active line?")) return;
    state.lines.delete(id);
    state.activeLine = null;
    renderLines();
    updateUI();
    showToast("Line deleted", "warning");
  }

  function clearAllTracks(){
    layers.tracks.clearLayers();
    layers.trackLabels.clearLayers();
    state.tracks.clear();
    state.pendingTrackNode = null;
    renderLines();
    updateUI();
    showToast("Cleared all tracks", "warning");
  }

  function kv(k, v){ return `<span class="k">${k}:</span> <span class="v">${v}</span>`; }

  function updateUI(){
    const panel = document.getElementById("controlPanel");

    const linesArr = Array.from(state.lines.values());
    const linesList = linesArr.map(l => `
      <div class="item ${l.id===state.activeLine ? "active" : ""}" onclick="selectLine('${l.id}')">
        <div style="font-weight:1000;color:#0f172a">${l.name}${l.circular ? " ⟳" : ""}</div>
        <div style="font-size:12px;font-weight:900;color:#64748b">
          ${l.stops.length} stops • ${l.type} • ${l.frequencyPerDay}/day
<div class="row" style="margin-top:10px;">
  <button class="btn secondary" onclick="saveGame()">Save</button>
  <button class="btn secondary" onclick="loadGame()">Load</button>
</div>

        </div>
      </div>
    `).join("");

    const activeCluster = state.activeClusterId ? state.clusters.get(state.activeClusterId) : null;

    const econ = state.economy || {};
    const exporterName = econ.biggestExporter?.id ? (state.nodes.get(econ.biggestExporter.id)?.name || econ.biggestExporter.id) : "—";
    const importerName = econ.biggestImporter?.id ? (state.nodes.get(econ.biggestImporter.id)?.name || econ.biggestImporter.id) : "—";

    panel.innerHTML = `
      <div class="section">
        <h3 class="title">Railway Network Simulator</h3>
        <p class="sub">
          Year: <b>${state.year}</b> • Budget: <b>${formatCurrency(state.budget)}</b>
          ${activeCluster ? `<span class="badge">In: ${activeCluster.hubName}</span>` : `<span class="badge">Spain</span>`}
        </p>

        <div class="tabs">
          <div class="tab ${state.activeTab==="network"?"active":""}" onclick="switchTab('network')">Network</div>
          <div class="tab ${state.activeTab==="tracks"?"active":""}" onclick="switchTab('tracks')">Tracks</div>
          <div class="tab ${state.activeTab==="economy"?"active":""}" onclick="switchTab('economy')">Economy</div>
        </div>
      </div>

      ${state.activeTab==="network" ? `
        <div class="section">
          <div class="hint">
            <b>Clusters are dots:</b> left-click selects, right-click zooms in.<br>
            <b>Smart lines:</b> stops are auto-ordered to reduce criss-cross, and tracks are auto-built between stops.
          </div>

          <button class="btn success" onclick="simulateYear()">Simulate Next Year</button>
        </div>

        <div class="section">
          <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Create Line</div>
          <input id="lineName" class="field" placeholder="Line name" />
          <div style="height:8px"></div>
          <select id="lineType" class="field">
            <option value="passenger">Passenger</option>
            <option value="cargo">Cargo</option>
            <option value="mixed">Mixed</option>
          </select>

          <div style="height:8px"></div>
          <div class="row">
            <input id="lineFreq" class="field" type="number" min="0" max="200" step="1" placeholder="Trips/day (e.g. 18)">
            <input id="lineCap" class="field" type="number" min="1" max="5000" step="1" placeholder="Capacity (pax or tons)">
          </div>
          <div style="height:8px"></div>
          <input id="lineSpeed" class="field" type="number" min="40" max="320" step="5" placeholder="Speed km/h (e.g. 160)">

          <div style="height:8px"></div>
          <label style="display:flex;gap:10px;align-items:center;font-weight:900;color:#334155;">
            <input id="lineCircular" type="checkbox" />
            Circular line
          </label>

          <button class="btn" onclick="createNewLine()">Create Line</button>

          <button class="btn secondary" onclick="toggleLineBuildMode()">
            ${state.lineBuildMode ? "Stop Adding Stops: ON" : "Stop Adding Stops: OFF"}
          </button>
        </div>

        <div class="section">
          <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Lines</div>
          <div class="list">${linesList || `<div style="padding:14px;color:#64748b;font-weight:1000;">No lines yet</div>`}</div>

          <div class="row" style="margin-top:10px;">
            <button class="btn secondary" onclick="toggleCircularActive()">Toggle circular</button>
            <button class="btn danger" onclick="deleteActiveLine()">Delete line</button>
          </div>
        </div>
      ` : ""}

      ${state.activeTab==="tracks" ? `
        <div class="section">
          <div class="hint">
            Track mode chain-builds: A→B, then B→C automatically.<br>
            Tracks are drawn in <b>black</b>. Lane count is shown as a <b>white number</b>.
          </div>

          <button class="btn ${state.trackBuildMode ? "warning" : "success"}"
            onclick="setTrackBuildMode(${!state.trackBuildMode})">
            ${state.trackBuildMode ? "Track Mode: ON" : "Track Mode: OFF"}
          </button>

          <div style="margin-top:10px;">
            <div class="k">Lanes</div>
            <select class="field" onchange="setTrackLanes(this.value)">
              <option value="1" ${state.pendingTrackLanes===1?"selected":""}>1 lane</option>
              <option value="2" ${state.pendingTrackLanes===2?"selected":""}>2 lanes</option>
              <option value="3" ${state.pendingTrackLanes===3?"selected":""}>3 lanes</option>
              <option value="4" ${state.pendingTrackLanes===4?"selected":""}>4 lanes</option>
              <option value="5" ${state.pendingTrackLanes===5?"selected":""}>5 lanes</option>
              <option value="6" ${state.pendingTrackLanes===6?"selected":""}>6 lanes</option>
            </select>
          </div>

          <div class="hint" style="margin-top:10px;">
            Current start node: <b>${state.pendingTrackNode ? state.pendingTrackNode.name : "—"}</b>
          </div>

          <button class="btn danger" onclick="clearAllTracks()">Clear ALL tracks</button>
        </div>
      ` : ""}

      ${state.activeTab==="economy" ? `
        <div class="section">
          <div class="hint">
            Economy now uses <b>flows</b> (passenger-km & ton-km) limited by <b>service capacity</b> (freq × vehicle capacity) and <b>track capacity</b> (lanes).
          </div>
          <div style="margin-top:10px;">
            <div>${kv("Annual revenue", formatCurrency(state.revenue))}</div>
            <div>${kv("Annual costs", formatCurrency(state.costs))}</div>
            <div>${kv("Annual profit", `<span style="color:${state.profit>=0?"#10b981":"#ef4444"}">${formatCurrency(state.profit)}</span>`)}</div>
          </div>

          <div style="margin-top:10px;" class="hint">
            <div>${kv("Passenger-km moved", fmtNum(Math.round(econ.paxKmMoved || 0)))}</div>
            <div>${kv("Cargo ton-km moved", fmtNum(Math.round(econ.tonKmMoved || 0)))}</div>
            <div>${kv("Biggest exporter", `${exporterName} (${formatCurrency(econ.biggestExporter?.exports || 0)})`)}</div>
            <div>${kv("Biggest needs", `${importerName} (${formatCurrency(econ.biggestImporter?.imports || 0)})`)}</div>
          </div>

          <button class="btn warning" onclick="simulateYear()">Simulate Next Year</button>
        </div>
      ` : ""}
    `;
  }

  // ======================
  // Init
  // ======================
  async function boot(){
    initMap();

    const cities = await loadJSON("./cities_es.json");
    state.cities = Array.isArray(cities) ? cities : (Array.isArray(cities?.cities) ? cities.cities : cities);

    buildClusters(state.cities);
    renderClusterMarkers();

    syncMarkerVisibility();
    updateClusterBar();
    updateUI();

    showToast(`Loaded cities: ${fmtNum(state.cities.length)} • clusters: ${fmtNum(state.clusters.size)}`, "success");
  }

  // expose globals for inline onclick
  window.switchTab = switchTab;
  window.simulateYear = simulateYear;
  window.setTrackBuildMode = setTrackBuildMode;
  window.setTrackLanes = setTrackLanes;
  window.createNewLine = createNewLine;
  window.selectLine = selectLine;
  window.toggleCircularActive = toggleCircularActive;
  window.toggleLineBuildMode = toggleLineBuildMode;
  window.deleteActiveLine = deleteActiveLine;
  window.clearAllTracks = clearAllTracks;

  boot().catch(err => {
    console.error(err);
    showToast("Failed to load data files", "error");
    document.getElementById("controlPanel").innerHTML = `
      <div class="section">
        <h3 class="title">Load error</h3>
        <div class="hint">
          ${String(err)}<br><br>
          Make sure these files sit next to <code>index.html</code>:<br>
          • <b>cities_es.json</b><br>
          • <b>economy.js</b><br><br>
          Run a local server, e.g. <code>python -m http.server 8000</code>
        </div>
      </div>
    `;
  });

function saveGame(){
  const data = {
    year: state.year,
    budget: state.budget,
    revenue: state.revenue,
    costs: state.costs,
    profit: state.profit,
    activeClusterId: state.activeClusterId,

    // tracks + lines are Maps, convert to arrays
    tracks: Array.from(state.tracks.values()).map(t => ({
      id: t.id, from: t.from, to: t.to, lanes: t.lanes
    })),
    lines: Array.from(state.lines.values()).map(l => ({
      id: l.id, name: l.name, type: l.type, color: l.color,
      stops: l.stops, circular: l.circular
    }))
  };

  localStorage.setItem("railSimSave", JSON.stringify(data));
  showToast("Saved!", "success");
}

function loadGame(){
  const raw = localStorage.getItem("railSimSave");
  if (!raw) { showToast("No save found", "warning"); return; }

  const data = JSON.parse(raw);

  state.year = data.year ?? state.year;
  state.budget = data.budget ?? state.budget;
  state.revenue = data.revenue ?? 0;
  state.costs = data.costs ?? 0;
  state.profit = data.profit ?? 0;
  state.activeClusterId = data.activeClusterId ?? null;

  // clear visuals + state
  layers.tracks.clearLayers();
  layers.lines.clearLayers();
  state.tracks.clear();
  state.lines.clear();

  // rebuild tracks (visual + state)
  for (const t of (data.tracks || [])) addTrack(t.from, t.to, t.lanes || 1);

  // rebuild lines
  for (const l of (data.lines || [])) {
    state.lines.set(l.id, {
      id: l.id, name: l.name, type: l.type, color: l.color,
      stops: Array.isArray(l.stops) ? l.stops : [],
      circular: !!l.circular,
      cursorStopId: null
    });
  }

  // set active line if any
  const firstLine = Array.from(state.lines.keys())[0] || null;
  state.activeLine = firstLine;

  // restore cluster view if needed
  if (state.activeClusterId) {
    const cl = state.clusters.get(state.activeClusterId);
    if (cl) map.fitBounds(cl.bounds.pad(0.25), { maxZoom: 11 });
  } else {
    map.setView(CONFIG.SPAIN_VIEW.center, CONFIG.SPAIN_VIEW.zoom);
  }

  renderLines();
  syncMarkerVisibility();
  updateClusterBar();
  updateUI();
  showToast("Loaded!", "success");
}

// expose to onclick buttons
window.saveGame = saveGame;
window.loadGame = loadGame;

</script>
</body>
</html>
