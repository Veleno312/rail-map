/* global CONFIG, L, PROD_ITEMS, TRAIN_SPEEDS, TRAIN_SPEED_CLASSES, addLine, addTrack, autoGenerateDepartures, autoLanesForLineType, buildClusters, calculateTrackCost, calendar_advanceDay, calendar_label, clamp, clearAllTracks, clock_start, clock_stop, computeRetailRentEURPerYear, computeStationPressure, construction_advanceDay, construction_cancelQueued, construction_resolveIssue, construction_startJobs, createNewLine, deleteActiveLine, downloadJSON, dynFlow_render, economy_initInvestments, economy_monthTick, edgeKey, fmtNum, formatCurrency, getCountryCatalog, getCountrySpec, getCountryUnlockRule, getNodeLineCount, getNodeTrackStats, getStation, hash01, hhmmToMin, hideNodeHover, importOsmRailTracks, initMap, layers, lineDefaults, line_calcDerivedMetrics, line_estimateTravelMin, line_isTrackReady, line_operatingCostEURPerDay, line_recalcDerived, line_trainMaintenanceCostEURPerYear, loadJSON, luti_computeAccessibility, luti_monthlyPopulationUpdate, luti_topContributors, makeEvenDepartures, map, map_applyTheme, minToHHMM, network_operatingCostEURPerDay, opt_autoBuildNetwork, opt_boostFrequencies, production_buildNodeStats, production_getNode, production_init, production_modalSplit, production_primaryItem, production_topSubitems, rebuildNodesFromCities, renderClusterMarkers, renderCountryBorder, render_network, render_overlay, renderGraph_buildTrackAdj, renderGraph_shortestPath, renderLines, renderStationBusyness, selectLine, selectNode, service_activeTrainsOnLine, service_estimateLineTravelMin, service_latLngAtDistance, service_refreshRunVisibility, service_runDistanceAtElapsed, service_spawnRun, setActiveLineCarriages, setActiveLineColor, setActiveLineNumber, setActiveLineSpeedClass, setClockSpeed, setClockSpeedFromSlider, setLineBuildMode, setTrackBuildAction, setTrackBuildMode, setTrackLanes, showNodeHover, showToast, simulateYear, state, stationUpgradeCost, switchTab, syncMarkerVisibility, toast, toggleCircularActive, toggleLineBuildMode, track_applyStyle, track_hideAllLabels, track_updateVisibility, trainVis_clearAll, uiClock_updateInline, ui_captureError, ui_centerOnNodeId, ui_centerOnSelected, ui_lineDiagram_stopClick, ui_lineEnsure, ui_lineRecalcTrainsFromDepartures, ui_lineRuntimeMin, ui_lineSchedulePanelHtml, ui_renderLineDiagram, ui_renderLineLegend, ui_renderLutiReport, ui_startLineAtSelected, ui_toggleAddStops, ui_updateActiveTrainsCount, undo_applyLast, undo_pushAction, unlock_initState, unlock_refreshMetrics, updateClusterBar, updateUI, upgradeStation, offlineCache_saveManifest, offlineCache_savePack, offlineCache_getLatestManifest, offlineCache_getPackForDataset, applyScenarioToState */  
/* exported TRAIN_SPEEDS, TRAIN_SPEED_CLASSES, buildClusters, calendar_advanceDay, clearAllTracks, computeRetailRentEURPerYear, computeStationPressure, construction_advanceDay, construction_cancelQueued, construction_resolveIssue, construction_fireCrew, construction_hireCrew, createNewLine, deleteActiveLine, downloadJSON, economy_monthTick, ensureDefaultTestLine, getNodeLineCount, getNodeTrackStats, hash01, hhmmToMin, hideNodeHover, importOsmRailTracks, initMap, lineDefaults, line_estimateTravelMin, line_isTrackReady, loadJSON, luti_computeAccessibility, luti_monthlyPopulationUpdate, opt_autoBuildNetwork, opt_boostFrequencies, opt_bearingDeg, production_buildNodeStats, production_init, production_primaryItem, production_modalSplit, rebuildNodesFromCities, renderStationBusyness, selectLine, selectNode, service_activeTrainsOnLine, service_estimateLineTravelMin, service_latLngAtDistance, service_runDistanceAtElapsed, service_spawnRun, setActiveLineCarriages, setActiveLineColor, setActiveLineNumber, setActiveLineSpeedClass, setClockSpeed, setClockSpeedFromSlider, setLineBuildMode, setTrackBuildAction, setTrackBuildMode, setTrackLanes, showNodeHover, showToast, simulateYear, switchTab, toast, toggleCircularActive, track_applyStyle, track_updateVisibility, trainVis_clearAll, uiClock_updateInline, ui_captureError, ui_centerOnNodeId, ui_centerOnSelected, ui_lineDiagram_stopClick, ui_lineEnsure, ui_lineRecalcTrainsFromDepartures, ui_lineRuntimeMin, ui_lineNumberTag, ui_renderLineDiagram, ui_renderLutiReport, ui_startLineAtSelected, ui_toggleAddStops, ui_toggleClockDisplay, ui_toggleTrackPlanning, ui_updateActiveTrainsCount, ui_copyReportRunId, undo_applyLast, undo_pushAction, unlock_initState, unlock_refreshMetrics, updateClusterBar, updateUI, upgradeStation, construction_startJobs, dynFlow_render, economy_initInvestments, edgeKey, getCountryCatalog, getCountryUnlockRule, getStation, importOsmRailTracks, makeEvenDepartures, network_operatingCostEURPerDay, production_buildNodeStats, production_getNode, line_calcDerivedMetrics, ui_cacheManifest, ui_cachePack, ui_loadCachedPack, ui_updateScenarioCacheStatus, ui_toggleOnlineMode */ 
// ======================
// Mode bar + hotkeys
// ======================
let uiHotkeysInstalled = false;

function uiMode_compute(){
  if (state.primaryTab === "production") {
    return {
      label: "INDUSTRY",
      pill: "P",
      detail: "Hover nodes for industry details",
      cursor: ""
    };
  }
// Track build mode has priority
if (state.trackBuildMode) {
  const start = state.pendingTrackNode ? state.pendingTrackNode.name : "";
  const isDemolish = state.trackBuildAction === "demolish";
  return {
    label: isDemolish ? "DEMOLISH TRACK" : "BUILD TRACK",
    pill: isDemolish ? "D" : "B",
    detail: isDemolish ? "Click a segment to schedule demolition" : `Chain start: ${start || "(none)"}`,
    cursor: isDemolish ? "not-allowed" : "crosshair"
  };
}

// Line build mode (only if a line is selected)
if (state.activeLine && state.lineBuildMode) {
  const ln = state.lines?.get?.(state.activeLine);
  return {
    label: "BUILD LINE",
    pill: "L",
    detail: `Active: ${ln?.name || state.activeLine}`,
    cursor: "copy"
  };
}

// Line selected, but building off
if (state.activeLine && !state.lineBuildMode) {
  const ln = state.lines?.get?.(state.activeLine);
  return {
    label: "INSPECT (line selected)",
    pill: "I",
    detail: `Active: ${ln?.name || state.activeLine} ‚Ä¢ add stops OFF`,
    cursor: ""
  };
}

// Default
return {
  label: "INSPECT",
  pill: "I",
  detail: "Click nodes to inspect/select",
  cursor: ""
};
}

function ui_toggleMapTheme(){
  const next = (state.mapTheme === "metro") ? "default" : "metro";
  if (typeof map_applyTheme === "function") {
    map_applyTheme(next);
  } else {
    state.mapTheme = next;
  }
  updateUI();
}

function ui_toggleWorldView(){
  state.worldView = !state.worldView;
  if (map) {
    const view = state.worldView ? CONFIG.WORLD_VIEW : (state.countryView || CONFIG.SPAIN_VIEW);
    map.setView(view.center, view.zoom);
  }
  if (typeof renderCountryBorder === "function") renderCountryBorder();
  updateUI();
}

window.ui_toggleMapTheme = ui_toggleMapTheme;
window.ui_toggleWorldView = ui_toggleWorldView;

function ui_toggleKPIDashboard(){
  if (window.kpiDashboard) {
    window.kpiDashboard.toggle();
  } else {
    showToast('KPI Dashboard not available', 'error');
  }
}

function ui_toggleEventTimeline(){
  if (window.eventTimeline) {
    window.eventTimeline.toggle();
  } else {
    showToast('Event timeline not available', 'error');
  }
}

window.ui_toggleKPIDashboard = ui_toggleKPIDashboard;
window.ui_toggleEventTimeline = ui_toggleEventTimeline;

const tabNames = {
  network: "Network",
  tracks: "Transport",
  economy: "Economy",
  dynamics: "Dynamics"
};
const primaryTabs = [
  { id: "production", label: "Industry", icon: "üè≠" },
  { id: "population", label: "Population", icon: "üåÜ" }
];
const subTabOrder = ["network", "tracks", "economy", "dynamics"];
const subTabIcons = {
  network: "üß≠",
  tracks: "üöÜ",
  economy: "üíº",
  dynamics: "‚öôÔ∏è"
};
const bottomTabBarId = "bottomTabBar";

function uiMode_render(){
const el = document.getElementById("modeBar");
if (!el) return;

const m = uiMode_compute();

el.innerHTML = `
  <div class="row">
    <div class="mode">${m.label}</div>
    <span class="pill">${m.pill}</span>
  </div>
  <div class="detail">${m.detail}</div>
  <div class="keys" id="simClock">${uiClock_label()}</div>
  <div class="row" style="margin-top:6px;gap:6px;">
    <button class="btn secondary" style="width:auto;padding:6px 8px;margin-top:0;" onclick="ui_toggleClockRunning()">${state.clock?.running ? "Pause" : "Play"}</button>
    <button class="btn secondary" style="width:auto;padding:6px 8px;margin-top:0;" onclick="ui_toggleClockDisplay()">Analog/Digital</button>
  </div>
  <div class="row" style="margin-top:6px;gap:6px;">
    <button class="btn secondary" style="width:auto;padding:6px 8px;margin-top:0;" onclick="ui_toggleMapTheme()">
      ${state.mapTheme === "metro" ? "Metro On" : "Metro Off"}
    </button>
    <button class="btn secondary" style="width:auto;padding:6px 8px;margin-top:0;" onclick="ui_toggleWorldView()">
      ${state.worldView ? "Country View" : "World View"}
    </button>
  </div>
  <div class="row" style="margin-top:6px;gap:6px;">
    <button class="btn secondary" style="width:auto;padding:6px 8px;margin-top:0;" onclick="ui_toggleKPIDashboard()">
      KPI Dashboard
    </button>
    <button class="btn secondary" style="width:auto;padding:6px 8px;margin-top:0;" onclick="ui_toggleEventTimeline()">
      Events
    </button>
  </div>
  <div style="margin-top:6px;">
    <div style="font-size:11px;font-weight:900;color:rgba(255,255,255,0.6);margin-bottom:4px;">Time speed <span id="clockSpeedVal">${ui_clockSpeedLabel()}</span></div>
    <input type="range" min="0" max="100" step="1" value="${ui_clockSliderValue()}" list="clockSpeedTicks"
      oninput="setClockSpeedFromSlider(this.value, true)" onchange="setClockSpeedFromSlider(this.value)" style="width:100%;">
    <datalist id="clockSpeedTicks">
      <option value="0" label="1m/s"></option>
      <option value="40" label="1h/s"></option>
      <option value="70" label="1d/s"></option>
      <option value="100" label="1w/s"></option>
    </datalist>
    <div style="display:flex;justify-content:space-between;font-size:10px;color:rgba(255,255,255,0.5);margin-top:4px;">
      <span>1m/s</span><span>1h/s</span><span>1d/s</span><span>1w/s</span>
    </div>
  </div>
  <div style="margin-top:8px; text-align:center;">
    <button class="btn warning" onclick="simulateYear()">Skip 1 Year</button>
  </div>
`;


// Cursor feedback on the map
try {
  if (map && map.getContainer) map.getContainer().style.cursor = m.cursor || "";
} catch { /* ignore */ }
}

// Small inline clock that lives where the hotkey hint used to be (upper-right).
function uiClock_label(){
const tMin = Number(state.clock?.tMin || 0);
const t = minToHHMM(tMin);
const run = state.clock?.running ? "RUN" : "PAUSE";
const spd = Math.round(Number(state.clock?.speed || 60));
const mode = state.clock?.display || "analog";

if (mode === "analog") {
  const fast = spd >= 1440;

  if (fast) {
    const c = state.calendar || { day: 1, daysPerMonth: 30 };
    const day = Number(c.day || 1);
    const days = Math.max(1, Number(c.daysPerMonth || 30));
    const dayDeg = ((day - 1) / days) * 360;

    return `
      <div style="display:flex;align-items:center;gap:8px;">
        <div style="position:relative;width:40px;height:40px;border:2px solid rgba(255,255,255,0.7);border-radius:999px;">
          <div style="position:absolute;left:50%;top:50%;width:2px;height:18px;background:#fff;transform-origin:bottom center;transform:translate(-50%,-100%) rotate(${dayDeg}deg);"></div>
          <div style="position:absolute;left:50%;top:50%;width:4px;height:4px;background:#fff;border-radius:999px;transform:translate(-50%,-50%);"></div>
          <div style="position:absolute;left:4px;top:3px;font-size:9px;color:rgba(255,255,255,0.7);">1</div>
          <div style="position:absolute;right:4px;top:3px;font-size:9px;color:rgba(255,255,255,0.7);">${Math.min(15, days)}</div>
          <div style="position:absolute;left:4px;bottom:2px;font-size:9px;color:rgba(255,255,255,0.7);">${Math.max(1, Math.floor(days/2))}</div>
          <div style="position:absolute;right:2px;bottom:2px;font-size:9px;color:rgba(255,255,255,0.7);">${days}</div>
        </div>
        <div style="line-height:1.1;">
          <div>${run} ${calendar_label()} Day ${day}</div>
          <div style="opacity:0.7;">${ui_clockSpeedLabel()}</div>
        </div>
      </div>
    `;
  }

  const hh = Math.floor(tMin / 60) % 12;
  const mm = tMin % 60;
  const hourDeg = (hh + mm / 60) * 30;
  const minDeg = mm * 6;

  return `
    <div style="display:flex;align-items:center;gap:8px;">
      <div style="position:relative;width:36px;height:36px;border:2px solid rgba(255,255,255,0.7);border-radius:999px;">
        <div style="position:absolute;left:50%;top:50%;width:2px;height:12px;background:#fff;transform-origin:bottom center;transform:translate(-50%,-100%) rotate(${hourDeg}deg);"></div>
        <div style="position:absolute;left:50%;top:50%;width:2px;height:16px;background:#fff;transform-origin:bottom center;transform:translate(-50%,-100%) rotate(${minDeg}deg);"></div>
        <div style="position:absolute;left:50%;top:50%;width:4px;height:4px;background:#fff;border-radius:999px;transform:translate(-50%,-50%);"></div>
      </div>
      <div style="line-height:1.1;">
        <div>${run} ${calendar_label()} ${t}</div>
        <div style="opacity:0.7;">${ui_clockSpeedLabel()}</div>
      </div>
    </div>
  `;
}

return `${run} ${calendar_label()} ${t}  |  x${spd}`;
}

function uiClock_updateInline(){
const el = document.getElementById("simClock");
if (!el) return;
el.innerHTML = uiClock_label();
}

function ui_toggleClockDisplay(){
if (!state.clock) state.clock = { tMin: 8*60, running: true, speed: 60, display: "analog" };
state.clock.display = (state.clock.display === "analog") ? "digital" : "analog";
uiClock_updateInline();
}

function ui_toggleClockRunning(){
if (!state.clock) state.clock = { tMin: 8*60, running: true, speed: 60, display: "analog" };
if (state.clock.running) {
  if (typeof clock_stop === "function") clock_stop();
  else state.clock.running = false;
} else {
  if (typeof clock_start === "function") clock_start();
  else state.clock.running = true;
}
uiClock_updateInline();
updateUI();
}

const CLOCK_SPEED_PRESETS = [1, 60, 1440, 10080];
const CLOCK_SPEED_LABELS = ["1m/s", "1h/s", "1d/s", "1w/s"];
const CLOCK_SLIDER_TICKS = [0, 40, 70, 100];

function ui_clockSliderValue(){
  return Math.round(ui_sliderFromSpeed(Number(state.clock?.speed || 60)));
}

function ui_clockSpeedLabel(){
  const spd = Number(state.clock?.speed || 60);
  let bestIdx = 0;
  let bestDiff = Infinity;
  for (let i = 0; i < CLOCK_SPEED_PRESETS.length; i++) {
    const d = Math.abs(CLOCK_SPEED_PRESETS[i] - spd);
    if (d < bestDiff) { bestDiff = d; bestIdx = i; }
  }
  return `${CLOCK_SPEED_LABELS[bestIdx]} (x${Math.round(spd)})`;
}

function ui_speedFromSlider(v){
  const x = clamp(Number(v || 0), 0, 100);

  if (x <= CLOCK_SLIDER_TICKS[1]) {
    const t = x / CLOCK_SLIDER_TICKS[1];
    return CLOCK_SPEED_PRESETS[0] + t * (CLOCK_SPEED_PRESETS[1] - CLOCK_SPEED_PRESETS[0]);
  }
  if (x <= CLOCK_SLIDER_TICKS[2]) {
    const t = (x - CLOCK_SLIDER_TICKS[1]) / (CLOCK_SLIDER_TICKS[2] - CLOCK_SLIDER_TICKS[1]);
    return CLOCK_SPEED_PRESETS[1] + t * (CLOCK_SPEED_PRESETS[2] - CLOCK_SPEED_PRESETS[1]);
  }

  const t = (x - CLOCK_SLIDER_TICKS[2]) / (CLOCK_SLIDER_TICKS[3] - CLOCK_SLIDER_TICKS[2]);
  return CLOCK_SPEED_PRESETS[2] + t * (CLOCK_SPEED_PRESETS[3] - CLOCK_SPEED_PRESETS[2]);
}

function ui_sliderFromSpeed(spd){
  const s = clamp(Number(spd || 60), CLOCK_SPEED_PRESETS[0], CLOCK_SPEED_PRESETS[3]);

  if (s <= CLOCK_SPEED_PRESETS[1]) {
    const t = (s - CLOCK_SPEED_PRESETS[0]) / (CLOCK_SPEED_PRESETS[1] - CLOCK_SPEED_PRESETS[0]);
    return CLOCK_SLIDER_TICKS[0] + t * (CLOCK_SLIDER_TICKS[1] - CLOCK_SLIDER_TICKS[0]);
  }
  if (s <= CLOCK_SPEED_PRESETS[2]) {
    const t = (s - CLOCK_SPEED_PRESETS[1]) / (CLOCK_SPEED_PRESETS[2] - CLOCK_SPEED_PRESETS[1]);
    return CLOCK_SLIDER_TICKS[1] + t * (CLOCK_SLIDER_TICKS[2] - CLOCK_SLIDER_TICKS[1]);
  }

  const t = (s - CLOCK_SPEED_PRESETS[2]) / (CLOCK_SPEED_PRESETS[3] - CLOCK_SPEED_PRESETS[2]);
  return CLOCK_SLIDER_TICKS[2] + t * (CLOCK_SLIDER_TICKS[3] - CLOCK_SLIDER_TICKS[2]);
}

function setClockSpeedFromSlider(v, silent=false){
  const spd = ui_speedFromSlider(v);
  setClockSpeed(spd, silent);
}

function setClockSpeed(v, silent=false){
if (!state.clock) state.clock = { tMin: 8*60, running: true, speed: 60, display: "analog" };
const spd = clamp(Number(v || 60), 1, 10080);
state.clock.speed = spd;
const el = document.getElementById("clockSpeedVal");
if (el) el.textContent = ui_clockSpeedLabel();
uiClock_updateInline();
if (!silent) showToast(`Clock speed: x${Math.round(spd)}`, "info");
}




function uiSetInspectMode(){
state.trackBuildMode = false;
state.pendingTrackNode = null;
if (typeof setLineBuildMode === "function") setLineBuildMode(false, { silent: true });
else state.lineBuildMode = false;
state.activeLine = null;

try { renderLines?.(); } catch { /* ignore */ }
updateUI();
showToast("Inspect mode", "info");
}

function uiCancelBuildModes(){
const wasAnything =
  !!state.pendingTrackNode || !!state.trackBuildMode || !!state.lineBuildMode;

state.pendingTrackNode = null;
state.trackBuildMode = false;
if (typeof setLineBuildMode === "function") setLineBuildMode(false, { silent: true });
else state.lineBuildMode = false;

try { renderLines?.(); } catch { /* ignore */ }
updateUI();

if (wasAnything) showToast("Cancelled build modes", "info");
}

function uiHotkeys_install(){
if (uiHotkeysInstalled) return;
uiHotkeysInstalled = true;

window.addEventListener("keydown", (e) => {
  // allow Esc always, but otherwise ignore if typing
  const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
  const typing = (tag === "input" || tag === "textarea" || tag === "select");

  const key = (e.key || "").toLowerCase();

  // Esc cancels even while typing
  if (key === "escape") {
    e.preventDefault();
    uiCancelBuildModes();
    return;
  }

  if (typing) return;
  if (e.ctrlKey || e.metaKey || e.altKey) return;

  if (key === "i") {
    e.preventDefault();
    uiSetInspectMode();
    return;
  }

  if (key === "t") {
    e.preventDefault();
    // entering track mode should disable line building to prevent surprises
    state.lineBuildMode = false;

    // Prefer existing helper if present
    if (typeof setTrackBuildMode === "function") {
      setTrackBuildMode(!state.trackBuildMode);
    } else {
      state.trackBuildMode = !state.trackBuildMode;
      state.pendingTrackNode = null;
      updateUI();
    }
    return;
  }

  if (key === "l") {
    e.preventDefault();
    // toggles line building, but only if a line is selected
    if (!state.activeLine) {
      showToast("Select a line first", "warning");
      return;
    }
    // turning on line mode should turn off track mode
    state.trackBuildMode = false;
    state.pendingTrackNode = null;

    if (typeof toggleLineBuildMode === "function") toggleLineBuildMode();
    else {
      state.lineBuildMode = !state.lineBuildMode;
      updateUI();
    }
    return;
  }

  if (key === "u") {
    e.preventDefault();
    if (typeof undo_applyLast === "function") undo_applyLast();
    else showToast("Undo not available", "warning");
    return;
  }
}, { passive: false });
}

// Alias for accidental wrong casing (prevents ReferenceError)
function uihotkeys_install(){ return uiHotkeys_install(); }

function ui_lineNumber(line){
  if (!line) return "";
  const n = Number(line.number);
  if (Number.isFinite(n) && n > 0) return String(Math.round(n));
  const m = String(line.name || "").match(/\b(\d+)\b/);
  return m ? m[1] : "";
}

function ui_lineNumberTag(line){
  const num = ui_lineNumber(line);
  return num ? `#${num}` : "";
}

function ui_lineDisplayName(line){
  if (!line) return "Line";
  const num = ui_lineNumber(line);
  const base = line.name || line.id || "Line";
  return num ? `#${num} ${base}` : base;
}

function ui_lineRuntimeMin(line){
if (!line || !Array.isArray(line.stops) || line.stops.length < 2) return 0;

const pts = line.stops.map(id => state.nodes.get(id)).filter(Boolean);
if (pts.length < 2) return 0;

// distance in meters
let meters = 0;
for (let i = 0; i < pts.length - 1; i++){
  const a = pts[i], b = pts[i+1];
  meters += map.distance([a.lat, a.lon], [b.lat, b.lon]);
}

const km = meters / 1000;
const speed = Math.max(10, Number(line.speedKmh || 120));

// ‚úÖ define travelMin
const travelMin = (km / speed) * 60;

// dwell time per segment (between stops)
const dwellMin = Math.max(0, Number(line.dwellSec || 0)) / 60;
const dwellTotal = Math.max(0, pts.length - 1) * dwellMin;

return travelMin + dwellTotal;
}

function ui_lineRecalcTrainsFromDepartures(line){
ui_lineEnsure(line);

const deps = (line.departures || []).map(Number).filter(Number.isFinite).sort((a,b)=>a-b);
const rt = ui_lineRuntimeMin(line);
if (deps.length === 0 || rt <= 0.05) { line.trains = 0; return; }

const events = [];
for (const d of deps){
  events.push([d, +1], [d + rt, -1]);
  events.push([d + 1440, +1], [d + 1440 + rt, -1]); // wrap-safe
}
events.sort((a,b)=>(a[0]-b[0]) || (a[1]-b[1]));

let cur=0, max=0;
for (const e of events){ cur += e[1]; if (cur>max) max=cur; }
line.trains = clamp(Math.ceil(max), 0, 50);
}

// ======================
// Schematic line diagram (Barcelona-style, simple)
// ======================
function ui_lineDiagramHtml(line){
if (!line || !Array.isArray(line.stops) || line.stops.length < 2) {
  return `<div style="padding:10px;color:#64748b;font-weight:900;">Add at least 2 stops to see the line diagram.</div>`;
}

const stops = line.stops.map(id => state.nodes.get(id)).filter(Boolean);
const n = stops.length;
if (n < 2) return `<div style="padding:10px;color:#64748b;font-weight:900;">Stops missing node data.</div>`;

const runs = (state.service?.runs || []).filter(r => r.lineId === line.id);
const allowedConnTypes = (state.primaryTab === "production")
  ? ["cargo", "mixed"]
  : ["passenger", "mixed"];
const topPad = 26;
const stopSpacing = 50;
const height = topPad + stops.length * stopSpacing + 20;
const trackX = 50; // %

const stopPos = new Map();
stops.forEach((s, i) => {
  stopPos.set(s.id, { x: trackX, y: topPad + i * stopSpacing });
});

const trimName = (val, maxLen) => {
  const s = (val || "").toString();
  return s.length > maxLen ? s.slice(0, Math.max(1, maxLen - 3)) + "..." : s;
};

const stopEls = stops.map((s, i) => {
  const pos = stopPos.get(s.id) || { x: trackX, y: topPad };
  const x = pos.x;
  const y = pos.y;
  const name = trimName(s.name || s.id || "", 16);
  const conn = [];
  const connSeen = new Set();
  for (const other of state.lines.values()){
    if (!other || other.id === line.id) continue;
    if (!allowedConnTypes.includes(other.type || "passenger")) continue;
    if (!Array.isArray(other.stops)) continue;
    if (other.stops.some(id => String(id) === String(s.id))){
      const num = ui_lineNumber(other);
      if (!num) continue;
      if (connSeen.has(num)) continue;
      connSeen.add(num);
      conn.push({ num, color: other.color || "#2b6cff" });
    }
  }
  const connIcons = conn.slice(0, 4).map(c => `
    <div style="width:16px;height:16px;border-radius:3px;background:${c.color};color:#fff;display:flex;align-items:center;justify-content:center;font-size:9px;font-weight:900;border:1px solid rgba(15,23,42,0.35);">
      ${escapeHtml(c.num)}
    </div>
  `).join("");
  const connExtra = conn.length > 4
    ? `<div style="font-size:9px;font-weight:900;color:#64748b;">+${conn.length - 4}</div>`
    : "";
  return `
    <div style="position:absolute;left:${x}%;top:${y}px;transform:translate(-50%,-50%);z-index:2;cursor:pointer;" onclick="ui_lineDiagram_stopClick('${s.id}')">
      <div style="width:10px;height:10px;border-radius:999px;background:#fff;border:2px solid #0f172a;"></div>
      <div style="position:absolute;left:${x}%;top:${y}px;transform:translate(-50%,-50%) translateX(-20px);text-align:right;max-width:80px;font-size:9px;font-weight:900;color:#334155;line-height:1.1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">
        ${escapeHtml(name)}
      </div>
      ${connIcons ? `
        <div style="position:absolute;left:${x}%;top:${y}px;transform:translate(-50%,-50%) translateX(20px);display:flex;gap:4px;align-items:center;white-space:nowrap;">
          ${connIcons}${connExtra}
        </div>
      ` : ""}
    </div>
  `;
}).join("");

const trainEls = runs.map((r) => {
  const p = Math.max(0, Math.min(1, Number(r.progress ?? 0)));
  const stopIndex = Math.min(stops.length - 1, Math.floor(p * stops.length));
  const nextIndex = Math.min(stops.length - 1, stopIndex + 1);
  const localT = (p * stops.length) - stopIndex;
  const pos1 = stopPos.get(stops[stopIndex].id);
  const pos2 = stopPos.get(stops[nextIndex].id);
  if (!pos1 || !pos2) return "";
  const x = trackX;
  const y = pos1.y + localT * (pos2.y - pos1.y);
  const base = line.color || "#38bdf8";
  const fill = (r.dir === -1) ? ui_invertHexColor(base) : base;
  return `
    <div title="Train" style="
      position:absolute;left:${x}%;top:${y}px;transform:translate(-50%,-50%);
      width:10px;height:10px;border-radius:999px;
      background:${fill};
      border:2px solid #0f172a;
      box-shadow:0 1px 0 rgba(0,0,0,0.06);
      z-index:3;
    "></div>
  `;
}).join("");

const linePath = `M ${trackX} ${topPad} L ${trackX} ${topPad + (stops.length - 1) * stopSpacing}`;
const zigLines = `
  <svg viewBox="0 0 100 ${height}" preserveAspectRatio="none" style="position:absolute;left:0;top:0;width:100%;height:100%;z-index:1;">
    <path d="${linePath}" fill="none" stroke="${line.color || "#38bdf8"}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
  </svg>
`;

return `
  <div style="position:relative;height:${height}px;border-radius:12px;border:1px solid rgba(15,23,42,0.10);background:#ffffff;overflow:hidden;">
    ${zigLines}
    ${trainEls}
    ${stopEls}
  </div>
`;
}

function ui_renderLineDiagram(){
const host = document.getElementById("lineDiagram");
if (!host) return;
const line = state.activeLine ? state.lines.get(state.activeLine) : null;
if (!line) { host.innerHTML = ""; return; }
host.innerHTML = ui_lineDiagramHtml(line);
}

// tiny HTML escape for stop labels
function escapeHtml(s){
return String(s)
  .replaceAll("&","&amp;")
  .replaceAll("<","&lt;")
  .replaceAll(">","&gt;")
  .replaceAll('"',"&quot;")
  .replaceAll("'","&#039;");
}

function ui_captureError(err, info = {}){
  if (!state.debug) state.debug = {};
  const msg = (err && err.message) ? String(err.message) : String(err);
  const stack = (err && err.stack) ? String(err.stack) : "";
  state.debug.lastError = {
    message: msg || "Unknown error",
    stack,
    time: Date.now(),
    source: String(info.source || ""),
    context: String(info.context || "")
  };
  ui_renderErrorBanner();
}

function ui_clearLastError(){
  if (!state.debug) state.debug = {};
  state.debug.lastError = null;
  ui_renderErrorBanner();
  updateUI();
}

function ui_openDebugDrawer(){
  const drawer = document.getElementById("debugDrawer");
  if (drawer) {
    drawer.open = true;
    try { drawer.scrollIntoView({ behavior: "smooth", block: "start" }); } catch { /* ignore */ }
  }
}

function ui_renderErrorBanner(){
  const banner = document.getElementById("errorBanner");
  if (!banner) return;
  const msgEl = document.getElementById("errorBannerMsg");
  const metaEl = document.getElementById("errorBannerMeta");
  const lastErr = state.debug?.lastError;
  if (!lastErr) {
    banner.classList.add("hidden");
    if (msgEl) msgEl.textContent = "";
    if (metaEl) metaEl.textContent = "";
    return;
  }
  banner.classList.remove("hidden");
  if (msgEl) msgEl.textContent = lastErr.message || "Unknown error";
  if (metaEl) {
    const when = lastErr.time ? new Date(lastErr.time).toLocaleString() : "";
    const source = lastErr.source ? ` - ${lastErr.source}` : "";
    metaEl.textContent = when ? `${when}${source}` : source;
  }
}

function ui_debugDrawerHtml(){
  const dbg = state.debug || {};
  const lastErr = dbg.lastError;
  const errStack = lastErr?.stack ? `<pre class="debug-pre">${escapeHtml(lastErr.stack)}</pre>` : "";
  const when = lastErr?.time ? new Date(lastErr.time).toLocaleString() : "";
  const source = lastErr?.source ? ` - ${escapeHtml(lastErr.source)}` : "";
  const stats = Array.isArray(dbg.lastSimStats) ? dbg.lastSimStats : [];
  const statsHtml = stats.length
    ? stats.map(([k, v]) => `<div>${kv(k, v)}</div>`).join("")
    : `<div class="hint">No stats recorded yet.</div>`;
  const errHtml = lastErr
    ? `
      <div class="debug-msg">${escapeHtml(lastErr.message || "Unknown error")}</div>
      ${when ? `<div class="debug-meta">${escapeHtml(when)}${source}</div>` : (source ? `<div class="debug-meta">${source}</div>` : "")}
      ${errStack}
      <button class="btn secondary" style="width:auto;padding:8px 10px;margin-top:8px;" onclick="ui_clearLastError()">Clear error</button>
    `
    : `<div class="hint">No errors recorded.</div>`;

  return `
    <details class="debug-drawer" id="debugDrawer">
      <summary>Debug</summary>
      <div class="debug-block">
        <div class="debug-title">Last error</div>
        ${errHtml}
      </div>
      <div class="debug-block">
        <div class="debug-title">Sim stats</div>
        <div class="debug-grid">${statsHtml}</div>
      </div>
    </details>
  `;
}

function runStateValidator(){
  const warnings = [];
  if (!(state.nodes instanceof Map) || state.nodes.size === 0) {
    warnings.push("No node data loaded yet.");
  }
  if (!(state.tracks instanceof Map) || state.tracks.size === 0) {
    warnings.push("Track graph is empty; no segments recorded.");
  }
  if (!(state.lines instanceof Map) || state.lines.size === 0) {
    warnings.push("No lines configured; services will not run.");
  }
  if (state.lines instanceof Map) {
    for (const line of state.lines.values()) {
      if (!Array.isArray(line.stops) || line.stops.length < 2) {
        warnings.push(`Line "${line.name || line.id || "unnamed"}" needs ‚â•2 stops.`);
        break;
      }
    }
  }
  return warnings;
}

function ui_validatorWarningsHtml(){
  const warnings = state.validatorWarnings || [];
  if (!warnings.length) return "";
  const list = warnings.map(w => `<div>${escapeHtml(w)}</div>`).join("");
  return `
    <div class="hint" style="border-color:#fcd34d;background:#fffbeb;color:#92400e;font-weight:900;">
      <div style="font-weight:1000;">State validator warnings</div>
      ${list}
    </div>
  `;
}

function ui_scenarioPanelHtml(){
  const payload = state.scenarioPayload;
  const meta = state.scenarioMeta || {};
  const packMeta = state.scenarioPackMeta || {};
  const manifest = state.scenarioPackManifest || {};
  const scenarioTitle = meta.title || packMeta.name || manifest.name || "Base dataset";
  const scenarioId = meta.scenarioId || meta.id || scenarioTitle;
  const scenarioHash = state.scenarioHash ? String(state.scenarioHash).slice(0,8) : "n/a";
  const tileCount = Array.isArray(packMeta.tiles)
    ? packMeta.tiles.length
    : (Array.isArray(manifest.tiles) ? manifest.tiles.length : 0);
  const datasetVersion = packMeta.datasetVersion || manifest.datasetVersion || window.datasetVersion || "n/a";
  const license = state.scenarioPackLicense || manifest.license || "Not provided";
  const badge = payload
    ? `<span class="badge">Scenario loaded</span>`
    : `<span class="badge" style="background:#f97316;">No scenario</span>`;
  const detailRows = [
    `ID: ${escapeHtml(String(scenarioId))}`,
    `Hash: ${escapeHtml(scenarioHash)}`,
    `Source: ${escapeHtml(scenarioTitle)}`,
    `Dataset: ${escapeHtml(datasetVersion)}`,
    `Tiles: ${escapeHtml(String(tileCount))}`
  ];
  const extraTags = [
    manifest.modelVersion ? `Model ${escapeHtml(String(manifest.modelVersion))}` : "",
    manifest.updatedAt ? `Updated ${escapeHtml(String(manifest.updatedAt))}` : ""
  ].filter(Boolean);
  const extraInfo = extraTags.length
    ? `<div class="hint" style="margin-top:4px;font-size:11px;color:#64748b;">${extraTags.join(" ¬∑ ")}</div>`
    : "";
  const onlineModeLabel = state.onlineMode ? "Online (live data)" : "Offline (cached data)";
  const onlineModeAction = state.onlineMode ? "Switch to offline mode" : "Switch to online mode";

  return `
    <div class="section">
      <div class="row" style="align-items:flex-start;gap:12px;">
        <div style="flex:1;">
          <div style="display:flex;gap:6px;align-items:center;">
            <div style="font-weight:1000;color:#0f172a;">Scenario menu</div>
            ${badge}
          </div>
          <div class="hint" style="margin-top:6px;font-size:12px;line-height:1.4;">
            Import a scenario pack or JSON export to seed the world, and restart the run to keep the list deterministic.
          </div>
          <div class="hint" style="margin-top:8px;font-size:11px;line-height:1.4;">
            ${detailRows.map(row => `<div>${row}</div>`).join("")}
          </div>
          ${extraInfo}
          <div class="hint" style="margin-top:4px;font-size:10px;color:#475569;">
            License: ${escapeHtml(license)}
          </div>
        </div>
        <div class="row" style="gap:6px;">
          <button class="btn secondary" style="padding:8px 12px;margin-top:0;" onclick="document.getElementById('scenarioFile').click()">Import scenario</button>
          <button class="btn secondary" style="padding:8px 12px;margin-top:0;" onclick="ui_restartScenarioRun()" ${payload ? "" : "disabled"}>Restart run</button>
        </div>
      </div>
      <div id="scenarioCacheStatus" class="hint" style="margin-top:8px;font-size:11px;">Offline cache status unknown.</div>
      <div class="row" style="gap:6px;margin-top:6px;">
        <button class="btn secondary" onclick="ui_cacheManifest()">Cache manifest</button>
        <button class="btn secondary" onclick="ui_cachePack()">Cache scenario</button>
        <button class="btn secondary" onclick="ui_loadCachedPack()">Load cached dataset</button>
      </div>
      <div class="hint" style="margin-top:6px;font-size:11px;">Mode: ${onlineModeLabel}</div>
      <div class="row" style="gap:6px;margin-top:4px;">
        <button class="btn secondary" onclick="ui_toggleOnlineMode()">${onlineModeAction}</button>
      </div>
      <input type="file" id="scenarioFile" accept="application/json" style="display:none;" onchange="ui_importScenario()">
    </div>
  `;
}

async function ui_cacheManifest(){
  if (typeof offlineCache_saveManifest !== "function") {
    showToast("Offline cache unavailable", "warning");
    return;
  }
  const manifest = state.scenarioPackManifest;
  if (!manifest || !manifest.datasetVersion) {
    showToast("No manifest loaded yet", "warning");
    return;
  }
  try {
    await offlineCache_saveManifest(manifest);
    showToast(`Manifest ${manifest.datasetVersion} cached`, "success");
    ui_updateScenarioCacheStatus();
  } catch (err) {
    showToast(`Manifest cache failed: ${err.message}`, "error");
  }
}

async function ui_cachePack(){
  if (typeof offlineCache_savePack !== "function") {
    showToast("Offline cache unavailable", "warning");
    return;
  }
  const pack = state.scenarioPayload;
  if (!pack) {
    showToast("Load a scenario pack first", "warning");
    return;
  }
  try {
    await offlineCache_savePack(pack);
    showToast("Scenario pack cached", "success");
    ui_updateScenarioCacheStatus();
  } catch (err) {
    showToast(`Pack cache failed: ${err.message}`, "error");
  }
}

async function ui_loadCachedPack(){
  if (typeof offlineCache_getLatestManifest !== "function") {
    showToast("Offline cache unavailable", "warning");
    return;
  }
  try {
    const entry = await offlineCache_getLatestManifest();
    if (!entry) {
      showToast("No cached manifest found", "warning");
      return;
    }
    const manifest = entry.value || entry;
    const datasetVersion = manifest.datasetVersion;
    const packEntry = await offlineCache_getPackForDataset(datasetVersion);
    if (!packEntry) {
      showToast(`No pack cached for ${datasetVersion}`, "warning");
      return;
    }
    const pack = packEntry.value || packEntry;
    state.scenarioPayload = pack;
    state.scenarioPackManifest = manifest;
    applyScenarioToState(pack);
    updateUI();
    showToast(`Loaded cached dataset ${datasetVersion}`, "success");
  } catch (err) {
    showToast(`Cache load failed: ${err.message}`, "error");
  }
}

function ui_updateScenarioCacheStatus(){
  const el = document.getElementById("scenarioCacheStatus");
  if (!el) return;
  if (typeof offlineCache_getLatestManifest !== "function") {
    const modeLabel = state.onlineMode ? "Online mode" : "Offline mode (cached)";
    el.textContent = `${modeLabel} - Offline cache not supported in this browser.`;
    return;
  }
  offlineCache_getLatestManifest()
    .then((entry) => {
      if (!entry) {
        const modeLabel = state.onlineMode ? "Online mode" : "Offline mode (cached)";
        el.textContent = `${modeLabel} - No cached dataset saved yet.`;
        return;
      }
      const manifest = entry.value || entry;
      const storedAt = entry.storedAt ? new Date(entry.storedAt).toLocaleString() : "unknown time";
      const modeLabel = state.onlineMode ? "Online mode" : "Offline mode (cached)";
      el.textContent = `${modeLabel} - Cached dataset ${manifest.datasetVersion} (saved ${storedAt})`;
    })
    .catch((err) => {
      const modeLabel = state.onlineMode ? "Online mode" : "Offline mode (cached)";
      el.textContent = `${modeLabel} - Cache error: ${err?.message || "unknown"}`;
    });
}

function ui_toggleOnlineMode(){
  state.onlineMode = !state.onlineMode;
  showToast(`Online mode ${state.onlineMode ? "enabled" : "disabled"}`, "info");
  updateUI();
}

function togglePanelMinimized(force){
if (!state) return;
state.panelMinimized = (typeof force === "boolean") ? force : !state.panelMinimized;
updateUI();
}

function ui_setSimSeed(raw){
if (!state) return;
const seed = Math.max(1, Math.floor(Number(raw) || Number(state.simSeed || state.meta?.seed || 1)));
state.simSeed = seed;
if (typeof window.makeRunMeta === "function") {
  state.meta = window.makeRunMeta({
    seed,
    scenarioId: state.scenarioMeta?.id || "default"
  });
}
showToast(`Seed set to ${seed}`, "success");
updateUI();
}

function ui_randomizeSimSeed(){
const seed = Math.floor(Math.random() * 1_000_000_000) + 1;
ui_setSimSeed(seed);
}

window.ui_copyReportRunId = function(){
  const runId = state.meta?.runId || "pending";
  const text = String(runId);
  if (navigator?.clipboard?.writeText) {
    navigator.clipboard.writeText(text)
      .then(() => showToast("Run ID copied to clipboard", "success"))
      .catch(() => showToast("Clipboard copy failed", "warning"));
  } else {
    showToast("Clipboard not available in this browser", "warning");
  }
};

function ui_invertHexColor(hex){
  const s = String(hex || "").trim();
  if (!s.startsWith("#")) return "#0f172a";
  let v = s.slice(1);
  if (v.length === 3) v = v.split("").map(ch => ch + ch).join("");
  if (v.length !== 6) return "#0f172a";
  const r = 255 - parseInt(v.slice(0,2), 16);
  const g = 255 - parseInt(v.slice(2,4), 16);
  const b = 255 - parseInt(v.slice(4,6), 16);
  const toHex = (n) => n.toString(16).padStart(2, "0");
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}

function line_stopFractions(line){
if (!line || !Array.isArray(line.stops) || line.stops.length < 2) return [];
const pts = line.stops.map(id => state.nodes.get(id)).filter(Boolean);
if (pts.length < 2) return [];

const seg = [];
let total = 0;
for (let i=0;i<pts.length-1;i++){
  const a = pts[i], b = pts[i+1];
  const d = map.distance([a.lat, a.lon], [b.lat, b.lon]);
  seg.push(d);
  total += d;
}
if (total <= 0) return pts.map((_,i)=> (pts.length===1?0:i/(pts.length-1)));

const frac = [0];
let acc = 0;
for (let i=0;i<seg.length;i++){
  acc += seg[i];
  frac.push(acc/total);
}
return frac;
}

function fmtAbsTime(absMin){
const day = Math.floor(absMin / 1440);
const t = ((absMin % 1440) + 1440) % 1440;
const hhmm = minToHHMM(t);
const baseDay = Number(state.service?.day || 0);
const dRel = day - baseDay;
return dRel === 0 ? hhmm : `${hhmm} (+${dRel}d)`;
}

function ui_nextArrivalsForStop(line, stopIndex, k=3){
const curTMin = Number(state.clock?.tMin || 0);
const absNow = Number(state.service?.day || 0)*1440 + curTMin;

const runtime = ui_lineRuntimeMin(line);
if (runtime <= 0.05) return [];

const fracs = line_stopFractions(line);
const f = Number(fracs[stopIndex] ?? (stopIndex/(Math.max(1,(line.stops.length-1)))));

const out = [];

// Active runs
for (const r of (state.service?.runs || [])){
  if (r.lineId !== line.id) continue;
  const absStart = Number(r.absStart ?? (Number(state.service?.day||0)*1440 + Number(r.depMin||0)));
  const arrAbs = absStart + Number(r.runtimeMin || runtime) * f;
  if (arrAbs >= absNow - 0.01) out.push(arrAbs);
}

// Future scheduled departures (today or tomorrow)
for (const dep of (line.departures || [])){
  const depMin = Number(dep);
  if (!Number.isFinite(depMin)) continue;
  const depAbs = (depMin >= curTMin)
    ? (Number(state.service?.day || 0)*1440 + depMin)
    : ((Number(state.service?.day || 0)+1)*1440 + depMin);

  const arrAbs = depAbs + runtime * f;
  if (arrAbs >= absNow - 0.01) out.push(arrAbs);
}

out.sort((a,b)=>a-b);

// Unique-ish (within 0.25 min)
const uniq = [];
for (const t of out){
  if (!uniq.length || Math.abs(t - uniq[uniq.length-1]) > 0.25) uniq.push(t);
  if (uniq.length >= k) break;
}
return uniq;
}

function ui_lineDiagram_stopClick(nodeId){
const line = state.activeLine ? state.lines.get(state.activeLine) : null;
const node = state.nodes.get(nodeId);
if (!line || !node) return;

// Center map
const z = Math.max(map.getZoom(), 9);
map.setView([node.lat, node.lon], z, { animate: true });

// Find stop index
const stopIndex = line.stops.findIndex(x => String(x) === String(nodeId));
const arrivals = stopIndex >= 0 ? ui_nextArrivalsForStop(line, stopIndex, 3) : [];

const html = `
  <div style="min-width:200px">
    <div style="font-weight:1000;color:#0f172a;">${escapeHtml(node.name || nodeId)}</div>
    <div style="font-weight:900;color:#334155;font-size:12px;line-height:1.4;margin-top:4px;">
      Line: <b>${escapeHtml(ui_lineDisplayName(line))}</b><br/>
      Next arrivals: ${
        arrivals.length
          ? arrivals.map(t => `<b>${fmtAbsTime(t)}</b>`).join(", ")
          : "<span style='color:#64748b'>none scheduled</span>"
      }
    </div>
  </div>
`;

L.popup({ closeButton: true, autoClose: true, closeOnClick: true })
  .setLatLng([node.lat, node.lon])
  .setContent(html)
  .openOn(map);
}

Object.assign(window, { ui_lineDiagram_stopClick });

// ======================
// UI actions
// ======================
function switchTab(tab){
  state.activeTab = tab;
  if (tab !== "tracks") {
    if (state.trackBuildMode) setTrackBuildMode(false, { silent: true });
    if (state.lineBuildMode && typeof setLineBuildMode === "function") setLineBuildMode(false, { silent: true });
    else if (state.lineBuildMode) state.lineBuildMode = false;
    updateUI();
    return;
  }
  updateUI();
}

function switchPrimaryTab(tab){
  state.primaryTab = (tab === "production") ? "production" : "population";
  state.lineEditorMode = ui_defaultLineMode();
  if (!state.dynamics) state.dynamics = {};
  state.dynamics.mode = (state.primaryTab === "production") ? "goods" : "passengers";
  const allowed = ui_allowedLineTypes();
  const activeLine = state.activeLine ? state.lines.get(state.activeLine) : null;
  if (activeLine && !allowed.includes(activeLine.type || "passenger")) {
    state.activeLine = null;
  }
  if (state.primaryTab === "production") {
    if (state.trackBuildMode) setTrackBuildMode(false, { silent: true });
    if (state.lineBuildMode && typeof setLineBuildMode === "function") setLineBuildMode(false, { silent: true });
    else if (state.lineBuildMode) state.lineBuildMode = false;
  }
  updateUI();
  if (typeof renderLines === "function") renderLines();
  if (typeof dynFlow_render === "function") dynFlow_render();
  if (typeof ui_renderLineLegend === "function") ui_renderLineLegend();
  ui_updatePrimaryTabOverlays();
  if (typeof renderClusterMarkers === "function") renderClusterMarkers();
  if (typeof syncMarkerVisibility === "function") syncMarkerVisibility();
}
window.switchPrimaryTab = switchPrimaryTab;

function ui_updatePrimaryTabOverlays(){
  if (!map) return;
  if (layers?.flowOverlay) {
    try { if (!map.hasLayer(layers.flowOverlay)) layers.flowOverlay.addTo(map); } catch { /* ignore */ }
  }
  if (layers?.trains) {
    try { if (!map.hasLayer(layers.trains)) layers.trains.addTo(map); } catch { /* ignore */ }
  }
  if (state.service?.layer) {
    try {
      if (!map.hasLayer(state.service.layer)) state.service.layer.addTo(map);
    } catch { /* ignore */ }
    try { if (typeof service_refreshRunVisibility === "function") service_refreshRunVisibility(); } catch { /* ignore */ }
  }
}

window.ui_cacheManifest = ui_cacheManifest;
window.ui_cachePack = ui_cachePack;
window.ui_loadCachedPack = ui_loadCachedPack;
window.ui_updateScenarioCacheStatus = ui_updateScenarioCacheStatus;
window.ui_toggleOnlineMode = ui_toggleOnlineMode;

function ui_selectPrimaryNav(tabId){
  const shouldHide = state.panelVisible && state.primaryTab === tabId;
  if (shouldHide){
    state.panelVisible = false;
    updateUI();
    return;
  }
  state.panelVisible = true;
  switchPrimaryTab(tabId);
}
window.ui_selectPrimaryNav = ui_selectPrimaryNav;

function ui_selectSubNav(tabId){
  const shouldHide = state.panelVisible && state.activeTab === tabId;
  if (shouldHide){
    state.panelVisible = false;
    updateUI();
    return;
  }
  state.panelVisible = true;
  switchTab(tabId);
}
window.ui_selectSubNav = ui_selectSubNav;



function ui_switchLinePanel(which){
  state.activeLinePanel = which;
  updateUI();
}
// expose for inline onclick in module context
window.ui_switchLinePanel = ui_switchLinePanel;
function setTrackBuildMode(on, { silent=false } = {}){
  state.trackBuildMode = !!on;
  if (state.trackBuildMode && !state.trackBuildAction) state.trackBuildAction = "build";
  state.pendingTrackNode = null;
  if (state.trackBuildMode && state.lineBuildMode) {
    if (typeof setLineBuildMode === "function") setLineBuildMode(false, { silent: true });
    else state.lineBuildMode = false;
  }

  if (state.trackBuildMode) {
    if (state.clock && typeof state.clock.running === "boolean") {
      state.clock._wasRunningBeforeBuild = !!state.clock.running;
    }
    if (typeof clock_stop === "function") clock_stop();
  } else {
    if (typeof track_hideAllLabels === "function") track_hideAllLabels();
    if (state.clock && state.clock._wasRunningBeforeBuild) {
      if (typeof clock_start === "function") clock_start();
    }
    if (state.clock) state.clock._wasRunningBeforeBuild = false;
  }

  updateUI();
  if (!silent) {
    showToast(on ? "Track build mode ON" : "Track build mode OFF", on ? "success" : "warning");
  }
}

function construction_hireCrew(){
  state.construction ||= { queue: [], active: [], history: [] };
  const max = Number(CONFIG.TRACK_BUILD_MAX_CREWS || 2);
  const cur = clamp(Number(state.construction.crewCap || max), 1, max);
  state.construction.crewCap = clamp(cur + 1, 1, max);
  try { if (typeof construction_startJobs === "function") construction_startJobs(); } catch { /* ignore */ }
  updateUI();
}

function construction_fireCrew(){
  state.construction ||= { queue: [], active: [], history: [] };
  const max = Number(CONFIG.TRACK_BUILD_MAX_CREWS || 2);
  const cur = clamp(Number(state.construction.crewCap || max), 1, max);
  const min = Math.max(1, (state.construction.active || []).length);
  state.construction.crewCap = clamp(cur - 1, min, max);
  updateUI();
}



function setTrackBuildAction(which){
  state.trackBuildAction = (which === "demolish") ? "demolish" : "build";
  if (!state.trackBuildMode) {
    setTrackBuildMode(true);
  } else {
    state.pendingTrackNode = null;
    updateUI();
  }
  showToast(state.trackBuildAction === "demolish" ? "Demolish mode" : "Build mode", "info");
}


function ui_toggleTrackPlanning(){
  const isOn = (state.activeTab === "tracks" && state.trackBuildMode);
  if (isOn) {
    setTrackBuildMode(false);
    switchTab("network");
    return;
  }
  switchTab("tracks");
  setTrackBuildAction("build");
}



function setTrackLanes(n){
  state.pendingTrackLanes = clamp(Number(n)||1, 1, 8);
  updateUI();
}

function ui_allowedLineTypes(){
  return (state.primaryTab === "production") ? ["cargo", "mixed"] : ["passenger", "mixed"];
}

function ui_defaultLineMode(){
  return (state.primaryTab === "production") ? "cargo" : "passenger";
}

function createNewLine(){
  const name = document.getElementById("lineName")?.value?.trim() || "New Line";
  const allowed = ui_allowedLineTypes();
  let type = document.getElementById("lineType")?.value || allowed[0];
  if (!allowed.includes(type)) type = allowed[0];
  const circular = !!document.getElementById("lineCircular")?.checked;

// Read optional inputs
const carsRaw = document.getElementById("lineCars")?.value;
const clsRaw  = document.getElementById("lineSpeedClass")?.value;

const cars = Number(carsRaw);

// override defaults if user set (NEW MODEL)
const ln = state.lines.get(state.activeLine);
if (ln) {
  ln.carriages = clamp(Number(document.getElementById("lineCarriages")?.value || ln.carriages || 6), 1, 50);
  ln.speedClass = String(document.getElementById("lineSpeedClass")?.value || ln.speedClass || "medium");
  try { line_recalcDerived(ln); } catch { /* ignore */ }
  try { if (typeof ui_lineRecalcTrainsFromDepartures === "function") ui_lineRecalcTrainsFromDepartures(ln); } catch { /* ignore */ }
}

const overrides = {};
if (Number.isFinite(cars)) overrides.carriages = cars;
if (typeof clsRaw === "string" && clsRaw) overrides.speedClass = clsRaw;

addLine(name, type, circular, overrides);

if (typeof setLineBuildMode === "function") {
  setLineBuildMode(true, { silent: true });
}

// Optional: clear fields for convenience (safe)
  const lnEl = document.getElementById("lineName");
  if (lnEl) lnEl.value = "";
  }

function setLineEditorMode(mode){
  const allowed = ui_allowedLineTypes();
  state.lineEditorMode = allowed.includes(mode) ? mode : allowed[0];
  const ln = state.activeLine ? state.lines.get(state.activeLine) : null;
  if (ln) {
    const t = ln.type || "passenger";
    if (!allowed.includes(t)) state.activeLine = null;
  }
  updateUI();
}
window.setLineEditorMode = setLineEditorMode;

function selectLine(id){
if (!id) {
  state.activeLine = null;
  renderLines();
  updateUI();
  showToast("No line selected (inspect mode)", "info");
  return;
}

state.activeLine = id;
renderLines();
updateUI();
}

// ======================
// Undo (last action)
// ======================
function undo_pushAction(action){
if (!state.undo) state.undo = { stack: [], max: 60 };
const st = state.undo.stack;
st.push(action);
const max = state.undo.max || 60;
if (st.length > max) st.shift();
}

function undo_removeTrackById(trackId){
const t = state.tracks.get(trackId);
if (!t) return null;

if (t._layer) layers.tracks.removeLayer(t._layer);

// label may live in tracks OR trackLabels depending on your current code
if (t._label) {
  layers.trackLabels.removeLayer(t._label);
  layers.tracks.removeLayer(t._label);
}

state.tracks.delete(trackId);
return t;
}

// restore a previous track visually WITHOUT charging budget
function undo_drawTrackVisual(fromId, toId, lanes){
const a = state.nodes.get(fromId);
const b = state.nodes.get(toId);
if (!a || !b) return null;

const key = edgeKey(fromId, toId);
const trackId = `TK-${key}`;

const cost = calculateTrackCost(a, b, lanes);

const line = L.polyline([[a.lat,a.lon],[b.lat,b.lon]], {
  color: "#000",
  weight: 2 + lanes * 1.5,
  opacity: 0.95,
  lineCap: "round"
}).addTo(layers.tracks);

const midLat = (a.lat + b.lat) / 2;
const midLon = (a.lon + b.lon) / 2;

const label = L.marker([midLat, midLon], {
  icon: L.divIcon({
    className: "",
    iconSize: [20, 20],
    iconAnchor: [10, 10],
    html: `<div class="track-lane-label">${lanes}</div>`
  }),
  interactive: false,
  keyboard: false
});

// prefer trackLabels layer if present
if (layers.trackLabels && typeof layers.trackLabels.addLayer === "function") label.addTo(layers.trackLabels);
else label.addTo(layers.tracks);

line.on("click", () => {
  if (confirm("Delete this track segment?")) {
    undo_removeTrackById(trackId);
    updateUI();
    renderLines();
    showToast("Track deleted", "warning");
  }
});

state.tracks.set(trackId, {
  id: trackId,
  from: fromId,
  to: toId,
  lanes,
  cost,
  built: true,
  _layer: line,
  _label: label
});

return trackId;
}

function undo_applyLast(){
const st = state.undo?.stack;
if (!st || !st.length) {
  showToast("Nothing to undo", "info");
  return;
}

const action = st.pop();

if (action.type === "track_add") {
  undo_removeTrackById(action.trackId);

  // If we overwrote a previous track, restore it
  if (action.prev && action.prev.from && action.prev.to) {
    undo_drawTrackVisual(action.prev.from, action.prev.to, action.prev.lanes || 1);
  }

  // Refund only what THIS build cost
  state.budget += Math.max(0, Number(action.refund || 0));

  state.pendingTrackNode = null;

  renderLines();
  updateUI();
  showToast("Undid track build", "success");
  return;
}

if (action.type === "line_stops") {
  const line = state.lines.get(action.lineId);
  if (line && Array.isArray(action.beforeStops)) {
    line.stops = action.beforeStops.slice();
  }

  renderLines();
  updateUI();
  showToast("Undid stop add", "success");
  return;
}

showToast("Nothing to undo", "info");
}

// ======================
// Optimizer (beta) - applies changes, not just suggestions
// ======================
function opt_scopeNodeIds(){
  const adj = (typeof renderGraph_buildTrackAdj === "function") ? renderGraph_buildTrackAdj() : null;
  const connected = new Set();
  if (adj && typeof adj.keys === "function") {
    for (const id of adj.keys()) connected.add(String(id));
  }

  if (!connected.size) return [];
  // If inside a cluster: optimize over cities in that cluster
  if (state.activeClusterId && state.clusters && state.clusters.has(state.activeClusterId)) {
    const cl = state.clusters.get(state.activeClusterId);
    if (cl && cl.cityIds && typeof cl.cityIds.forEach === "function") {
      return Array.from(cl.cityIds).filter(id => connected.has(String(id)));
    }
  }
  // Otherwise optimize over connected clusters (national network)
  return Array.from(connected).filter(id => {
    const n = state.nodes?.get(id);
    return n && n.kind === "cluster";
  });
}

function opt_nodePop(id){
const n = state.nodes?.get(id);
return Math.max(0, Number(n?.population || 0));
}

function opt_distKm(aId, bId){
if (!map || !map.distance) return Infinity;
const a = state.nodes?.get(aId);
const b = state.nodes?.get(bId);
if (!a || !b) return Infinity;
const d = map.distance([Number(a.lat), Number(a.lon)], [Number(b.lat), Number(b.lon)]);
return Number.isFinite(d) ? d / 1000 : Infinity;
}

function opt_colorByIndex(i){
const palette = ["#2b6cff","#10b981","#f59e0b","#ef4444","#a855f7","#06b6d4","#84cc16","#f97316"];
return palette[i % palette.length];
}

function opt_bearingDeg(fromId, toId){
const a = state.nodes?.get(fromId);
const b = state.nodes?.get(toId);
if (!a || !b) return 0;

const lat1 = Number(a.lat) * Math.PI / 180;
const lon1 = Number(a.lon) * Math.PI / 180;
const lat2 = Number(b.lat) * Math.PI / 180;
const lon2 = Number(b.lon) * Math.PI / 180;

const y = Math.sin(lon2 - lon1) * Math.cos(lat2);
const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
const brng = Math.atan2(y, x) * 180 / Math.PI;

return (brng + 360) % 360;
}

function opt_orderStopsByPath(line){
  if (!line || !Array.isArray(line.stops) || !Array.isArray(line.pathNodes)) return;
  const masterSet = new Set(line.stops.map(id => String(id)));
  const seen = new Set();
  const ordered = [];
  for (const raw of line.pathNodes) {
    const id = String(raw);
    if (!masterSet.has(id)) continue;
    if (seen.has(id)) continue;
    ordered.push(id);
    seen.add(id);
  }
  if (ordered.length) {
    line.stops = ordered;
  }
}


function opt_buildLinesForScope(nodeIds){
  const adj = (typeof renderGraph_buildTrackAdj === "function") ? renderGraph_buildTrackAdj() : null;
  if (!adj || !adj.size) return [];

  const ids = nodeIds
    .filter(id => state.nodes?.has(id) && (adj.has(id) || adj.has(String(id))))
    .sort((a,b)=> opt_nodePop(b)-opt_nodePop(a));

  if (ids.length < 2) return [];

  const MAXN = 220;
  const useIds = ids.length > MAXN ? ids.slice(0, MAXN) : ids.slice();
  const n = useIds.length;
  const lineType = (state.primaryTab === "production") ? "cargo" : "passenger";

  const majorCount = clamp(Math.round(n * 0.10), 5, 12);
  const majorHubs = useIds.slice(0, majorCount).map(id => String(id));
  const majorSet = new Set(majorHubs);
  const hubTargets = new Map();
  for (let i = 0; i < majorHubs.length; i++) {
    hubTargets.set(majorHubs[i], i < 3 ? 5 : 3);
  }
  const hubPassCount = new Map();
  for (const id of majorHubs) hubPassCount.set(id, 0);

  const baseLines = clamp(Math.round(Math.sqrt(n) / 1.5), 4, 12);
  const numLines = Math.max(baseLines, Math.min(majorHubs.length, 12));
  const bigPopThreshold = majorHubs.length
    ? Math.max(0, opt_nodePop(majorHubs[Math.min(majorHubs.length - 1, 2)]))
    : 0;

  const distCache = new Map();
  const opt_adjKey = (id) => {
    if (adj.has(id)) return id;
    const str = String(id);
    if (adj.has(str)) return str;
    const num = Number(id);
    if (Number.isFinite(num) && adj.has(num)) return num;
    return id;
  };
  const opt_nodeDegree = (id) => {
    const key = opt_adjKey(id);
    const nbrs = adj.get(key) || adj.get(String(key)) || [];
    return Math.max(0, nbrs.length || 0);
  };
  const opt_pathDistanceKm = (a, b) => {
    if (typeof renderGraph_shortestPath !== "function") return Infinity;
    const aKey = opt_adjKey(a);
    const bKey = opt_adjKey(b);
    const key = String(aKey) < String(bKey) ? `${aKey}|${bKey}` : `${bKey}|${aKey}`;
    if (distCache.has(key)) return distCache.get(key);
    const path = renderGraph_shortestPath(adj, aKey, bKey);
    if (!Array.isArray(path) || path.length < 2) {
      distCache.set(key, Infinity);
      return Infinity;
    }
    let km = 0;
    for (let i = 0; i < path.length - 1; i++) {
      km += opt_distKm(path[i], path[i + 1]);
    }
    distCache.set(key, km);
    return km;
  };

  const hasRoute = (a, b) => Number.isFinite(opt_pathDistanceKm(a, b));

  const opt_pathInfoNoRepeat = (a, b, used) => {
    if (typeof renderGraph_shortestPath !== "function") return null;
    const aKey = opt_adjKey(a);
    const bKey = opt_adjKey(b);
    const path = renderGraph_shortestPath(adj, aKey, bKey);
    if (!Array.isArray(path) || path.length < 2) return null;
    for (let i = 1; i < path.length; i++) {
      const id = String(path[i]);
      if (used.has(id)) return null;
    }
    let km = 0;
    for (let i = 0; i < path.length - 1; i++) {
      km += opt_distKm(path[i], path[i + 1]);
    }
    return { path, km };
  };

  const globalStopUse = new Map();
  const usedStarts = new Set();

  const pickStartHub = () => {
    let best = null;
    let bestGap = -1;
    let bestPop = -1;
    for (const id of majorHubs) {
      const gap = Math.max(0, (hubTargets.get(id) || 0) - (hubPassCount.get(id) || 0));
      if (gap <= 0) continue;
      const pop = opt_nodePop(id);
      if (gap > bestGap || (gap === bestGap && pop > bestPop)) {
        best = id;
        bestGap = gap;
        bestPop = pop;
      }
    }
    if (best) return best;

    let fallback = null;
    let fallbackPop = -1;
    for (const id of useIds) {
      const sid = String(id);
      if (usedStarts.has(sid)) continue;
      const pop = opt_nodePop(sid);
      if (pop > fallbackPop) {
        fallbackPop = pop;
        fallback = sid;
      }
    }
    return fallback || (useIds.length ? String(useIds[0]) : null);
  };

  const opt_pathOverlap = (path) => {
    if (!Array.isArray(path)) return 0;
    let overlap = 0;
    for (const raw of path) {
      const id = String(raw);
      if (majorSet.has(id)) continue;
      const count = globalStopUse.get(id) || 0;
      overlap += count;
    }
    return overlap;
  };

  const addStopsFromPath = (path, routeStops, spacingKm) => {
    if (!Array.isArray(path) || path.length < 2) return;
    let distSince = 0;
    let prev = path[0];
    for (let i = 1; i < path.length; i++) {
      const rawId = path[i];
      const nodeId = String(rawId);
      distSince += opt_distKm(prev, rawId);
      const isFinal = i === path.length - 1;
      const isMajor = majorSet.has(nodeId);
      const isLarge = bigPopThreshold > 0 && opt_nodePop(nodeId) >= bigPopThreshold;
      const shouldStop = isFinal || isMajor || isLarge || distSince >= spacingKm;
      if (shouldStop && !routeStops.includes(nodeId)) {
        routeStops.push(nodeId);
        distSince = 0;
      }
      prev = rawId;
    }
  };

  const settingsList = [
    {
      minStops: 10,
      minKm: 300,
      maxStops: 24,
      maxKm: 1600,
      stepBaseKm: 140,
      stepNeedMult: 2.6,
      stepOkMult: 1.6,
      overlapPenalty: 180,
      stopSpacingTight: 60,
      stopSpacingLoose: 90
    },
    {
      minStops: 8,
      minKm: 220,
      maxStops: 32,
      maxKm: 2400,
      stepBaseKm: 200,
      stepNeedMult: 3.2,
      stepOkMult: 2.1,
      overlapPenalty: 120,
      stopSpacingTight: 80,
      stopSpacingLoose: 120
    },
    {
      minStops: 6,
      minKm: 160,
      maxStops: 38,
      maxKm: 2800,
      stepBaseKm: 240,
      stepNeedMult: 3.6,
      stepOkMult: 2.4,
      overlapPenalty: 80,
      stopSpacingTight: 100,
      stopSpacingLoose: 160
    }
  ];

  const buildFallbackLine = (candidateIds, settings, lineIdx) => {
    let bestPair = null;
    let bestKm = -Infinity;
    for (let i = 0; i < candidateIds.length; i++) {
      const a = candidateIds[i];
      for (let j = i + 1; j < candidateIds.length; j++) {
        const b = candidateIds[j];
        const km = opt_pathDistanceKm(a, b);
        if (!Number.isFinite(km)) continue;
        if (km > bestKm) {
          bestKm = km;
          bestPair = [a, b];
        }
      }
    }
    if (!bestPair) return null;
    const path = renderGraph_shortestPath(adj, opt_adjKey(bestPair[0]), opt_adjKey(bestPair[1]));
    if (!Array.isArray(path) || path.length < 2) return null;

    const routeStops = [String(path[0])];
    addStopsFromPath(path, routeStops, settings.stopSpacingTight);

    if (routeStops.length < 2) return null;

    let popSum = 0;
    for (const rid of routeStops) popSum += opt_nodePop(rid);
    const freq = clamp(Math.round(popSum / 3_000_000) + 2, 2, 24);

    const line = {
      id: `L-AUTO-${Date.now().toString(36)}-${lineIdx}`,
      name: `Auto Line ${lineIdx + 1}`,
      type: lineType,
      color: opt_colorByIndex(lineIdx),
      stops: routeStops,
      pathNodes: path.slice(),
      circular: false,
      noAutoTracks: true,
      frequencyPerDay: 0,
      carriages: lineType === "cargo" ? 10 : 6,
      speedClass: lineType === "cargo" ? "medium" : "fast",
      departures: [],
      trains: 0
    };
    line.departures = autoGenerateDepartures(line, freq);
    opt_orderStopsByPath(line);
    return line;
  };

  const lines = [];
  let idx = 0;
  for (const settings of settingsList) {
    const maxAttempts = (numLines - lines.length) * 4 + 4;
    let attempts = 0;
    while (lines.length < numLines && attempts < maxAttempts) {
      attempts++;
      const hub = pickStartHub();
      if (!hub) break;
      usedStarts.add(String(hub));

      let remaining = useIds
        .map(id => String(id))
        .filter(id => id !== String(hub) && hasRoute(hub, id));
      if (remaining.length < 1) continue;

      const routeStops = [hub];
      const used = new Set([String(hub)]);
      const pathNodes = [hub];
      let current = hub;
      let routeKm = 0;
      const baseMaxStepKm = state.activeClusterId ? settings.stepBaseKm : settings.stepBaseKm * 3;

      while (remaining.length) {
        const needSpan = routeStops.length < settings.minStops || routeKm < settings.minKm;
        const maxStepKm = baseMaxStepKm * (needSpan ? settings.stepNeedMult : settings.stepOkMult);
        const spacingKm = needSpan ? settings.stopSpacingTight : settings.stopSpacingLoose;

        const priorityHubs = majorHubs.filter(id => {
          const gap = (hubTargets.get(id) || 0) - (hubPassCount.get(id) || 0);
          return gap > 0 && !used.has(id) && remaining.includes(id);
        });
        const candidates = priorityHubs.length ? priorityHubs : remaining;

        let bestIdx = -1;
        let bestPath = null;
        let bestValue = -Infinity;
        let bestDist = 0;

        for (let i = 0; i < candidates.length; i++) {
          const cand = candidates[i];
          const info = opt_pathInfoNoRepeat(current, cand, used);
          if (!info) continue;
          if (Number.isFinite(info.km) && info.km > maxStepKm) continue;

          const pop = opt_nodePop(cand);
          const popBoost = Math.log10(1 + Math.max(0, pop)) * 80;
          const degBoost = opt_nodeDegree(cand) * 12;
          const hubNeed = majorSet.has(String(cand))
            ? Math.max(0, (hubTargets.get(String(cand)) || 0) - (hubPassCount.get(String(cand)) || 0))
            : 0;
          const hubBonus = hubNeed > 0 ? (1600 + hubNeed * 500) : 0;
          const overlap = opt_pathOverlap(info.path);
          const overlapPenalty = overlap * settings.overlapPenalty;
          const distScore = info.km * (needSpan ? 1.7 : 1.25);

          const value = distScore + popBoost + degBoost + hubBonus - overlapPenalty;
          if (value > bestValue) {
            bestValue = value;
            bestIdx = i;
            bestPath = info.path;
            bestDist = info.km;
          }
        }

        if (bestIdx === -1 || !bestPath) break;

        for (let i = 1; i < bestPath.length; i++) {
          const rawId = bestPath[i];
          const id = String(rawId);
          used.add(id);
          pathNodes.push(rawId);
        }
        addStopsFromPath(bestPath, routeStops, spacingKm);
        routeKm += bestDist;
        current = bestPath[bestPath.length - 1];

        remaining = remaining.filter(id => !used.has(String(id)));

        if (routeStops.length >= settings.maxStops || routeKm >= settings.maxKm) {
          if (routeStops.length >= settings.minStops && routeKm >= settings.minKm) break;
        }
      }

      if (routeStops.length < settings.minStops || routeKm < settings.minKm) continue;

      let popSum = 0;
      for (const rid of routeStops) popSum += opt_nodePop(rid);
      const freq = clamp(Math.round(popSum / 3_000_000) + 2, 2, 24);

      const line = {
        id: `L-AUTO-${Date.now().toString(36)}-${idx}`,
        name: `Auto Line ${idx + 1}`,
        type: lineType,
        color: opt_colorByIndex(idx),
        stops: routeStops,
        pathNodes: pathNodes.slice(),
        circular: false,
        noAutoTracks: true,
        frequencyPerDay: 0,
        carriages: lineType === "cargo" ? 10 : 6,
        speedClass: lineType === "cargo" ? "medium" : "fast",
        departures: [],
        trains: 0
      };
      line.departures = autoGenerateDepartures(line, freq);
      opt_orderStopsByPath(line);
      lines.push(line);
      idx++;

      const uniqueStops = new Set(routeStops.map(id => String(id)));
      for (const sid of uniqueStops) {
        globalStopUse.set(sid, (globalStopUse.get(sid) || 0) + 1);
        if (majorSet.has(sid)) {
          hubPassCount.set(sid, (hubPassCount.get(sid) || 0) + 1);
        }
      }
    }
  }

  if (!lines.length) {
    const candidates = majorHubs.length ? majorHubs.slice() : useIds.map(id => String(id));
    const fallbackLine = buildFallbackLine(candidates, settingsList[0], idx);
    if (fallbackLine) {
      lines.push(fallbackLine);
      idx++;
    }
    if (lines.length < 2 && candidates.length > 4) {
      const remaining = candidates.filter(id => !lines[0]?.stops?.includes(id));
      const secondLine = buildFallbackLine(remaining.length ? remaining : candidates, settingsList[1], idx);
      if (secondLine) lines.push(secondLine);
    }
  }

  return lines;
}

function opt_autoBuildNetwork(mode){
  if (mode === "add") {
    showToast("Optimizer is set to override only. Use Replace.", "warning");
    return;
  }
  const adj = (typeof renderGraph_buildTrackAdj === "function") ? renderGraph_buildTrackAdj() : null;
  if (!adj || !adj.size) {
    showToast("Optimizer needs existing tracks to build lines", "warning");
    return;
  }
  const scopeIds = opt_scopeNodeIds();
  if (!scopeIds.length) { showToast("No nodes in scope to optimize", "warning"); return; }

  const ok = confirm("Replace visible lines with an auto-built network?");
  if (!ok) return;

const newLines = opt_buildLinesForScope(scopeIds);
if (!newLines.length) { showToast("Optimizer could not build lines (check tracks + min 10 stops / 300 km)", "warning"); return; }

  const allowedTypes = ui_allowedLineTypes();
  const preserved = [];
  let preservedActive = null;
  for (const l of state.lines.values()){
    const t = l.type || "passenger";
    if (!allowedTypes.includes(t)) {
      preserved.push(l);
      if (state.activeLine === l.id) preservedActive = l.id;
    }
  }

  state.lines.clear();
  for (const l of preserved) state.lines.set(l.id, l);
  state.activeLine = preservedActive;

for (const l of newLines) {
  // Ensure new-style line model fields are derived/consistent
  if (!Array.isArray(l.departures)) l.departures = [];
  if (!Number.isFinite(Number(l.frequencyPerDay))) l.frequencyPerDay = 0;
  if (!l.speedClass) l.speedClass = (l.type === 'cargo') ? 'medium' : 'fast';
  if (!Number.isFinite(Number(l.carriages))) l.carriages = 6;
  line_recalcDerived(l);
  // trains required comes from departures + runtime
  if (typeof ui_lineRecalcTrainsFromDepartures === 'function') ui_lineRecalcTrainsFromDepartures(l);
  state.lines.set(l.id, l);
}

state.activeLine = state.activeLine || newLines[0]?.id || null;

renderLines();
dynFlow_render?.(); // if present, refresh moving dots
updateUI();
showToast(`Optimizer applied: ${newLines.length} lines (${mode})`, "success");
}

function opt_boostFrequencies(){
let changed = 0;
for (const l of state.lines.values()){
  if (!l) continue;
  if (!Array.isArray(l.departures)) l.departures = [];
  const curN = l.departures.length;
  const targetN = clamp(Math.ceil(curN * 1.2), 0, 200);
  if (targetN === curN) continue;
  l.departures = makeEvenDepartures(targetN);
  l.frequencyPerDay = 0;
  try { line_recalcDerived(l); } catch { /* ignore */ }
  try { if (typeof ui_lineRecalcTrainsFromDepartures === "function") ui_lineRecalcTrainsFromDepartures(l); } catch { /* ignore */ }
  changed++;
}
renderLines();
dynFlow_render?.();
updateUI();
showToast(changed ? `Boosted timetables on ${changed} lines` : "No timetables to boost", changed ? "success" : "info");
}


function kv(k, v){ return `<span class="k">${k}:</span> <span class="v">${v}</span>`; }

function production_iconHtml(it, size = 16){
  if (!it) return "";
  if (it.iconSvg) {
    return `<img src="${it.iconSvg}" alt="${escapeHtml(it.name || it.id || "")}" style="width:${size}px;height:${size}px;image-rendering:pixelated;">`;
  }
  return `<span style="font-weight:900;font-size:${Math.max(10, size - 6)}px;color:#fff;">${escapeHtml(it.icon || "")}</span>`;
}

function production_setDetailTab(id){
  if (!state.production) state.production = {};
  state.production.activeDetailTab = id;
  updateUI();
}
window.production_setDetailTab = production_setDetailTab;

function renderInvestmentPanel(opts = {}){
  const wrap = opts.wrap !== false;
  try { if (typeof economy_initInvestments === "function") economy_initInvestments(state); } catch { /* ignore */ }
  const companies = Array.isArray(state.economy?.companies) ? state.economy.companies : [];
  const publicMinCap = 200_000_000;
  const holdingsValue = companies.reduce((s, c) => s + (Number(c.playerShares || 0) * Number(c.sharePrice || 0)), 0);
  const lastDividends = Number(state.economy?.lastDividends || 0);
  const companyOptions = companies.map(c => `
    <option value="${c.id}">${escapeHtml(c.name)} ‚Äî ${formatCurrency(Number(c.sharePrice || 0))}/share</option>
  `).join("");
  const companyListHtml = companies.length ? companies.map(c => `
    <div class="item" style="cursor:default;">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
        <div style="min-width:0;">
          <div style="font-weight:900;color:#0f172a;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${escapeHtml(c.name)}</div>
          <div style="font-size:12px;font-weight:900;color:#64748b;">
            ${escapeHtml(c.scope || "company")} ¬∑ ${escapeHtml(c.sector || "general")} ¬∑ ${Number(c.marketCap || 0) >= publicMinCap ? "Listed" : "Private"}
          </div>
        </div>
        <div style="text-align:right;font-weight:900;">
          ${formatCurrency(Number(c.sharePrice || 0))}
        </div>
      </div>
      <div style="margin-top:6px;font-size:12px;font-weight:900;color:#64748b;">
        Market cap: ${formatCurrency(Number(c.marketCap || 0))} ¬∑ Shares: ${fmtNum(Math.round(Number(c.sharesOutstanding || 0)))}
        ${Number(c.playerShares || 0) > 0 ? ` ¬∑ You: ${fmtNum(Math.round(Number(c.playerShares || 0)))} shares` : ""}
      </div>
    </div>
  `).join("") : `<div class="hint">No companies available yet.</div>`;

  const panelHtml = `
      <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Local investments</div>
      <div class="hint">
        Invest in companies connected to the network. Dividends pay monthly and growing firms increase local goods needs. Only listed companies can be traded.
      </div>
      <div class="row" style="margin-top:10px;">
        <select id="investCompany" class="field">
          ${companyOptions || `<option value="">No companies available</option>`}
        </select>
      </div>
      <div class="row" style="margin-top:8px;gap:8px;">
        <input id="investShares" class="field" type="number" min="1" step="1" placeholder="Shares">
        <button class="btn secondary" style="width:auto;padding:10px 12px;margin-top:0;" onclick="economy_buyShares(document.getElementById('investCompany').value, document.getElementById('investShares').value)">Buy</button>
        <button class="btn secondary" style="width:auto;padding:10px 12px;margin-top:0;" onclick="economy_sellShares(document.getElementById('investCompany').value, document.getElementById('investShares').value)">Sell</button>
      </div>
      <div class="hint" style="margin-top:10px;">
        <div>${kv("Portfolio value", formatCurrency(holdingsValue))}</div>
        <div>${kv("Last month dividends", formatCurrency(lastDividends))}</div>
      </div>
      <div style="margin-top:10px;">${companyListHtml}</div>
  `;
  return wrap ? `<div class="section">${panelHtml}</div>` : panelHtml;
}

function renderProductionTab(){
const macro = state.production?.macro || {};
const year = macro.year || "";
const source = macro.source || "Unknown";
const units = macro.units || "";
const totalsProd = macro.production_eur || {};
const totalsNeed = macro.consumption_eur || {};
const sumProd = Object.values(totalsProd).reduce((s,x)=>s+Number(x||0),0);
const sumNeed = Object.values(totalsNeed).reduce((s,x)=>s+Number(x||0),0);
const activeTab = state.production?.activeDetailTab || PROD_ITEMS[0]?.id;
const activeItem = PROD_ITEMS.find(it => it.id === activeTab) || PROD_ITEMS[0];
const activeNodeId = state.selectedNodeId;
const activeNode = activeNodeId ? production_getNode?.(activeNodeId) : null;
const s = state.flowSummary || {};
const dyn = state.dynamics || {};

return `
  <div class="section">
    <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Industry Overview</div>
    <div style="margin-top:10px; line-height:1.7;">
      ${kv("Year", year || "‚Äî")}
      <br>${kv("Total production", formatCurrency(sumProd || 0) + (units ? " " + units : ""))}
      <br>${kv("Total needs", formatCurrency(sumNeed || 0) + (units ? " " + units : ""))}
    </div>
    <div class="hint" style="margin-top:10px;">
      Source: ${escapeHtml(source)}
    </div>
    <div class="hint" style="margin-top:6px;">
      Hover a town to see local industry output, needs, and mode split.
    </div>
  </div>

  <div class="section">
    <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Goods movement (yearly)</div>
    <label style="display:flex;gap:10px;align-items:center;font-weight:900;color:#334155;">
      <input type="checkbox" ${dyn.enabled ? "checked" : ""} onchange="setDynamicsEnabled(this.checked)">
      Enable goods dynamics
    </label>
    <div style="margin-top:10px; line-height:1.7;">
      ${kv("Goods demand", fmtNum(s.goodsDemand||0))}
      <br>${kv("Goods by rail", fmtNum(s.goodsByRail||0))}
      <br>${kv("Goods by other", fmtNum(s.goodsByOther||0))}
      <br>${kv("Goods delivered", fmtNum(s.goodsDelivered||0))}
      <br>${kv("Goods unmet", fmtNum(s.goodsUnmet||0))}
    </div>
  </div>

  <div class="section">
    <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Items</div>
    <div style="display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px;">
      ${PROD_ITEMS.map(it => {
        const val = Number(totalsProd[it.id] || 0);
        const details = Array.isArray(it.details) ? it.details.join(", ") : "";
        return `
          <div style="padding:8px 10px;border:1px solid rgba(15,23,42,0.08);border-radius:10px;">
            <div style="display:flex;align-items:center;gap:8px;">
              <div style="width:18px;height:18px;border-radius:4px;background:${it.color};display:flex;align-items:center;justify-content:center;">${production_iconHtml(it, 16)}</div>
              <div style="font-weight:900;color:#0f172a;">${it.name}</div>
            </div>
            ${details ? `<div style="margin-top:4px;font-size:11px;font-weight:900;color:#64748b;">${escapeHtml(details)}</div>` : ""}
            <div style="margin-top:6px;font-size:12px;font-weight:900;color:#334155;">${formatCurrency(val)}${units ? " " + units : ""}</div>
          </div>
        `;
      }).join("")}
    </div>
  </div>

  <div class="section">
    <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Local industry detail</div>
    <div class="tabs" style="margin-bottom:8px;">
      ${PROD_ITEMS.map(it => `
        <div class="tab ${it.id===activeItem?.id ? "active" : ""}" onclick="production_setDetailTab('${it.id}')">${it.name}</div>
      `).join("")}
    </div>
    ${activeNode ? (() => {
      const detail = activeNode.prodDetail?.[activeItem?.id] || {};
      const sub = Array.isArray(activeItem?.subitems) ? activeItem.subitems : [];
      if (!sub.length) return `<div class="hint">No sub-item data available.</div>`;
      const list = sub.map(s => ({
        ...s,
        val: Number(detail[s.id] || 0)
      })).sort((a,b)=> (b.val||0)-(a.val||0));
      const maxVal = Math.max(1, ...list.map(x => x.val || 0));
      return `
        <div style="font-weight:900;color:#334155;font-size:12px;margin-bottom:6px;">
          ${escapeHtml(activeNode?.nodeId || activeNodeId)} ‚Ä¢ ${escapeHtml(state.nodes?.get(activeNodeId)?.name || "")}
        </div>
        ${list.map(s => {
          const pct = Math.max(2, Math.round((s.val / maxVal) * 100));
          return `
            <div style="display:flex;align-items:center;gap:8px;margin-top:6px;">
              <div style="width:18px;height:18px;border-radius:4px;background:${s.color};display:flex;align-items:center;justify-content:center;">${production_iconHtml(s, 14)}</div>
              <div style="min-width:0;flex:1;">
                <div style="font-size:12px;font-weight:900;color:#334155;">${escapeHtml(s.name)}</div>
                <div style="margin-top:3px;height:6px;background:rgba(15,23,42,0.08);border-radius:999px;overflow:hidden;">
                  <div style="width:${pct}%;height:100%;background:${s.color};"></div>
                </div>
              </div>
              <div style="font-size:12px;font-weight:900;color:#334155;">${formatCurrency(s.val)}${units ? " " + units : ""}</div>
            </div>
          `;
        }).join("")}
      `;
    })() : `<div class="hint">Select a city or cluster to see its local production mix.</div>`}
  </div>
`;
}

function renderDynamicsTab(){
const s = state.flowSummary || {};
const dyn = state.dynamics || {};
const isProd = state.primaryTab === "production";

return `

  <div class="section">
    <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Overlay</div>

    <label style="display:flex;gap:10px;align-items:center;font-weight:900;color:#334155;">
      <input type="checkbox" ${dyn.enabled ? "checked" : ""} onchange="setDynamicsEnabled(this.checked)">
      Enable dynamics
    </label>

    <label style="display:flex;gap:10px;align-items:center;font-weight:900;color:#334155;margin-top:8px;">
      <input type="checkbox" ${dyn.showOverlay ? "checked" : ""} onchange="setDynamicsOverlay(this.checked)">
      Show flow overlay
    </label>

    <div style="margin-top:10px;">
      <div class="k">Mode</div>
      <select class="field" onchange="setDynamicsMode(this.value)">
        ${isProd
          ? `<option value="goods" ${dyn.mode==="goods"?"selected":""}>Goods</option>`
          : `<option value="passengers" ${dyn.mode==="passengers"?"selected":""}>Passengers</option>`
        }
      </select>
    </div>

    <!-- Skip 1 Year button moved to mode bar -->
  </div>

  <div class="section">
    <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">${isProd ? "Goods movement (yearly)" : "Passenger movement (yearly)"}</div>

    <div style="margin-top:10px; line-height:1.7;">
      ${kv("Demand met", `${Number(s.demandMetPct||0).toFixed(1)}%`)}
      ${isProd
        ? `
          <br>${kv("Goods demand", fmtNum(s.goodsDemand||0))}
          <br>${kv("Goods by rail", fmtNum(s.goodsByRail||0))}
          <br>${kv("Goods by other", fmtNum(s.goodsByOther||0))}
          <br>${kv("Goods delivered", fmtNum(s.goodsDelivered||0))}
          <br>${kv("Goods unmet", fmtNum(s.goodsUnmet||0))}
        `
        : `
          <br>${kv("Passenger trips", fmtNum(s.passengerTrips||0))}
          <br>${kv("Passenger unmet", fmtNum(s.passengerUnmet||0))}
        `
      }
    </div>
  </div>

  <div class="section">
    <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Economy Impact (yearly)</div>

    <div style="margin-top:10px; line-height:1.7;">
      ${kv("Delivered goods ‚Ç¨", formatCurrency(s.deliveredGoodsEUR || 0))}
      <br>${kv("Delivered passengers ‚Ç¨", formatCurrency(s.deliveredPassengersEUR || 0))}
      <br>${kv("Lost demand ‚Ç¨", formatCurrency(s.lostDemandEUR || 0))}
      <br>${kv("Congestion penalty ‚Ç¨", formatCurrency(s.congestionPenaltyEUR || 0))}
    </div>
  </div>


  <div class="section">
    <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Biggest Export & Biggest Need</div>

    <div style="margin-top:10px; line-height:1.7;">
      ${kv("Top export", `${s.topExportName || "‚Äî"} (${formatCurrency(s.topExportValue||0)})`)}
      <br>${kv("Top need", `${s.topNeedName || "‚Äî"} (${formatCurrency(s.topNeedValue||0)})`)}
    </div>

    <div class="hint" style="margin-top:10px;">
      When we add real ‚Äúgoods types‚Äù, this becomes a per-good export/need list.
    </div>
  </div>

  <div class="section">
    <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Bottleneck</div>

    <div style="margin-top:10px; line-height:1.7;">
      ${kv("Top bottleneck", `${s.topBottleneck || "‚Äî"}`)}
      <br>${kv("Utilization / flow", fmtNum(s.topBottleneckValue||0))}
    </div>
  </div>

<div class="section">
<div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">LUTI Report</div>
<div id="lutiReport"></div>
<div class="hint" style="margin-top:10px;">
  This report summarizes accessibility (and later: monthly population & jobs relocation).
</div>
</div>

<div class="section">
<div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Research controls</div>
<div class="row" style="gap:8px;flex-wrap:wrap;">
  <button class="btn secondary" onclick="ui_runMonths(6)">Run 6 months</button>
  <button class="btn secondary" onclick="ui_runMonths(24)">Run 24 months</button>
  <button class="btn secondary" onclick="exportResultsArtifact()">Export Results</button>
</div>
<div class="hint" style="margin-top:8px;">
  Runs the monthly LUTI update repeatedly (fast) and lets you export an output artifact for papers.
</div>
</div>


`;
}

function ui_fixFieldNames(){
// Only inside the control panel (where your UI is constantly re-rendered)
const root = document.getElementById("controlPanel") || document;

let i = 0;
root.querySelectorAll("input, select, textarea").forEach(el => {
  if (el.type === "hidden") return;
  if (!el.id && !el.name) el.name = `field_${i++}`;
});
}

function ui_renderLutiReport(){
const host = document.getElementById("lutiReport");
if (!host) return;

const access = state?.luti?.accessJobs;
const beta = Number(state?.luti?.beta ?? 0.045);

if (!(access instanceof Map) || access.size === 0){
  host.innerHTML = `
    <div style="font-weight:900;color:#64748b;font-size:12px;line-height:1.4;">
      No accessibility data yet. (It will appear after the first LUTI compute pass.)
    </div>
  `;
  return;
}

const arr = Array.from(access.entries()).map(([id, v]) => ({ id:String(id), v:Number(v||0) }));
arr.sort((a,b)=>b.v-a.v);

const top = arr.slice(0, 6);
const n = arr.length;
const avg = arr.reduce((s,x)=>s+x.v,0) / Math.max(1,n);

host.innerHTML = `
  <div style="font-weight:900;color:#334155;font-size:12px;line-height:1.5;">
    Zones scored: <b>${n}</b><br/>
    Œ≤ (travel-time sensitivity): <b>${beta}</b><br/>
    Avg access (proxy): <b>${Math.round(avg)}</b>
  </div>
  <div style="margin-top:10px;font-size:12px;color:#64748b;font-weight:900;">
    Top accessibility:
    ${top.map(x => {
      const z = state.nodes?.get?.(x.id);
      const name = z?.name || x.id;
      return `<div>‚Ä¢ ${escapeHtml(name)} ‚Äî <b>${Math.round(x.v)}</b></div>`;
    }).join("")}
  </div>
  <div style="margin-top:10px;font-size:12px;color:#64748b;font-weight:900;">
    Next: monthly relocation (Œîpop/Œîjobs) will be shown here.
  </div>
`;
}
window.ui_renderLutiReport = ui_renderLutiReport;
Object.assign(window, {
  ui_captureError,
  ui_clearLastError,
  ui_openDebugDrawer,
  ui_renderErrorBanner,
  togglePanelMinimized,
  ui_setSimSeed,
  ui_randomizeSimSeed,
  ui_toggleClockDisplay,
  ui_toggleClockRunning,
  setClockSpeedFromSlider,
  ui_lineNumberTag,
  construction_hireCrew,
  construction_fireCrew,
  ui_toggleTrackPlanning,
  setTrackLanes,
  createNewLine,
  selectLine,
  undo_pushAction,
  opt_bearingDeg,
  opt_autoBuildNetwork,
  opt_boostFrequencies,
  ensureDefaultTestLine,
  showNodeHover,
  hideNodeHover
});





function updateUI(){
  try { if (typeof unlock_refreshMetrics === "function") unlock_refreshMetrics(); } catch { /* ignore */ }
  if (!state.dynamics) state.dynamics = {};
  if (state.primaryTab === "production" && state.dynamics.mode !== "goods") state.dynamics.mode = "goods";
  if (state.primaryTab !== "production" && state.dynamics.mode !== "passengers") state.dynamics.mode = "passengers";
  const opDay = network_operatingCostEURPerDay();
  if (typeof state.panelVisible !== "boolean") state.panelVisible = false;
  const panel = document.getElementById("controlPanel");
  if (!state.panelVisible){
    panel.style.display = "none";
    try { renderBottomTabBar(); } catch { /* ignore */ }
    try { uiMode_render(); } catch { /* ignore */ }
    return;
  }
  panel.style.display = "";
  const linesArr = Array.from(state.lines.values());
  const editorTypes = ui_allowedLineTypes();
  const editorLines = linesArr.filter(l => editorTypes.includes(l.type || "passenger"));
  const linesList = editorLines.map(l => `
  <div class="item ${l.id===state.activeLine ? "active" : ""}" onclick="selectLine('${l.id}')">
  <div style="font-weight:1000;color:#0f172a">${ui_lineDisplayName(l)}${l.circular ? " ‚ü≥" : ""}</div>
  <div style="font-size:12px;font-weight:900;color:#64748b"> 
  ${l.stops.length} stops ‚Ä¢ ${l.type} 
  <div class="row" style="margin-top:10px;">
  <button class="btn secondary" onclick="saveGame()">Save</button>
  <button class="btn secondary" onclick="loadGame()">Load</button>
  </div>

      </div>
    </div>
  `).join("");
  const lineOptions = [
`<option value="" ${!state.activeLine ? "selected" : ""}>(No line selected ‚Äî Inspect)</option>`,
...editorLines.map(l => `<option value="${l.id}" ${l.id===state.activeLine ? "selected" : ""}>${ui_lineDisplayName(l)} ‚Ä¢ ${l.type}</option>`)
].join("");
const activeLineObjRaw = state.activeLine ? state.lines.get(state.activeLine) : null;
const activeLineAllowed = !!(activeLineObjRaw && editorTypes.includes(activeLineObjRaw.type || "passenger"));
const activeLineObj = activeLineAllowed ? activeLineObjRaw : null;
const activeLineColor = (activeLineObj && activeLineObj.color) ? activeLineObj.color : "#2b6cff";

const statusTypes = (state.primaryTab === "production") ? ["cargo"] : ["passenger"];
const statusLines = linesArr.filter(l => statusTypes.includes(l.type || "passenger"));
const statusLineOptions = [
  `<option value="" ${!state.activeLine ? "selected" : ""}>(No line selected - Inspect)</option>`,
  ...statusLines.map(l => `<option value="${l.id}" ${l.id===state.activeLine ? "selected" : ""}>${ui_lineDisplayName(l)} - ${l.type}</option>`)
].join("");
const statusActiveLineObjRaw = state.activeLine ? state.lines.get(state.activeLine) : null;
const statusActiveLineAllowed = !!(statusActiveLineObjRaw && statusTypes.includes(statusActiveLineObjRaw.type || "passenger"));
const statusActiveLineObj = statusActiveLineAllowed ? statusActiveLineObjRaw : null;
const statusActiveLineDiagramHtml = statusActiveLineObj
  ? ui_lineDiagramHtml(statusActiveLineObj)
  : '<div class="hint">Select a line to view its diagram.</div>';
const statusActiveLineStatusLabel = statusActiveLineObj
  ? `${ui_lineDisplayName(statusActiveLineObj)} (${statusActiveLineObj.type || "passenger"})`
  : "No line selected";
const statusActiveLineRetiringLabel = statusActiveLineObj?.retiring ? " - retiring" : "";

const lineStops = (activeLineObj && Array.isArray(activeLineObj.stops)) ? activeLineObj.stops : [];
const lineStopName = (id) => {
  const n = state.nodes?.get(id);
  return escapeHtml(n?.name || n?.id || id);
};
  const lineStopsListHtml = lineStops.length ? lineStops.map(sid => `
    <div class="item" style="display:flex;justify-content:space-between;gap:10px;align-items:center;">
      <div style="font-weight:950;color:#0f172a;">${lineStopName(sid)}</div>
      <button class="btn danger" onclick="ui_lineRemoveStop('${sid}')">Remove</button>
    </div>
  `).join("") : `<div style="padding:10px;color:#64748b;font-weight:900;">No stops yet.</div>`;

const lineEditorTabsHtml = `
  <div class="tabs" style="margin-bottom:8px;">
    <div class="tab active" style="cursor:default;">
      ${state.primaryTab === "production" ? "Cargo lines" : "Passenger lines"}
    </div>
  </div>
`;
const lineTypeOptions = editorTypes
  .map(t => `<option value="${t}">${t === "mixed" ? "Mixed" : (t === "cargo" ? "Cargo" : "Passenger")}</option>`)
  .join("");

const lineEditorHtml = state.lineBuildMode ? `
  <div class="section">
    ${lineEditorTabsHtml}
    <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Create Line</div>
    <input id="lineName" class="field" placeholder="Line name" />
    <div style="height:8px"></div>
    <select id="lineType" class="field">
      ${lineTypeOptions}
    </select>

    <div style="height:8px"></div>
    <div class="row">
      <input id="lineCars" class="field" type="number" min="1" max="50" step="1" placeholder="Carriages (e.g. 6)">
      <select id="lineSpeedClass" class="field">
        <option value="small">Small (60 km/h)</option>
        <option value="medium">Medium (90 km/h)</option>
        <option value="fast" selected>Fast (120 km/h)</option>
        <option value="high">High speed (200 km/h)</option>
        <option value="bullet">Bullet (300 km/h)</option>
      </select>
    </div>

    <div style="height:8px"></div>
    <div class="hint">
      Timetable controls departures. (No more "trips/day" here.)
    </div>

    <div style="height:8px"></div>
    <label style="display:flex;gap:10px;align-items:center;font-weight:900;color:#334155;">
      <input id="lineCircular" type="checkbox" />
      Circular line
    </label>

    <button class="btn" onclick="createNewLine()">Create Line</button>
  </div>

  <div class="section">
    <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Line editing</div>
    <div class="hint">
      Line edit pauses time for planning. Add stops, remove stops, or retire a line.
    </div>
    <div class="row" style="margin-top:10px;">
      <button class="btn secondary" onclick="ui_toggleAddStops()" ${state.activeLine ? "" : "disabled"}>${state.lineBuildMode ? "Stop adding stops" : "Add stops to active line"}</button>
      <button class="btn secondary" onclick="selectLine('')">No line selected</button>
    </div>
  </div>

  <div class="section">
    <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Optimizer</div>
    <div class="hint">
      Builds lines only on existing track connections.
    </div>
    <div class="row" style="margin-top:10px;">
      <button class="btn danger" onclick="opt_autoBuildNetwork('replace')">Auto-build</button>
    </div>
    <div class="row" style="margin-top:8px;">
      <button class="btn secondary" onclick="opt_boostFrequencies()">Boost frequencies (+20%)</button>
    </div>
  </div>

  <div class="section">
    <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Stops</div>
    <div class="list">${lineStopsListHtml}</div>
  </div>

  <div class="section">
    <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Lines</div>

    <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
      <div style="font-weight:1000;color:#0f172a;">Active line</div>
      ${activeLineObj ? `
        <button class="btn secondary" style="width:auto;padding:8px 10px;margin-top:0;"
          onclick="selectLine('')">No line selected</button>
      ` : `
        <span class="badge">No line selected</span>
      `}
    </div>

    <div style="height:8px"></div>

    <select class="field" onchange="selectLine(this.value)">
      ${lineOptions}
    </select>

    <div style="height:10px"></div>

    <div class="lineInspectorGrid">
      <div class="liField">
        <div class="liLabel">Color</div>
        <input
          type="color"
          value="${activeLineColor}"
          ${activeLineObj ? "" : "disabled"}
          onchange="setActiveLineColor(this.value)"
          style="width:100%;height:38px;border:2px solid #e2e8f0;border-radius:10px;background:transparent;padding:4px;cursor:pointer;"
        />
      </div>

      <div class="liField">
        <div class="liLabel">Carriages</div>
        <input class="field" type="number" id="lineCarriages" min="1" max="50" step="1"
          value="${activeLineObj ? (activeLineObj.carriages || 1) : 1}"
          ${activeLineObj ? "" : "disabled"}
          onchange="setActiveLineCarriages(this.value)"
        />
      </div>

      <div class="liField">
        <div class="liLabel">Speed</div>
        <select class="field" name="speedClass"
          ${activeLineObj ? "" : "disabled"}
          onchange="setActiveLineSpeedClass(this.value)">
          ${["small","medium","fast","high","bullet"].map(k =>
            `<option value="${k}" ${(activeLineObj && activeLineObj.speedClass===k) ? "selected" : ""}>${k}</option>`
          ).join("")}
        </select>
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <div style="font-weight:900;color:#334155;">Line name</div>
      <input class="field" type="text" placeholder="Line name"
        value="${activeLineObj ? escapeHtml(activeLineObj.name || "") : ""}"
        ${activeLineObj ? "" : "disabled"}
        onchange="setActiveLineName(this.value)">
    </div>

    <div class="row" style="margin-top:10px;">
      <div style="font-weight:900;color:#334155;">Line #</div>
      <input class="field" type="number" min="1" step="1"
        value="${Number.isFinite(activeLineObj?.number) ? activeLineObj.number : ""}"
        ${activeLineObj ? "" : "disabled"}
        onchange="setActiveLineNumber(this.value)">
    </div>

    <div class="row" style="margin-top:10px;">
      <div style="font-weight:900;color:#334155;">Dwell / stop (sec)</div>
      <input class="field" name="dwellSec" type="number" min="0" step="5"
        value="${Number(activeLineObj?.dwellSec ?? 60)}"
        ${activeLineObj ? "" : "disabled"}
        onchange="ui_lineSetDwellSec(this.value)">
    </div>

    <div style="margin-top:8px;color:#64748b;font-weight:850;font-size:12px;line-height:1.35;">
      ${activeLineObj ? (() => {
        try { line_recalcDerived(activeLineObj); } catch { /* ignore */ }
        const pax = Number(activeLineObj.capacityPax || 0);
        const cargo = Number(activeLineObj.capacityCargo || 0);
        const kmh = Number(activeLineObj.speedKmh || 0);
        const maint = line_trainMaintenanceCostEURPerYear(activeLineObj);
        const lineCostDay = line_operatingCostEURPerDay(activeLineObj);
        const capTxt = (activeLineObj.type==="cargo") ? `Capacity: <b>${fmtNum(cargo)}</b> cargo units` :
                       (activeLineObj.type==="mixed") ? `Capacity: <b>${fmtNum(pax)}</b> pax + <b>${fmtNum(cargo)}</b> cargo` :
                       `Capacity: <b>${fmtNum(pax)}</b> pax`;
        return `${capTxt} ‚Ä¢ Speed: <b>${Math.round(kmh)}</b> km/h ‚Ä¢ Fleet maintenance: <b>${formatCurrency(maint)}</b>/year ‚Ä¢ Line Cost (day): <b>${kv("Op cost/day", formatCurrency(lineCostDay))}</b>
      ` ;
      })() : "Select a line to edit carriages and speed."}
    </div>

    ${activeLineObj ? (() => {
      const m = line_calcDerivedMetrics(activeLineObj);

      const fmt = (x, suf="") => (x==null || !isFinite(x)) ? "‚Äî" : `${(x>=100 ? Math.round(x) : x.toFixed(1))}${suf}`;

      return `
        <div class="section" style="margin-top:10px;">
          <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Derived metrics</div>
          <div style="line-height:1.7;">
            ${kv("Planned departures", fmtNum(m.plannedDepartures))}
            <br>${kv("Avg headway", `${fmt(m.headwayMin, " min")}`)}
            <br>${kv("Service window", `${fmt(m.serviceWindowMin, " min")}`)}
            <br>${kv("One-way travel", `${fmt(m.oneWayMin, " min")}`)}
            <br>${kv("Round trip", `${fmt(m.roundTripMin, " min")}`)}
            <br>${kv("Required trains", m.requiredTrains==null ? "‚Äî" : fmtNum(m.requiredTrains))}
          </div>
        </div>
      `;
    })() : ""}

    <div style="margin-top:8px;color:#64748b;font-weight:850;font-size:12px;">
      Tip: choose "No line selected" to click nodes without adding stops.
    </div>
  </div>

  <div class="list">${linesList || `<div style="padding:14px;color:#64748b;font-weight:1000;">No lines yet</div>`}</div>

  <div class="row" style="margin-top:10px;">
    <button class="btn secondary" onclick="toggleCircularActive()">Toggle circular</button>
    <button class="btn danger" onclick="deleteActiveLine()">Delete line</button>
  </div>
  ${ui_lineSchedulePanelHtml()}

  <div class="row" style="margin-top:10px;">
    <div style="font-weight:900;color:#334155;">Day service start</div>
    <div style="display:flex;gap:8px;align-items:center;">
      <input class="field" type="time"
        value="${minToHHMM(activeLineObj?.serviceStartMin ?? 330)}"
        ${activeLineObj ? "" : "disabled"}
        onchange="ui_lineSetServiceStart(this.value)">
      <span style="font-weight:900;">to 00:00</span>
    </div>
  </div>
  <div style="margin-top:6px;color:#64748b;font-weight:850;font-size:12px;">
    Night departures end at 08:00. Night service trains cost more.
  </div>

  <div class="row" style="margin-top:6px;">
    <label style="display:flex;gap:8px;align-items:center;">
      <input type="checkbox"
        ${activeLineObj?.nightService ? "checked" : ""}
        ${activeLineObj ? "" : "disabled"}
        onchange="ui_lineToggleNight(this.checked)">
      <span style="font-weight:900;color:#334155;">Night service</span>
    </label>
  </div>

  ${activeLineObj?.nightService ? `
    <div class="row" style="margin-top:6px;">
      <div style="font-weight:900;color:#334155;">Night headway (min)</div>
      <input class="field" type="number" min="15" step="5"
        value="${activeLineObj.nightHeadwayMin}"
        onchange="ui_lineSetNightHeadway(this.value)">
    </div>
  ` : ""}
` : "";

  const isPopulationTab = state.primaryTab !== "production";
  const seedVal = Number(state.simSeed ?? state.meta?.seed ?? 1);
  const datasetVersion = state.meta?.datasetVersion || window.datasetVersion || "n/a";
  const modelVersion = state.meta?.modelVersion || window.modelVersion || "n/a";
  const schemaVersion = state.meta?.schemaVersion || window.schemaVersion || "n/a";
  const productionTabHtml = (!isPopulationTab && state.activeTab === "network") ? renderProductionTab() : "";
  const dynamicsTabHtml = state.activeTab==="dynamics"
    ? renderDynamicsTab()
    : "";

  const scenTitle =
  (state.scenarioMeta && state.scenarioMeta.title)
    ? ` ‚Ä¢ <span class="badge">${state.scenarioMeta.title}</span>`
    : "";
  const scenarioPanelHtml = ui_scenarioPanelHtml();
  const activeCluster = state.activeClusterId ? state.clusters.get(state.activeClusterId) : null;

  const cons = state.construction || { queue: [], active: [], history: [] };
  const nodeName = (id) => {
    const n = state.nodes.get(id);
    return n ? (n.name || n.id) : String(id);
  };
  const jobProgressPct = (j) => {
    if (!j || !j.totalDays) return 0;
    return Math.round(((j.totalDays - j.remainingDays) / j.totalDays) * 100);
  };
  const jobCostLeft = (j) => Math.max(0, Number(j.costTotal || 0) - Number(j.costPaid || 0));
  const jobRow = (j, label, canCancel=false) => {
    const issueActive = j.issue && j.issue.active && !j.issue.resolved;
    const issueBtn = issueActive
      ? `<button class="btn warning" onclick="construction_resolveIssue('${j.id}')">Resolve issue (${formatCurrency(j.issue.cost)})</button>`
      : "";
    const cancelBtn = canCancel
      ? `<button class="btn secondary" onclick="construction_cancelQueued('${j.id}')">Cancel</button>`
      : "";
    return `
      <div class="item" style="cursor:default;">
        <div style="font-weight:900;color:#0f172a;">${label} - ${j.type === "build" ? "Build" : "Demolish"}</div>
        <div style="color:#64748b;font-weight:850;font-size:12px;line-height:1.35;">
          ${nodeName(j.from)} -> ${nodeName(j.to)} - ${j.remainingDays}d left - ${jobProgressPct(j)}% - ${formatCurrency(jobCostLeft(j))} remaining
        </div>
        ${issueBtn}
        ${cancelBtn}
      </div>
    `;
  };
  const activeJobs = (cons.active || []).map(j => jobRow(j, "Active", false)).join("");
  const queuedJobs = (cons.queue || []).map(j => jobRow(j, "Queued", true)).join("");
  const constructionQueueHtml = (activeJobs || queuedJobs)
    ? `<div class="list">${activeJobs}${queuedJobs}</div>`
    : `<div class="hint">No construction scheduled.</div>`;

  const crewMax = Number(CONFIG.TRACK_BUILD_MAX_CREWS || 2);
  const crewCap = clamp(Number(cons.crewCap || crewMax), 1, crewMax);
  const crewMin = Math.max(1, (cons.active || []).length);
  const trackJobRow = (j) => {
    const daysLeft = Number(j.remainingDays || 0);
    return `
      <div class="item" style="cursor:default;">
        <div style="font-weight:900;color:#0f172a;">${j.type === "build" ? "Build" : "Demolish"}: ${nodeName(j.from)} -> ${nodeName(j.to)}</div>
        <div style="color:#64748b;font-weight:850;font-size:12px;line-height:1.35;">
          ${daysLeft}d left ‚Ä¢ ${jobProgressPct(j)}% ‚Ä¢ ${formatCurrency(jobCostLeft(j))} remaining
        </div>
      </div>
    `;
  };
  const trackJobs = [
    ...(cons.active || []).map(trackJobRow),
    ...(cons.queue || []).map(trackJobRow)
  ].join("");
  const trackWorkListHtml = trackJobs
    ? `<div class="list">${trackJobs}</div>`
    : `<div class="hint">No track segments scheduled.</div>`;

  const econ = state.economy || {};
  const exporterName = econ.biggestExporter?.id ? (state.nodes.get(econ.biggestExporter.id)?.name || econ.biggestExporter.id) : "‚Äî";
  const importerName = econ.biggestImporter?.id ? (state.nodes.get(econ.biggestImporter.id)?.name || econ.biggestImporter.id) : "‚Äî";
  const prodMacro = state.production?.macro || {};
  const prodYear = prodMacro.year || "";
  const prodSource = prodMacro.source || "";
  // --- Score (0..100): UI-only, robust defaults ---
  const ssum = state.flowSummary || {};
  const _lines = (state.lines instanceof Map) ? Array.from(state.lines.values()) : [];
  const _tracks = (state.tracks instanceof Map) ? Array.from(state.tracks.values()) : [];
  const _nodes = (state.nodes instanceof Map) ? state.nodes : new Map();

  // service capacity proxy (cap/day)
  let _capPerDay = 0;
  for (const l of _lines) {
    const f = Math.max(0, Number(l.frequencyPerDay || 0));
    const c = Math.max(0, Number(l.vehicleCapacity || 0));
    _capPerDay += f * c;
  }

  // network size proxy (track km)
  let _trackKm = 0;
  if (map && map.distance && _tracks.length) {
    for (const t of _tracks) {
      const a = _nodes.get(t.from);
      const b = _nodes.get(t.to);
      if (!a || !b) continue;

      const d = map.distance(
        [Number(a.lat), Number(a.lon)],
        [Number(b.lat), Number(b.lon)]
      );
      if (Number.isFinite(d)) _trackKm += d / 1000;
    }
  }

  const _demandMet = clamp(Number(ssum.demandMetPct || 0), 0, 100);

  const _deliveredEUR = Math.max(
    0,
    Number(ssum.deliveredGoodsEUR || 0) + Number(ssum.deliveredPassengersEUR || 0)
  );
  const _congEUR = Math.max(0, Number(ssum.congestionPenaltyEUR || 0));
  const _penRate = _deliveredEUR > 0 ? clamp(_congEUR / _deliveredEUR, 0, 1) : 0;
  const _reliability = Math.round(100 * (1 - _penRate));

  // profit score (smooth, handles negatives)
  const _profit = Number(state.profit || 0);
  const _profitScore = Math.round(50 + 50 * Math.tanh(_profit / 200000000)); // ¬±‚Ç¨200M scale

  // service score (log-scaled so it doesn't explode)
  const _serviceScore = Math.round(clamp(
    12 * Math.log10(1 + (_capPerDay / 1000)) +
    18 * Math.log10(1 + (_trackKm / 50)),
    0, 100
  ));

  const _totalScore = Math.round(clamp(
    0.30 * _profitScore +
    0.30 * _demandMet +
    0.25 * _serviceScore +
    0.15 * _reliability,
    0, 100
  ));

  const _scoreColor = _totalScore >= 70 ? "#10b981" : (_totalScore >= 45 ? "#f59e0b" : "#ef4444");

  const scorePanelHtml = `
    <div class="hint" style="margin-top:10px;">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
        <div style="font-weight:1000;color:#0f172a;">Score</div>
        <div style="font-weight:1000;color:${_scoreColor};font-size:18px;">${_totalScore}/100</div>
      </div>

      <div style="height:8px;"></div>
      <div style="height:10px;background:#e2e8f0;border-radius:999px;overflow:hidden;">
        <div style="height:10px;width:${_totalScore}%;background:${_scoreColor};"></div>
      </div>

      <div style="margin-top:10px;line-height:1.7;">
        ${kv("Profit score", fmtNum(_profitScore))}
        <br>${kv("Demand met", `${_demandMet.toFixed(1)}%`)}
        <br>${kv("Service score", fmtNum(_serviceScore))}
        <br>${kv("Reliability", `${fmtNum(_reliability)}%`)}
      </div>

      <div style="margin-top:8px;color:#64748b;font-weight:850;font-size:12px;">
        Score = weighted mix of profit, demand met, service capacity√ónetwork size, and congestion reliability.
      </div>
    </div>
  `;


  const unlock = state.unlocks || {};
  const unlockCatalog = (typeof getCountryCatalog === "function") ? getCountryCatalog() : [];
  const unlockedSet = new Set(Array.isArray(unlock.unlockedCountries) ? unlock.unlockedCountries : []);
  const lastMonthLabel = unlock.lastMonthLabel || "last month";
  const interPct = Number(unlock.interconnectivityPct || 0).toFixed(1);
  const lastMonthProfit = (unlock.lastMonthProfit ?? unlock.monthlyProfit ?? 0);

  const expansionList = unlockCatalog.length
    ? `<div class="list">${unlockCatalog.map(spec => {
        const isCurrent = spec.id === (state.countryId || "ES");
        const isUnlocked = unlockedSet.has(spec.id);
        const rule = (typeof getCountryUnlockRule === "function") ? getCountryUnlockRule(spec.id) : null;
        const req = rule
          ? `${fmtNum(rule.minInterconnectPct)}% interconnectivity + ${formatCurrency(rule.minMonthlyProfit)}/mo`
          : "No unlock rule";
        const status = isCurrent ? "Active" : (isUnlocked ? "Unlocked" : "Locked");
        const action = (!isCurrent && isUnlocked)
          ? `<div style="margin-top:6px;"><button class="btn secondary" onclick="loadCountry('${spec.id}')">Enter</button></div>`
          : "";
        const hint = isCurrent
          ? "Current country"
          : (isUnlocked ? "Ready to enter" : `Requires ${req}`);
        return `
          <div class="item" style="display:flex;align-items:flex-start;justify-content:space-between;gap:10px;">
            <div>
              <div style="font-weight:900;">${spec.name || spec.id}</div>
              <div class="hint" style="margin-top:4px;">${hint}</div>
            </div>
            <div style="text-align:right;min-width:90px;">
              <div class="badge">${status}</div>
              ${action}
            </div>
          </div>
        `;
      }).join("")}</div>`
    : `<div class="hint">No country catalog available.</div>`;

  const expansionPanelHtml = `
    <div class="section">
      <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Global expansion</div>
      <div class="hint">
        <div>${kv("Interconnectivity", `${interPct}%`)}</div>
        <div>${kv("Monthly profit", `${formatCurrency(lastMonthProfit)} (${lastMonthLabel})`)}</div>
      </div>
      <div style="margin-top:10px;">${expansionList}</div>
      <div class="hint" style="margin-top:8px;">
        Unlocks require both interconnectivity and monthly profit thresholds.
      </div>
    </div>
  `;

  const reportRowCount = Array.isArray(state.simReportRows) ? state.simReportRows.length : 0;
  const reportSeed = Number(state.simSeed ?? state.meta?.seed ?? 1);
  const reportRawRunId = state.meta?.runId || "pending";
  const reportRunIdShort = escapeHtml(
    reportRawRunId.length > 32
      ? `${reportRawRunId.slice(0, 16)}‚Ä¶${reportRawRunId.slice(-12)}`
      : reportRawRunId
  );
  const reportRunId = escapeHtml(reportRawRunId);
  const reportPanelHtml = `
    <div class="section">
      <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Model report export</div>
      <div class="hint" style="font-size:12px;margin-bottom:8px;">
        Rows collected: ${fmtNum(reportRowCount)} ¬∑ Run ID: ${reportRunId}
        <br>Versions: dataset ${datasetVersion} ¬∑ model ${modelVersion} ¬∑ schema ${schemaVersion}
      </div>
      <div class="hint" style="font-size:12px;margin-bottom:8px;display:flex;flex-wrap:wrap;gap:10px;align-items:center;">
        <div>Seed ${fmtNum(reportSeed)}</div>
        <div>Run ID preview: ${reportRunIdShort}</div>
        <button class="btn secondary" style="white-space:nowrap;padding:6px 10px;font-size:11px;height:auto;" onclick="ui_copyReportRunId()">Copy run ID</button>
      </div>
      <div class="row" style="gap:8px;flex-wrap:wrap;">
        <button class="btn secondary" style="white-space:nowrap;" onclick="exportSimReportJson()">Download JSON</button>
        <button class="btn secondary" style="white-space:nowrap;" onclick="exportSimReportCsv()">Download CSV</button>
      </div>
      <div class="hint" style="margin-top:10px;">
        Includes deterministic tick rows and metadata so every publishable run can be reproduced.
      </div>
    </div>
  `;

  // --- Line effectiveness ranking (capacity-km/day) ---
  const lineEffect = [];
  for (const l of linesArr) {
    const stops = Array.isArray(l.stops) ? l.stops : [];
    if (stops.length < 2) continue;

    const freq = Math.max(0, Number(l.frequencyPerDay || 0));
    const defaultCap = (l.type === "cargo") ? 1200 : (l.type === "mixed") ? 700 : 350;
    const vehCap = Math.max(0, Number(l.vehicleCapacity || defaultCap));

    let km = 0;
    if (map && state.nodes) {
      for (let i = 1; i < stops.length; i++) {
        const a = state.nodes.get(stops[i - 1]);
        const b = state.nodes.get(stops[i]);
        if (!a || !b) continue;

        const d = map.distance(
          [Number(a.lat), Number(a.lon)],
          [Number(b.lat), Number(b.lon)]
        );
        if (Number.isFinite(d)) km += d / 1000;
      }

      // if circular, close the loop for length estimation
      if (l.circular && stops.length >= 3) {
        const a = state.nodes.get(stops[stops.length - 1]);
        const b = state.nodes.get(stops[0]);
        if (a && b) {
          const d = map.distance(
            [Number(a.lat), Number(a.lon)],
            [Number(b.lat), Number(b.lon)]
          );
          if (Number.isFinite(d)) km += d / 1000;
        }
      }
    }

    const capKmPerDay = km * freq * vehCap;

    lineEffect.push({
      id: l.id,
      name: ui_lineDisplayName(l),
      type: l.type || "passenger",
      color: l.color || "#2b6cff",
      km,
      freq,
      vehCap,
      capKmPerDay
    });
  }

  lineEffect.sort((a, b) => (b.capKmPerDay || 0) - (a.capKmPerDay || 0));
  const topLines = lineEffect.slice(0, 8);

  const lineRankingHtml = topLines.length ? topLines.map(r => `
    <div class="item" onclick="selectLine('${r.id}')">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
        <div style="display:flex;align-items:center;gap:8px;min-width:0;">
          <span style="width:12px;height:12px;border-radius:4px;flex:0 0 12px;background:${r.color};border:1px solid rgba(0,0,0,0.2);"></span>
          <div style="font-weight:1000;color:#0f172a;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${r.name}</div>
          <span class="badge">${r.type}</span>
        </div>
        <div style="font-weight:1000;color:#0f172a;white-space:nowrap;">${fmtNum(Math.round((r.capKmPerDay || 0) / 1000))}k</div>
      </div>
      <div style="margin-top:4px;font-size:12px;font-weight:900;color:#64748b;">
        ${(Number.isFinite(r.km) ? r.km : 0).toFixed(1)} km ‚Ä¢ ${fmtNum(Math.round(r.freq || 0))}/day ‚Ä¢ cap ${fmtNum(Math.round(r.vehCap || 0))}
      </div>
    </div>
  `).join("") : `
    <div style="padding:12px;color:#64748b;font-weight:1000;">
      Create a line with 2+ stops to see rankings.
    </div>
  `;


  // --- Network KPIs (UI-only; safe defaults) ---
  const tracksCount = state.tracks?.size || 0;
  const nodesCount = state.nodes?.size || 0;
  const linesCount = linesArr.length;

  let totalTrainsPerDay = 0;
  let totalCapacityPerDay = 0;
  let totalStops = 0;

  const stationMoves = new Map(); // nodeId -> trains/day (sum of frequencies)
  for (const l of linesArr) {
    const f = Math.max(0, Number(l.frequencyPerDay || 0));
    totalTrainsPerDay += f;
    totalCapacityPerDay += f * Math.max(0, Number(l.vehicleCapacity || 0));
    totalStops += Array.isArray(l.stops) ? l.stops.length : 0;

    if (Array.isArray(l.stops)) {
      for (const sid of l.stops) {
        stationMoves.set(sid, (stationMoves.get(sid) || 0) + f);
      }
    }
  }

  const avgStopsPerLine = linesCount ? (totalStops / linesCount) : 0;

  let busiestStationId = null;
  let busiestMoves = 0;
  for (const [sid, mv] of stationMoves.entries()) {
    if (mv > busiestMoves) { busiestMoves = mv; busiestStationId = sid; }
  }
  const busiestStationName = busiestStationId && state.nodes?.get(busiestStationId)
    ? (state.nodes.get(busiestStationId).name || busiestStationId)
    : "‚Äî";

  let trackKm = 0;
  if (map && state.tracks && typeof state.tracks.values === "function") {
    for (const t of state.tracks.values()) {
      const a = state.nodes?.get(t.from);
      const b = state.nodes?.get(t.to);
      if (!a || !b) continue;

      const d = map.distance(
        [Number(a.lat), Number(a.lon)],
        [Number(b.lat), Number(b.lon)]
      );
      if (Number.isFinite(d)) trackKm += d / 1000;
    }
  }

  state.validatorWarnings = runStateValidator();
  const validatorWarningHtml = ui_validatorWarningsHtml();

  if (!state.debug) state.debug = {};
  const clockSpeed = Number(state.clock?.speed || 0);
  const clockLabel = state.clock?.running
    ? `running x${Math.round(clockSpeed || 0)}`
    : "paused";
  const calendarText = (typeof calendar_label === "function") ? calendar_label() : "";
  state.debug.lastSimStats = [
    ["Year", fmtNum(Number(state.year || 0))],
    ["Calendar", calendarText || "n/a"],
    ["Service day", fmtNum(Number(state.service?.day || 0))],
    ["Budget", formatCurrency(state.budget)],
    ["Revenue", formatCurrency(state.revenue)],
    ["Costs", formatCurrency(state.costs)],
    ["Profit", formatCurrency(state.profit)],
    ["Nodes", fmtNum(nodesCount)],
    ["Tracks", fmtNum(tracksCount)],
    ["Lines", fmtNum(linesCount)],
    ["Track km", fmtNum(Number(trackKm.toFixed(1)))],
    ["Trains/day", fmtNum(Math.round(totalTrainsPerDay))],
    ["Capacity/day", fmtNum(Math.round(totalCapacityPerDay))],
    ["Clock", clockLabel]
  ];
  state.debug.lastSimStatsAt = Date.now();

const lineStatusBlockHtml = `
      <div class="section">
        <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Active line status</div>
        <div class="hint" style="margin-bottom:8px;">
          ${statusActiveLineStatusLabel}${statusActiveLineRetiringLabel}
        </div>
        <select class="field" onchange="selectLine(this.value)">
          ${statusLineOptions}
        </select>
        <div style="height:8px;"></div>
        <div id="lineDiagram">${statusActiveLineDiagramHtml}</div>
      </div>
`;


  
const networkTabHtml = state.activeTab==="network"
  ? (isPopulationTab ? `

      <div class="section">
        <div class="hint">
          <b>Clusters are dots:</b> left-click selects, right-click zooms in.<br>
          <b>Smart lines:</b> stops are auto-ordered to reduce criss-cross, and tracks are auto-built between stops.
        </div>

        <!-- Skip 1 Year button moved to mode bar -->
        <button class="btn secondary" onclick="exportScenario()">Export Scenario</button>
        <button class="btn secondary" onclick="undo_applyLast()">Undo last action</button>
        <button class="btn secondary" onclick="exportResultsArtifact()">Export Results</button>
        <button class="btn secondary" onclick="ui_pickResultsImport()">Import Results</button>
        <input type="file" id="resultsImportFile" name="resultsImportFile" accept="application/json" style="display:none" onchange="ui_importResultsFile(this.files && this.files[0])">
      </div>

      <div class="section">
        <div style="font-weight:1000;color:#0f172a;margin-bottom:6px;">Deterministic seed</div>
        <div class="row" style="gap:8px;align-items:center;">
          <input id="seedInput" class="field" type="number" min="1" step="1" value="${seedVal}" onchange="ui_setSimSeed(this.value)" style="flex:1;">
          <button class="btn secondary" style="width:auto;padding:8px 12px;margin-top:0;" onclick="ui_randomizeSimSeed()">Randomize</button>
        </div>
        <div class="hint" style="margin-top:8px;font-size:11px;">
          Seed controls provide deterministic reproduce runs; changing it updates run metadata.
        </div>
        <div class="hint" style="margin-top:6px;font-size:11px;">
          Versions: dataset ${datasetVersion} ¬∑ model ${modelVersion} ¬∑ schema ${schemaVersion}
        </div>
      </div>

        <div class="section">
          <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Active line status</div>
        <div class="hint" style="margin-bottom:8px;">
          ${statusActiveLineStatusLabel}${statusActiveLineRetiringLabel}
        </div>
        <select class="field" onchange="selectLine(this.value)">
          ${statusLineOptions}
        </select>
        <div style="height:8px;"></div>
        <div id="lineDiagram">${statusActiveLineDiagramHtml}</div>
      </div>
    
` : (productionTabHtml + lineStatusBlockHtml))
  : "";
const transportTabHtml = state.activeTab==="tracks" ? `

      <div class="section">
        <div class="row" style="margin-bottom:8px;gap:8px;">
          <button class="btn secondary" style="width:auto;padding:8px 10px;margin-top:0;" onclick="setTrackBuildMode(${!state.trackBuildMode})">
            ${state.trackBuildMode ? "Exit Build Mode" : "Enter Build Mode"}
          </button>
          <button class="btn secondary" style="width:auto;padding:8px 10px;margin-top:0;" onclick="setLineBuildMode(!state.lineBuildMode)">
            ${state.lineBuildMode ? "Exit Line Edit" : "Enter Line Edit"}
          </button>
        </div>
      </div>

      ${state.trackBuildMode ? `
        <div class="section">
          <div class="hint">
            Build mode plans segments; crews build over sim-time. Demolition requires removing all lines using the track.
          </div>

          <div class="row" style="margin-top:10px;">
            <button class="btn ${state.trackBuildAction==="build" ? "success" : "secondary"}"
              onclick="setTrackBuildAction('build')">Build</button>
            <button class="btn ${state.trackBuildAction==="demolish" ? "danger" : "secondary"}"
              onclick="setTrackBuildAction('demolish')">Demolish</button>
          </div>

          <div style="margin-top:10px;">
            <div class="k">Lanes</div>
            <select class="field" onchange="setTrackLanes(this.value)" ${state.trackBuildAction==="demolish" ? "disabled" : ""}>
              <option value="1" ${state.pendingTrackLanes===1?"selected":""}>1 lane</option>
              <option value="2" ${state.pendingTrackLanes===2?"selected":""}>2 lanes</option>
              <option value="3" ${state.pendingTrackLanes===3?"selected":""}>3 lanes</option>
              <option value="4" ${state.pendingTrackLanes===4?"selected":""}>4 lanes</option>
              <option value="5" ${state.pendingTrackLanes===5?"selected":""}>5 lanes</option>
              <option value="6" ${state.pendingTrackLanes===6?"selected":""}>6 lanes</option>
            </select>
          </div>

          <div class="hint" style="margin-top:10px;">
            ${state.trackBuildAction==="build"
              ? `Plan by clicking nodes in sequence. Current start: <b>${state.pendingTrackNode ? state.pendingTrackNode.name : "(none)"}</b>`
              : `Demolish mode: click a track segment to schedule removal.`}
          <br>Active crews: <b>${(state.construction?.active || []).length}</b> / <b>${crewCap}</b>
        </div>
        </div>

        <div class="section">
          <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Construction</div>
          ${constructionQueueHtml}
        </div>
      ` : ""}

      ${state.lineBuildMode ? `
        <div class="tabs" style="margin-top:6px;">
          <div class="tab active" style="cursor:default;">Line editor</div>
        </div>
      ` : ""}

      ${lineEditorHtml}

${state.trackBuildMode && state.selectedNode ? (() => {
const st = getStation(state.selectedNode.id);
const cP = stationUpgradeCost("platforms", st);
const cA = stationUpgradeCost("amenities", st);
const cR = stationUpgradeCost("retail", st);
 const p = state.stationPressure.get(String(state.selectedNode.id)) || { demand: 0, supply: 0, pressurePct: 0 };


return `
  <div class="section">
    <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Station: ${state.selectedNode.name}</div>
    <div class="hint" style="line-height:1.7;">
      ${kv("Level", fmtNum(st.level))}
      <br>${kv("Platforms", fmtNum(st.platforms))}
      <br>${kv("Amenities", fmtNum(st.amenities))}
      <br>${kv("Retail", fmtNum(st.retail))}
    </div>

<div class="hint" style="margin-top:8px; line-height:1.7;">
${kv(
  "Pressure",
  `<b style="color:${
    p.pressurePct >= 70 ? "#ef4444" :
    p.pressurePct >= 35 ? "#f59e0b" :
                          "#10b981"
  }">${p.pressurePct}%</b>`
)}
<br>${kv("Demand / day", fmtNum(Math.round(p.demand || 0)))}
<br>${kv("Supply / day", fmtNum(Math.round(p.supply || 0)))}
</div>


    <div class="row" style="margin-top:10px;">
      <button class="btn secondary" onclick="upgradeStation('platforms')">+ Platform (${formatCurrency(cP)})</button>
      <button class="btn secondary" onclick="upgradeStation('amenities')">+ Amenities (${formatCurrency(cA)})</button>
    </div>
    <button class="btn secondary" onclick="upgradeStation('retail')">+ Retail (${formatCurrency(cR)})</button>

    <div class="hint" style="margin-top:10px;">
      Platforms will later increase how many trains can be handled without ‚Äúdelay‚Äù.
      Amenities reduce crowd pressure.
      Retail generates yearly rent revenue.
    </div>
  </div>
`;
})() : ""}

      <div class="section">
        <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Track works</div>
        <div class="hint">
          <div>${kv("Mode", state.trackBuildMode ? (state.trackBuildAction === "demolish" ? "Demolish (active)" : "Build (active)") : "Off")}</div>
          <div>${kv("Active crews", fmtNum((cons.active || []).length) + " / " + fmtNum(crewCap))}</div>
          <div>${kv("Active jobs", "Build " + fmtNum((cons.active || []).filter(j=>j.type==="build").length) + " / Demolish " + fmtNum((cons.active || []).filter(j=>j.type==="demolish").length))}</div>
          <div>${kv("Queued jobs", "Build " + fmtNum((cons.queue || []).filter(j=>j.type==="build").length) + " / Demolish " + fmtNum((cons.queue || []).filter(j=>j.type==="demolish").length))}</div>
        </div>
        <div class="row" style="margin-top:10px;">
          <button class="btn secondary" onclick="construction_hireCrew()" ${crewCap >= crewMax ? "disabled" : ""}>Hire crew</button>
          <button class="btn secondary" onclick="construction_fireCrew()" ${crewCap <= crewMin ? "disabled" : ""}>Fire crew</button>
        </div>
        <div style="margin-top:10px;">
          ${trackWorkListHtml}
        </div>
      </div>

      <div class="section">
        <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Line retirement</div>
        <div class="hint">
          ${activeLineObj && activeLineObj.retiring ? (() => {
            const dayNow = Number(state.service?.day || 0);
            const start = Number(activeLineObj.retireStartDay || dayNow);
            const wait = Number(activeLineObj.retireDays || CONFIG.LINE_RETIRE_DAYS || 7);
            const left = Math.max(0, Math.ceil((start + wait) - dayNow));
            return `<div>${kv("Active line", escapeHtml(ui_lineDisplayName(activeLineObj)))}</div>
                    <div>${kv("Days remaining", fmtNum(left))}</div>`;
          })() : `<div>No line is retiring.</div>`}
        </div>
      </div>

`
: "";
const economyTabHtml = state.activeTab==="economy"
  ? (isPopulationTab ? `

      <div class="section">
        <div class="hint">
          Economy now uses <b>flows</b> (passenger-km & ton-km) limited by <b>service capacity</b> (freq √ó vehicle capacity) and <b>track capacity</b> (lanes).
        </div>
<div style="margin-top:10px;" class="hint">
<div style="font-weight:1000;color:#0f172a;margin-bottom:6px;">Network KPIs</div>
<div>${kv("Stations loaded", fmtNum(nodesCount))}</div>
<div>${kv("Tracks built", fmtNum(tracksCount))}</div>
<div>${kv("Track length", fmtNum(Number(trackKm.toFixed(1))) + " km")}</div>
<div>${kv("Lines", fmtNum(linesCount))}</div>
<div>${kv("Trains/day", fmtNum(Math.round(totalTrainsPerDay)))}</div>
<div>${kv("Capacity/day", fmtNum(Math.round(totalCapacityPerDay)))}</div>
<div>${kv("Avg stops/line", fmtNum(Number(avgStopsPerLine.toFixed(1))))}</div>
<div>${kv("Busiest station", busiestStationName==="‚Äî" ? "‚Äî" : (busiestStationName + " (" + fmtNum(Math.round(busiestMoves)) + "/day)"))}</div>
</div>

        <div style="margin-top:10px;">
          <div>${kv("Annual revenue", formatCurrency(state.revenue))}</div>
          <div>${kv("Annual costs", formatCurrency(state.costs))}</div>
          <div>${kv("Annual profit", `<span style="color:${state.profit>=0?"#10b981":"#ef4444"}">${formatCurrency(state.profit)}</span>`)}</div>
        </div>

        ${scorePanelHtml}

        ${expansionPanelHtml}

        ${reportPanelHtml}

        <div style="margin-top:10px;" class="hint">
          <div>${kv("Passenger-km moved", fmtNum(Math.round(econ.paxKmMoved || 0)))}</div>
          <div>${kv("Cargo ton-km moved", fmtNum(Math.round(econ.tonKmMoved || 0)))}</div>
          <div>${kv("Biggest exporter", `${exporterName} (${formatCurrency(econ.biggestExporter?.exports || 0)})`)}</div>
          <div>${kv("Biggest needs", `${importerName} (${formatCurrency(econ.biggestImporter?.imports || 0)})`)}</div>
        </div>

        <div style="margin-top:12px;">
          <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Most effective lines</div>
          <div class="list" style="max-height:240px;">${lineRankingHtml}</div>
          <div style="margin-top:8px;color:#64748b;font-weight:850;font-size:12px;">
            Effectiveness = route km √ó trains/day √ó vehicle capacity (capacity-km/day). Click a line to select it.
          </div>
        </div>

        <!-- Skip 1 Year button moved to mode bar -->
      </div>


    
` : `
      <div class="section">
        <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Industry economy</div>
        <div style="margin-top:10px; line-height:1.7;">
          ${kv("Year", prodYear || "n/a")}
          <br>${kv("Goods demand", fmtNum(ssum.goodsDemand||0))}
          <br>${kv("Goods by rail", fmtNum(ssum.goodsByRail||0))}
          <br>${kv("Goods by other", fmtNum(ssum.goodsByOther||0))}
          <br>${kv("Goods delivered", fmtNum(ssum.goodsDelivered||0))}
          <br>${kv("Goods unmet", fmtNum(ssum.goodsUnmet||0))}
          <br>${kv("Delivered goods EUR", formatCurrency(ssum.deliveredGoodsEUR || 0))}
          <br>${kv("Lost demand EUR", formatCurrency(ssum.lostDemandEUR || 0))}
          <br>${kv("Congestion penalty EUR", formatCurrency(ssum.congestionPenaltyEUR || 0))}
        </div>
        ${prodSource ? `<div class="hint" style="margin-top:10px;">Source: ${escapeHtml(prodSource)}</div>` : ""}
      </div>
      ${reportPanelHtml}
      ${renderInvestmentPanel()}
    `)
  : "";
  const debugDrawerHtml = ui_debugDrawerHtml();
  const currentCountrySpec = (typeof getCountrySpec === "function")
    ? getCountrySpec(state.countryId || "ES")
    : null;
  const currentCountryName = currentCountrySpec?.name || "Spain";
  const clusterBadgeHtml = activeCluster
    ? '<span class="badge">In: ' + (activeCluster.hubName || '') + '</span>'
    : '<span class="badge">' + currentCountryName + '</span>';

  const activePrimaryLabel = state.primaryTab === "production" ? "Industry" : "Population";
  const activeSubLabel = tabNames[state.activeTab] || "Network";
  const windowControlLabel = state.panelMinimized ? "Restore panel" : "Minimize panel";
  const windowControlAction = state.panelMinimized ? "togglePanelMinimized(false)" : "togglePanelMinimized(true)";
  const windowControlsHtml = `
    <div class="window-controls">
      <button class="window-control" title="${windowControlLabel}" onclick="${windowControlAction}">‚ñÅ</button>
    </div>
  `;
  const panelHeaderHtml = `
    <div class="section panel-header">
      <div>
        <h3 class="title">Railway Network Simulator</h3>
        <p class="sub">
Year: <b>${state.year}</b> ? Budget: <b>${formatCurrency(state.budget)}</b> ? Op/day: <b>${formatCurrency(opDay)}</b>
${clusterBadgeHtml}
${scenTitle}
</p>
      </div>
      <div class="panel-header-actions">
        ${windowControlsHtml}
      </div>
    </div>
  `;
  const panelHtml = [
    panelHeaderHtml,
    scenarioPanelHtml,
    validatorWarningHtml,
    networkTabHtml,
    transportTabHtml,
    economyTabHtml,
    dynamicsTabHtml,
    debugDrawerHtml
  ].join("");
  const panelMinimizedContent = `
    <div class="panel-minimized">
      <div>
        <div style="font-weight:1000;color:#0f172a;">${activePrimaryLabel} ‚Ä¢ ${activeSubLabel} minimized</div>
        <div class="panel-minimized-row">
          <span>Budget: ${formatCurrency(state.budget)}</span>
          <span>Profit: ${formatCurrency(state.profit)}</span>
        </div>
        <div class="panel-minimized-stats">
          <div>${kv("Nodes", fmtNum(nodesCount))}</div>
          <div>${kv("Lines", fmtNum(linesCount))}</div>
          <div>${kv("Tracks", fmtNum(tracksCount))}</div>
          <div>${kv("Trains/day", fmtNum(Math.round(totalTrainsPerDay)))}</div>
        </div>
      </div>
      <button class="btn secondary" style="width:auto;padding:8px 12px;margin-top:0;" onclick="togglePanelMinimized(false)">Expand panel</button>
    </div>
    <div class="panel-minimized-row">
      <span>Seed: ${seedVal}</span>
    </div>
    <div class="panel-minimized-row" style="font-size:11px;">
      <span>Versions: dataset ${datasetVersion} ¬∑ model ${modelVersion} ¬∑ schema ${schemaVersion}</span>
    </div>
    ${validatorWarningHtml}
    ${debugDrawerHtml}
  `;

  if (state.panelMinimized) {
    panel.classList.add("minimized");
    panel.innerHTML = panelMinimizedContent;
  } else {
    panel.classList.remove("minimized");
    panel.innerHTML = panelHtml;
  }
  try { renderBottomTabBar(); } catch { /* ignore */ }

  // Post-render fixes: prevent Chrome autofill warnings and keep small widgets in sync
  try { ui_fixFieldNames(); } catch { /* ignore */ }
  try { ui_updateActiveTrainsCount(); } catch { /* ignore */ }
  try { ui_renderLineDiagram(); } catch { /* ignore */ }
  try { uiMode_render(); } catch { /* ignore */ }
  try { ui_renderLineLegend(); } catch { /* ignore */ }
  try { if (typeof service_refreshRunVisibility === "function") service_refreshRunVisibility(); } catch { /* ignore */ }
  try { if (state.activeTab === "dynamics") ui_renderLutiReport(); } catch { /* ignore */ }
  try { ui_renderErrorBanner(); } catch { /* ignore */ }
  try { render_network(); } catch { /* ignore */ }
  try { render_overlay(); } catch { /* ignore */ }
  try { ui_updateScenarioCacheStatus(); } catch { /* ignore */ }
}

function ensureBottomTabBarElement(){
  let el = document.getElementById(bottomTabBarId);
  if (!el){
    el = document.createElement("div");
    el.id = bottomTabBarId;
    document.body.appendChild(el);
  }
  return el;
}

function bottomTabBarContent(){
  const primaryRow = primaryTabs.map(tab => {
    const isActive = state.primaryTab === tab.id;
    const bg = isActive ? "linear-gradient(135deg,#0ea5e9,#38bdf8)" : "rgba(255,255,255,0.08)";
    const border = isActive ? "rgba(255,255,255,0.6)" : "rgba(255,255,255,0.25)";
    const color = isActive ? "#fff" : "#e2e8f0";
    return `
      <button type="button" onclick="ui_selectPrimaryNav('${tab.id}')" style="display:flex;align-items:center;gap:6px;padding:8px 12px;border-radius:999px;border:1px solid ${border};background:${bg};color:${color};font-weight:900;font-size:12px;box-shadow:0 8px 20px rgba(15,23,42,0.25);">
        <span style="font-size:16px;">${tab.icon}</span>
        <span>${tab.label}</span>
      </button>
    `;
  }).join("");
  const subRow = subTabOrder.map(name => {
    const isActive = state.activeTab === name;
    const bg = isActive ? "rgba(15,23,42,0.8)" : "rgba(255,255,255,0.06)";
    const border = isActive ? "rgba(59,130,246,0.7)" : "rgba(255,255,255,0.2)";
    const color = isActive ? "#f8fafc" : "#cbd5f5";
    const icon = subTabIcons[name] || "‚Ä¢";
    return `
      <button type="button" onclick="ui_selectSubNav('${name}')" style="display:flex;align-items:center;gap:6px;padding:6px 10px;border-radius:14px;border:1px solid ${border};background:${bg};color:${color};font-size:11px;font-weight:700;">
        <span style="font-size:14px;">${icon}</span>
        <span>${tabNames[name] || name}</span>
      </button>
    `;
  }).join("");
  const showSubNav = !!(state.panelVisible && state.primaryTab);
  const subRowWrapper = showSubNav ? `
    <div style="display:flex;gap:6px;justify-content:center;flex-wrap:wrap;background:rgba(15,23,42,0.95);border-radius:18px;border:1px solid rgba(255,255,255,0.3);padding:8px 12px;box-shadow:0 -12px 24px rgba(15,23,42,0.45);">
      ${subRow}
    </div>
  ` : "";
  return `
    ${subRowWrapper}
    <div style="display:flex;gap:6px;justify-content:center;flex-wrap:wrap;">
      ${primaryRow}
    </div>
  `;
}

function renderBottomTabBar(){
  const el = ensureBottomTabBarElement();
  el.style.position = "fixed";
  el.style.bottom = "14px";
  el.style.left = "50%";
  el.style.transform = "translateX(-50%)";
  el.style.maxWidth = "760px";
  el.style.width = "calc(100% - 28px)";
  el.style.display = "flex";
  el.style.flexDirection = "column";
  el.style.gap = "6px";
  el.style.padding = "9px 12px";
  el.style.borderRadius = "18px";
  el.style.background = "linear-gradient(135deg,rgba(15,23,42,0.95),rgba(14,165,233,0.8))";
  el.style.boxShadow = "0 18px 40px rgba(15,23,42,0.45)";
  el.style.zIndex = "1200";
  el.style.pointerEvents = "auto";
  el.innerHTML = bottomTabBarContent();
}

window.updateUI = updateUI;

function ensureDefaultTestLine(){
// If there are already lines (or a save was loaded), do nothing.
if (state.lines.size > 0) return;

// Use clusters (works zoomed out) ‚Äì pick a few big ones
const clusters = Array.from(state.clusters.values())
  .slice()
  .sort((a,b) => (Number(b.population||0) - Number(a.population||0)))
  .slice(0, 6);

if (clusters.length < 2) return;

// Order them west->east to make a nicer looking first line
clusters.sort((a,b) => (Number(a.lon||0) - Number(b.lon||0)));

const id = addLine("Test Line", "passenger", false, {
  frequencyPerDay: 6,
  vehicleCapacity: 220,
  speedKmh: 180
});

const line = state.lines.get(id);
if (!line) return;

line.stops = clusters.slice(0, 4).map(c => String(c.id));

// Build initial test tracks instantly so the test line is ready
if (typeof autoLanesForLineType === "function" && typeof addTrack === "function") {
  const lanes = autoLanesForLineType(line.type);
  for (let i = 0; i < line.stops.length - 1; i++) {
    const a = line.stops[i];
    const b = line.stops[i + 1];
    addTrack(a, b, lanes, { silent: true, status: "built" });
  }
}

state.activeLine = id;
renderLines();
updateUI();
ui_renderLineLegend();
uiMode_render();
uihotkeys_install();

}

let hoverTip = null;

function hoverTipEnsure(){
if (hoverTip) return hoverTip;
hoverTip = L.tooltip({
  permanent: false,
  direction: "top",
  opacity: 0.95,
  offset: [0, -10],
  className: "node-hover-tip"
});
return hoverTip;
}

function getNodeLineCount(nodeId){
let c = 0;
for (const l of state.lines.values()){
  if (Array.isArray(l.stops) && l.stops.includes(nodeId)) c++;
}
return c;
}

function getNodeTrackStats(nodeId){
let edges = 0;
let lanes = 0;
for (const t of state.tracks.values()){
  if (t.from === nodeId || t.to === nodeId) {
    edges++;
    lanes += Math.max(0, Number(t.lanes || 0));
  }
}
return { edges, lanes };
}

function showNodeHover(nodeId, lat, lon){
const n = state.nodes.get(nodeId);
if (!n || !map) return;

  const pop = Math.max(0, Number(n.population || 0));
  const isProductionTab = state.primaryTab === "production";
  const lc = isProductionTab ? 0 : getNodeLineCount(nodeId);
  const ts = getNodeTrackStats(nodeId);
  
  let html = `<div style="font-weight:1000;color:#0f172a;">${n.name || nodeId}</div>`;
  
  if (isProductionTab) {
    const prodNode = typeof production_getNode === "function"
      ? production_getNode(nodeId)
      : null;
    if (prodNode && Array.isArray(PROD_ITEMS)) {
      const units = state.production?.macro?.units || "";
      const maxProd = Math.max(1, ...PROD_ITEMS.map(it => Number(prodNode.prod?.[it.id] || 0)));
      const split = (typeof production_modalSplit === "function")
        ? production_modalSplit(nodeId)
        : { railShare: prodNode.railShare || 0, otherShare: prodNode.otherShare || 1 };
      const railPct = Math.round((split.railShare || 0) * 100);
      const otherPct = Math.round((split.otherShare || 0) * 100);
      html += `
      <div style="margin-top:6px;font-weight:900;color:#334155;font-size:12px;line-height:1.4;">
        Industries: ${fmtNum(prodNode.industries || 0)}<br/>
        Output: ${formatCurrency(prodNode.prodSum || 0)}${units ? " " + units : ""}<br/>
        Needs: ${formatCurrency(prodNode.needSum || 0)}${units ? " " + units : ""}<br/>
        Rail share: ${railPct}% (other ${otherPct}%)
      </div>
      ${(() => {
        const topSubs = (typeof production_topSubitems === "function") ? production_topSubitems(nodeId, 4) : [];
        if (!topSubs.length) return "";
        return `
        <div style="margin-top:8px;">
          <div style="font-weight:1000;color:#0f172a;margin-bottom:4px;">Top outputs</div>
          ${topSubs.map(s => `
            <div style="display:flex;align-items:center;gap:6px;margin-top:4px;">
              <div style="width:14px;height:14px;border-radius:3px;background:${s.color};display:flex;align-items:center;justify-content:center;">${production_iconHtml(s, 12)}</div>
              <div style="font-size:11px;font-weight:900;color:#334155;">${escapeHtml(s.name)}</div>
              <div style="font-size:11px;font-weight:900;color:#64748b;">${formatCurrency(s.val)}${units ? " " + units : ""}</div>
            </div>
          `).join("")}
        </div>
        `;
      })()}
      <div style="margin-top:8px;">
        ${PROD_ITEMS.map(it => {
          const val = Number(prodNode.prod?.[it.id] || 0);
          const pct = Math.max(2, Math.round((val / maxProd) * 100));
          const details = Array.isArray(it.details) ? it.details.join(", ") : "";
          return `
            <div style="display:flex;align-items:center;gap:6px;margin-top:6px;">
              <div style="width:16px;height:16px;border-radius:3px;background:${it.color};display:flex;align-items:center;justify-content:center;">${production_iconHtml(it, 14)}</div>
              <div style="min-width:0;flex:1;">
                <div style="font-size:11px;font-weight:900;color:#334155;">${it.name}</div>
                ${details ? `<div style="font-size:10px;font-weight:900;color:#64748b;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${escapeHtml(details)}</div>` : ""}
                <div style="margin-top:3px;height:6px;background:rgba(15,23,42,0.08);border-radius:999px;overflow:hidden;">
                  <div style="width:${pct}%;height:100%;background:${it.color};"></div>
                </div>
              </div>
              <div style="font-size:11px;font-weight:900;color:#334155;">${formatCurrency(val)}</div>
            </div>
          `;
        }).join("")}
      </div>
      `;
    } else {
      html += `<div style="margin-top:6px;font-weight:900;color:#64748b;font-size:12px;">No industry data.</div>`;
    }
  } else {
    html += `
      <div style="font-weight:900;color:#334155;font-size:12px;line-height:1.4;">
        Pop: ${fmtNum(pop)}<br/>
        Tracks: ${fmtNum(ts.edges)} (lanes ${fmtNum(ts.lanes)})<br/>
        Lines: ${fmtNum(lc)}
      </div>
    `;
  }

const tip = hoverTipEnsure();
tip.setLatLng([lat, lon]);
tip.addTo(map);

if (!isProductionTab) {
const acc = (state.luti && state.luti.accessJobs && state.luti.accessJobs.get(nodeId)) || 0;
const tops = luti_topContributors(nodeId, 5);

html += `
<div style="margin-top:8px;padding-top:8px;border-top:1px solid rgba(15,23,42,0.08);">
  <div style="font-weight:1000;color:#0f172a;">Accessibility</div>
  <div style="font-weight:900;color:#334155;font-size:12px;line-height:1.4;">
    Jobs access (proxy): <b>${fmtNum(acc)}</b><br/>
    Œ≤: ${(state.luti && state.luti.beta) || 0.045}
  </div>
  <div style="margin-top:6px;font-size:12px;color:#64748b;font-weight:900;">
    Top contributors:
        ${tops.map(t => (
      '<div>? ' + escapeHtml(t.name) + ' ? ' + fmtNum(t.jobsProxy) + ' / ' + Math.round(t.t) + 'm</div>'
    )).join("")}
  </div>
</div>
`;
}

tip.setContent(html);
}

function hideNodeHover(){
if (!hoverTip || !map) return;
try { map.removeLayer(hoverTip); } catch { /* ignore */ }
}
