<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Railway Network Simulator (Cities + Clusters)</title>

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; overflow: hidden; }
    #map { height: 100%; width: 100%; }

    .panel{
      position:absolute; top:16px; right:16px; z-index:1000;
      background:rgba(255,255,255,0.96); backdrop-filter: blur(16px);
      padding:14px; border-radius:14px; box-shadow:0 8px 24px rgba(0,0,0,0.22);
      width:420px; max-height:86vh; overflow:auto; border:1px solid rgba(0,0,0,0.06);
    }
    .tabs{ display:flex; gap:6px; background:#f1f5f9; padding:6px; border-radius:12px; margin-bottom:12px; }
    .tab{ flex:1; text-align:center; padding:10px 8px; border-radius:10px; font-weight:900; cursor:pointer; user-select:none; color:#64748b; }
    .tab.active{ background:white; color:#2b6cff; box-shadow:0 2px 8px rgba(0,0,0,0.08); }

    .section{ padding-bottom:12px; margin-bottom:12px; border-bottom:1px solid #e2e8f0; }
    .section:last-child{ border-bottom:none; margin-bottom:0; padding-bottom:0; }
    .title{ font-weight:1000; color:#0f172a; margin:0 0 4px 0; }
    .sub{ color:#64748b; font-weight:800; font-size:12px; margin:0 0 10px 0; }
/* Busy station ring pulse */
.station-busy {
  animation: stationPulse 2.6s ease-in-out infinite;
  transform-origin: center;
}

@keyframes stationPulse {
  0% {
    stroke-opacity: calc(0.15 * var(--pulse-strength, 1));
    stroke-width: 1.5;
  }
  50% {
    stroke-opacity: calc(0.9 * var(--pulse-strength, 1));
    stroke-width: 4;
  }
  100% {
    stroke-opacity: calc(0.15 * var(--pulse-strength, 1));
    stroke-width: 1.5;
  }
}



    .btn{
      width:100%; padding:12px; border:0; border-radius:10px; cursor:pointer; font-weight:1000;
      background:linear-gradient(135deg,#2b6cff,#1a56db); color:white; user-select:none;
      margin-top:8px;
    }
    .btn.secondary{ background:#f1f5f9; color:#0f172a; }
    .btn.success{ background:linear-gradient(135deg,#10b981,#059669); }
    .btn.warning{ background:linear-gradient(135deg,#f59e0b,#d97706); }
    .btn.danger{ background:linear-gradient(135deg,#ef4444,#b91c1c); }
    .row{ display:flex; gap:8px; }
    .row .btn{ margin-top:0; }

    .field{ width:100%; padding:10px 12px; border:2px solid #e2e8f0; border-radius:10px; font-weight:900; }
    .field:focus{ outline:none; border-color:#2b6cff; box-shadow:0 0 0 3px rgba(43,108,255,0.08); }

    .hint{
      background:#f8fafc; border:1px solid #e2e8f0; border-radius:10px;
      padding:10px 12px; color:#334155; font-weight:850; font-size:12px;
    }

    .toast{
      position:fixed; right:18px; bottom:18px; z-index:99999;
      background:#0f172a; color:white; padding:12px 14px; border-radius:12px;
      box-shadow:0 6px 20px rgba(0,0,0,0.25); font-weight:950; display:none;
    }

    .k{ color:#64748b; font-weight:900; }
    .v{ color:#0f172a; font-weight:1000; }

    .list{ border:1px solid #e2e8f0; border-radius:12px; overflow:hidden; background:white; max-height:240px; overflow:auto; }
    .item{ padding:10px 12px; border-bottom:1px solid #f1f5f9; cursor:pointer; user-select:none; }
    .item:last-child{ border-bottom:none; }
    .item:hover{ background:#f8fafc; }
    .item.active{ background:#e0f2fe; border-left:4px solid #2b6cff; }

    .badge{
      display:inline-block; padding:2px 8px; border-radius:999px; font-weight:1000; font-size:11px;
      background:#e2e8f0; color:#0f172a; margin-left:8px;
    }

    /* Bottom-left cluster exit */
    #clusterBar{
      position:absolute; left:16px; bottom:16px; z-index:1200;
      background:rgba(255,255,255,0.96); backdrop-filter: blur(16px);
      padding:10px 12px; border-radius:14px;
      box-shadow:0 8px 24px rgba(0,0,0,0.22);
      border:1px solid rgba(0,0,0,0.06);
      display:none;
      width:320px;
    }
    #clusterBar .rowTop{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    #clusterBar .name{ font-weight:1000; color:#0f172a; font-size:13px; }
    #clusterBar .btnTiny{
      border:0; border-radius:10px; padding:8px 10px; cursor:pointer; font-weight:1000;
      background:#f1f5f9; color:#0f172a;
    }

    /* Cluster dots (same size always) */
    .cluster-dot {
      width: 14px;
      height: 14px;
      border-radius: 999px;
      background: rgba(0,0,0,0.9);
      box-shadow: 0 8px 18px rgba(0,0,0,0.18);
      border: 2px solid rgba(255,255,255,0.85);
    }
    .cluster-dot.active {
      outline: 4px solid rgba(16,185,129,0.35);
      border-color: rgba(255,255,255,1);
    }

    /* Track lane label at midpoint */
    .lane-label{
      background: rgba(0,0,0,0.85);
      color: white;
      border-radius: 10px;
      padding: 2px 6px;
      font-weight: 1000;
      font-size: 12px;
      line-height: 1;
      border: 1px solid rgba(255,255,255,0.25);
      box-shadow: 0 8px 18px rgba(0,0,0,0.20);
      pointer-events: none;
    }

/* === Track lane count label === */
.track-lane-label{
  color:#fff;
  font-weight:1000;
  font-size:14px;
  line-height:1;
  white-space:nowrap;
  pointer-events:none;

  /* “halo” outline so white text is readable on any map */
  text-shadow:
    -1px -1px 0 rgba(0,0,0,0.85),
     1px -1px 0 rgba(0,0,0,0.85),
    -1px  1px 0 rgba(0,0,0,0.85),
     1px  1px 0 rgba(0,0,0,0.85),
     0px  2px 6px rgba(0,0,0,0.70);
}

/* Mode bar (top-left) */
#modeBar{
  position:absolute;
  left:16px;
  top:16px;
  z-index:1300;
  background:rgba(15,23,42,0.88);
  color:#fff;
  padding:10px 12px;
  border-radius:14px;
  box-shadow:0 8px 24px rgba(0,0,0,0.22);
  border:1px solid rgba(255,255,255,0.14);
  min-width:240px;
}
#modeBar .row{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}
#modeBar .mode{
  font-weight:1000;
  letter-spacing:0.3px;
}
#modeBar .pill{
  display:inline-block;
  padding:2px 8px;
  border-radius:999px;
  font-size:11px;
  font-weight:1000;
  background:rgba(255,255,255,0.14);
}
#modeBar .detail{
  margin-top:2px;
  font-size:12px;
  font-weight:900;
  color:rgba(255,255,255,0.78);
}
#modeBar .keys{
  margin-top:8px;
  font-size:11px;
  font-weight:900;
  color:rgba(255,255,255,0.62);
}


  </style>
</head>

<body>
  <div id="map"></div>
  <div id="controlPanel" class="panel"></div>
  <div id="clusterBar"></div>
  <div id="modeBar"></div>
  <div id="toast" class="toast"></div>

<script type="module">
  import { computeEconomy } from "./economy.js";
import { computeFlows } from "./dynamics.js";


  // ======================
  // Config
  // ======================
  const CONFIG = {
    CLUSTER_RADIUS_KM: 30,
    CLUSTER_VIEW_MAX_ZOOM: 7,
    SPAIN_VIEW: { center: [40.0, -3.7], zoom: 6 },

    // Infra
    TRACK_COST_PER_KM: 5_000_000,
    TRACK_MAINTENANCE_PER_KM: 250_000,

    STARTING_BUDGET: 15_000_000_000_000,
    ANNUAL_BUDGET: 1_000_000_000,

    // production proxy (until real stats)
    PROD_EUR_PER_PERSON_MIN: 900,
    PROD_EUR_PER_PERSON_MAX: 2200,

    // auto-track settings
    AUTO_TRACK_LANES_PASSENGER: 2,
    AUTO_TRACK_LANES_CARGO: 3,
    AUTO_TRACK_LANES_MIXED: 2,
  };

  // ======================
  // Helpers
  // ======================
function getStation(nodeId){
  const id = String(nodeId);
  if (!state.stations.has(id)) {
    state.stations.set(id, { level: 0, platforms: 1, amenities: 0, retail: 0 });
  }
  return state.stations.get(id);
}

function retailUpgradeCost(st){
  // escalating cost: 20M, 33M, 54M, ...
  return Math.round(20_000_000 * Math.pow(1.65, Number(st.retail || 0)));
}

function upgradeRetailOnSelected(){
  const n = state.selectedNode;
  if (!n) { showToast("Select a station first", "warning"); return; }

  const st = getStation(n.id);
  const cost = retailUpgradeCost(st);

  if (state.budget < cost) {
    showToast("Not enough budget", "warning");
    return;
  }

  state.budget -= cost;
  st.retail = (Number(st.retail || 0) + 1);

  showToast(`Retail upgraded at ${n.name} (level ${st.retail})`, "success");
  updateUI();
}

function computeRetailRentEURPerYear(){
  // Simple, readable model:
  // rent = baseRent * retailLevel * (1 + localPopFactor)
  // Uses node population if present.
  let rent = 0;

  for (const [id, st] of state.stations.entries()){
    const lvl = Math.max(0, Number(st?.retail || 0));
    if (lvl <= 0) continue;

    const n = state.nodes.get(String(id));
    const pop = Math.max(0, Number(n?.population || 0));

    // pop factor: 0..~2.0 for big cities/clusters
    const popFactor = Math.min(2.0, Math.log10(1 + pop) / 5);

    const baseRent = 8_000_000; // €8M per retail level per year (tweak later)
    rent += baseRent * lvl * (1 + popFactor);
  }

  return Math.round(rent);
}

function stationUpgradeCost(kind, st){
  // Simple escalating costs (tweak later)
  const base =
    kind === "platforms" ? 25_000_000 :
    kind === "amenities" ? 15_000_000 :
    kind === "retail" ? 18_000_000 : 20_000_000;

  const lvl =
    kind === "platforms" ? (st.platforms - 1) :
    kind === "amenities" ? st.amenities :
    kind === "retail" ? st.retail : st.level;

  return Math.round(base * (1 + lvl * 0.65));
}

function upgradeStation(kind){
  const n = state.selectedNode;
  if (!n) return;

  const st = getStation(n.id);
  const cost = stationUpgradeCost(kind, st);
  if (state.budget < cost) {
    showToast("Not enough budget for this upgrade", "warning");
    return;
  }

  state.budget -= cost;

  if (kind === "platforms") st.platforms += 1;
  else if (kind === "amenities") st.amenities += 1;
  else if (kind === "retail") st.retail += 1;

  st.level = Math.max(st.level, st.platforms - 1, st.amenities, st.retail);

  updateUI();
  showToast(`Upgraded ${kind} at ${n.name}`, "success");

  // refresh rings (busyness can later incorporate station capacity)
  try {
    if (map.getZoom() <= CONFIG.CLUSTER_VIEW_MAX_ZOOM) renderStationBusyness(Array.from(state.clusters.keys()));
  } catch(_) {}
}

  function fmtNum(x){
    if (x === null || x === undefined || Number.isNaN(Number(x))) return "—";
    return Number(x).toLocaleString();
  }
  function formatCurrency(amount){
    if (amount === null || amount === undefined || Number.isNaN(Number(amount))) return "—";
    const a = Number(amount);
    if (a >= 1e12) return '€' + (a/1e12).toFixed(2) + 'T';
    if (a >= 1e9)  return '€' + (a/1e9).toFixed(2) + 'B';
    if (a >= 1e6)  return '€' + (a/1e6).toFixed(2) + 'M';
    if (a >= 1e3)  return '€' + (a/1e3).toFixed(0) + 'K';
    return '€' + a.toFixed(0);
  }
  function showToast(msg, type="info"){
    const t = document.getElementById("toast");
    t.textContent = msg;
    t.style.display = "block";
    t.style.background =
      type==="error" ? "#ef4444" :
      type==="success" ? "#10b981" :
      type==="warning" ? "#f59e0b" : "#0f172a";
    setTimeout(()=> t.style.display="none", 2200);
  }
  async function loadJSON(url){
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`Failed to load ${url} (${res.status})`);
    return await res.json();
  }
  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

  // deterministic hash -> 0..1
  function hash01(str){
    let h = 2166136261;
    for (let i=0;i<str.length;i++){
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return ((h >>> 0) % 1000000) / 1000000;
  }

  function edgeKey(a,b){
    a=String(a); b=String(b);
    return a<b ? `${a}—${b}` : `${b}—${a}`;
  }

  // ======================
  // State
  // ======================
  const state = {
    nodes: new Map(),   // id -> {id,name,lat,lon,kind,population,production,clusterId?}
    cities: [],
    clusters: new Map(),// clusterId -> {id, hubCityId, hubName, lat, lon, population, cityIds:Set, bounds, totalProduction, biggestProduction}
    stations: new Map(), // nodeId -> { level, platforms, amenities, retail }
    tracks: new Map(),  // trackId -> {id, from, to, lanes, cost, _layer, _label}
    stationPressure: new Map(), // nodeId -> { demand, supply, pressurePct }
    lines: new Map(),   // lineId -> {id,name,type,color,stops:[],circular, frequencyPerDay, vehicleCapacity, speedKmh}

    year: 2024,
    budget: CONFIG.STARTING_BUDGET,
    annualBudget: CONFIG.ANNUAL_BUDGET,
    revenue: 0,
    costs: 0,
    profit: 0,
    // Undo (last actions)
    undo: { stack: [], max: 60 },


  // ===== Dynamics (filled by economy.js later) =====
  dynamics: {
    enabled: true,
    showOverlay: true,
    mode: "both", // "goods" | "passengers" | "both"
  },

  // Summary numbers to display (economy.js should update these)
  flowSummary: {
    goodsDelivered: 0,
    goodsUnmet: 0,
    passengerTrips: 0,
    passengerUnmet: 0,
    demandMetPct: 0,          // 0..100
    topExportName: "—",
    topExportValue: 0,
    topNeedName: "—",
    topNeedValue: 0,
    topBottleneck: "—",
    topBottleneckValue: 0,
  },

    activeTab: "network",
    activeLine: null,

    // modes
    trackBuildMode: false,
    pendingTrackNode: null,
    pendingTrackLanes: 1,

    // clustering UX
    activeClusterId: null,
    selectedNode: null,

    // line building toggle
    lineBuildMode: true,
  };

  // ======================
  // Map + Layers
  // ======================
  let map;
const layers = {
  clusters: L.layerGroup(),
  cities: L.layerGroup(),
  tracks: L.layerGroup(),
  stationOverlay: L.layerGroup(), // NEW: busy station rings
  trackLabels: L.layerGroup(),
  lines: L.layerGroup(),
trains: L.layerGroup(),
  flowOverlay: L.layerGroup(), // <-- NEW: animated trains live here
};

  function initMap(){
    map = L.map("map").setView(CONFIG.SPAIN_VIEW.center, CONFIG.SPAIN_VIEW.zoom);
map.createPane("stationPane");
map.getPane("stationPane").style.zIndex = 650; // above markers, below UI
map.on("zoomend", () => {
  if (state.activeTab === "network") {
    if (state.viewMode === "clusters") {
      renderStationBusyness(Array.from(state.clusters.keys()));
    } else {
      renderStationBusyness(Array.from(state.visibleCityIds || []));
    }
  }
});


    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: "© OpenStreetMap contributors"
    }).addTo(map);

    layers.clusters.addTo(map);
    layers.cities.addTo(map);
    layers.tracks.addTo(map);
    layers.stationOverlay.addTo(map); // NEW
    layers.trackLabels.addTo(map);
    layers.lines.addTo(map);
layers.trains.addTo(map);
layers.flowOverlay.addTo(map);


    map.on("zoomend moveend", () => {
      syncMarkerVisibility();
      if (state.activeClusterId && map.getZoom() <= CONFIG.CLUSTER_VIEW_MAX_ZOOM) {
        leaveCluster(true);
      }
    });
  }

  // ======================
  // Production proxy
  // ======================
  function estimateCityProductionEUR(city){
    const pop = Number(city.population || 0);
    const t = hash01(String(city.id || city.name || "x"));
    const perPerson = CONFIG.PROD_EUR_PER_PERSON_MIN +
      (CONFIG.PROD_EUR_PER_PERSON_MAX - CONFIG.PROD_EUR_PER_PERSON_MIN) * t;
    return Math.round(pop * perPerson);
  }

  // ======================
  // Clustering (greedy by population)
  // ======================
  function buildClusters(cities){
    state.clusters.clear();

    const usable = cities
      .filter(c => Number(c?.lat) && Number(c?.lon) && Number(c?.population) >= 5000)
      .map(c => ({
        id: String(c.id),
        name: c.name,
        lat: Number(c.lat),
        lon: Number(c.lon),
        population: Number(c.population) || 0
      }));

    usable.sort((a,b) => (b.population||0) - (a.population||0));

    const assigned = new Set();
    const radiusM = CONFIG.CLUSTER_RADIUS_KM * 1000;

    const cityProd = new Map();
    for (const c of usable) cityProd.set(c.id, estimateCityProductionEUR(c));

    for (const hub of usable) {
      if (assigned.has(hub.id)) continue;

      const clusterId = `CL-${hub.id}`;
      const cityIds = new Set([hub.id]);
      assigned.add(hub.id);

      const bounds = L.latLngBounds([[hub.lat, hub.lon],[hub.lat, hub.lon]]);
      let popSum = hub.population || 0;

      let totalProduction = cityProd.get(hub.id) || 0;
      let biggestProduction = cityProd.get(hub.id) || 0;

      for (const c of usable) {
        if (assigned.has(c.id)) continue;
        const d = map.distance([hub.lat, hub.lon], [c.lat, c.lon]);
        if (d <= radiusM) {
          assigned.add(c.id);
          cityIds.add(c.id);
          popSum += c.population || 0;
          bounds.extend([c.lat, c.lon]);

          const p = cityProd.get(c.id) || 0;
          totalProduction += p;
          if (p > biggestProduction) biggestProduction = p;
        }
      }

      state.clusters.set(clusterId, {
        id: clusterId,
        hubCityId: hub.id,
        hubName: hub.name,
        lat: hub.lat,
        lon: hub.lon,
        population: popSum,
        cityIds,
        bounds,
        totalProduction,
        biggestProduction
      });
    }

    // Build nodes (clusters + cities)
    state.nodes.clear();

    for (const cl of state.clusters.values()) {
      state.nodes.set(cl.id, {
        id: cl.id,
        name: cl.hubName,
        lat: cl.lat,
        lon: cl.lon,
        kind: "cluster",
        population: cl.population,
        production: cl.totalProduction,
        biggestProduction: cl.biggestProduction,
        hubCityId: cl.hubCityId
      });
    }

    for (const c of usable) {
      let clusterId = null;
      for (const cl of state.clusters.values()) {
        if (cl.cityIds.has(c.id)) { clusterId = cl.id; break; }
      }

      state.nodes.set(c.id, {
        id: c.id,
        name: c.name,
        lat: c.lat,
        lon: c.lon,
        kind: "city",
        population: c.population,
        production: cityProd.get(c.id) || 0,
        clusterId
      });
    }
  }

  // ======================
  // Rendering: clusters + cities
  // ======================
  function makeClusterDotIcon(cluster) {
    const active = state.selectedNode?.id === cluster.id;
    return L.divIcon({
      className: "",
      iconSize: [14, 14],
      iconAnchor: [7, 7],
      html: `<div class="cluster-dot ${active ? "active" : ""}"></div>`
    });
  }

// ======================
// Station busyness overlay (service-based, visual-only)
// ======================

function computeStationIntensity(){
  // intensity per nodeId based on services that stop there
  const m = new Map();

  for (const line of state.lines.values()){
    if (!line || !Array.isArray(line.stops) || line.stops.length < 1) continue;

    const freq = Math.max(0, Number(line.frequencyPerDay || 0));
    const cap = Math.max(0, Number(line.vehicleCapacity || 0));

    // Type weight: passengers feel “busy”, cargo less visually busy
    const typeW =
      line.type === "passenger" ? 1.0 :
      line.type === "mixed" ? 0.75 :
      line.type === "cargo" ? 0.45 : 0.8;

    const score = freq * cap * typeW; // “people-throughput-like”

    for (const id of line.stops){
      const key = String(id);
      m.set(key, (m.get(key) || 0) + score);
    }
  }

  return m;
}

function stationPressureColor01(p01){
  // p01 is 0..1 (0 = calm/green, 1 = overloaded/red)
  const t = clamp(Number(p01) || 0, 0, 1);
  const hue = 120 *  t; // 120=green -> 0=red
  return `hsl(${hue}, 85%, 45%)`;
}

function renderStationBusyness(nodeIds){
  layers.stationOverlay.clearLayers();

  const intensity = computeStationIntensity();
  if (!intensity || intensity.size === 0) return;

  // Find max in this view so scaling feels good locally
  let max = 0;
  for (const id of nodeIds){
    const v = intensity.get(String(id)) || 0;
    if (v > max) max = v;
  }
  if (max <= 0) return;

  for (const id of nodeIds){
    const n = state.nodes.get(String(id));
    if (!n) continue;

    const v = intensity.get(String(id)) || 0;
    if (v <= 0) continue;

    // Normalize (log scale so big hubs don’t dominate too hard)
    const t = Math.log10(1 + v) / Math.log10(1 + max); // 0..1

    // Ring radius: bigger for busier stations
    const r = 8 + t * 18;

    // --- Pressure model (safe + simple) ---
    // capacity grows with platforms; amenities reduce effective pressure
    const st = getStation(String(id));
    const platforms = Math.max(1, Number(st?.platforms || 1));
    const amenities = Math.max(0, Number(st?.amenities || 0));

    const capacity = platforms * 5000 * (1 + amenities * 0.35);
    const rawPressure = capacity > 0 ? (v / capacity) : 0;

    // Convert to 0..1 where 1 means "overloaded"
    const p01 = clamp(rawPressure, 0, 1);

    // Color by pressure (green -> red)
    const col = stationPressureColor01(p01);

    const marker = L.circleMarker([n.lat, n.lon], {
      radius: r,
      pane: "stationPane",
      color: col,
      weight: 1.5,
      opacity: 0.35 + t * 0.65,
      fillColor: col,
      fillOpacity: 0.08 + p01 * 0.08,
      interactive: false,
      className: "station-busy"
    }).addTo(layers.stationOverlay);

    marker.bringToFront();

    const el = marker.getElement();
    if (el) {
      // pulse strength: slightly stronger if pressure is higher
      const pulse = clamp(0.35 + t * 0.45 + p01 * 0.35, 0.15, 1.25);
      el.style.setProperty("--pulse-strength", pulse.toFixed(2));
    }
  }
}





  function renderClusterMarkers(){
    layers.clusters.clearLayers();

    for (const cl of state.clusters.values()) {
      const marker = L.marker([cl.lat, cl.lon], {
        icon: makeClusterDotIcon(cl),
        keyboard: false
      });

      marker.bindTooltip(
        `<strong>${cl.hubName}</strong><br>` +
        `Cluster pop: ${fmtNum(cl.population)}<br>` +
        `Cities: ${fmtNum(cl.cityIds.size)}<br>` +
        `Production (proxy): ${formatCurrency(cl.totalProduction)}<br>` +
        `Biggest city prod (proxy): ${formatCurrency(cl.biggestProduction)}`
      );

      // Left click: select node (for lines/tracks)
      marker.on("click", () => selectNode(cl.id));

      // Right click: zoom into cluster
      marker.on("contextmenu", (e) => {
        L.DomEvent.preventDefault(e);
        enterCluster(cl.id);
      });

      marker.addTo(layers.clusters);

    }      renderStationBusyness(Array.from(state.clusters.keys()));

  }

  function renderCityMarkers(cityIds){
    layers.cities.clearLayers();

    for (const id of cityIds) {
      const n = state.nodes.get(id);
      if (!n || n.kind !== "city") continue;

      // Cities stay normal small dots (for realism and performance)
      const pop = n.population || 0;
      const r = Math.max(3, Math.min(9, Math.log10(Math.max(1,pop)) * 2.1));
      const fill =
        pop >= 500000 ? "#ef4444" :
        pop >= 100000 ? "#f59e0b" : "#10b981";

      const m = L.circleMarker([n.lat, n.lon], {
        radius: r,
        color: "#0f172a",
        weight: 1,
        fillColor: fill,
        fillOpacity: 0.78
      });

      m.bindTooltip(
        `<strong>${n.name}</strong><br>` +
        `Pop: ${fmtNum(pop)}<br>` +
        `Production (proxy): ${formatCurrency(n.production || 0)}`
      );

      m.on("click", () => selectNode(n.id));
      m.addTo(layers.cities);
renderStationBusyness(cityIds);
    }
  }

  function syncMarkerVisibility(){
    const z = map.getZoom();

    if (z <= CONFIG.CLUSTER_VIEW_MAX_ZOOM) {
      layers.clusters.addTo(map);
      layers.cities.clearLayers();
      return;
    }

    layers.clusters.removeFrom(map);

    if (state.activeClusterId && state.clusters.has(state.activeClusterId)) {
      const cl = state.clusters.get(state.activeClusterId);
      renderCityMarkers(cl.cityIds);
      return;
    }

    const b = map.getBounds();
    const visible = [];
    for (const n of state.nodes.values()) {
      if (n.kind !== "city") continue;
      if (b.contains([n.lat, n.lon])) visible.push(n.id);
      if (visible.length >= 1800) break;
    }
    renderCityMarkers(visible);
  }

  // ======================
  // Cluster enter/leave UX
  // ======================
  function enterCluster(clusterId){
    const cl = state.clusters.get(clusterId);
    if (!cl) return;

    state.activeClusterId = clusterId;
    map.fitBounds(cl.bounds.pad(0.25), { maxZoom: 11 });

    updateClusterBar();
    syncMarkerVisibility();
    updateUI();
    showToast(`Entered cluster: ${cl.hubName}`, "success");
    renderClusterMarkers();
  }

  function leaveCluster(silent=false){
    state.activeClusterId = null;
    updateClusterBar();

    map.setView(CONFIG.SPAIN_VIEW.center, CONFIG.SPAIN_VIEW.zoom);

    syncMarkerVisibility();
    updateUI();
    if (!silent) showToast("Left cluster view", "info");
    renderClusterMarkers();
  }

  function updateClusterBar(){
    const bar = document.getElementById("clusterBar");
    if (!state.activeClusterId) {
      bar.style.display = "none";
      bar.innerHTML = "";
      return;
    }
    const cl = state.clusters.get(state.activeClusterId);
    if (!cl) { bar.style.display="none"; bar.innerHTML=""; return; }

    bar.style.display = "block";
    bar.innerHTML = `
      <div class="rowTop">
        <div>
          <div class="name">Zoomed in: ${cl.hubName}</div>
          <div style="font-size:12px;color:#64748b;font-weight:900;">
            Cities: ${fmtNum(cl.cityIds.size)} • Pop: ${fmtNum(cl.population)}
          </div>
        </div>
        <button class="btnTiny" id="leaveClusterBtn">Leave</button>
      </div>
      <div style="margin-top:8px;" class="hint">
        <b>Global:</b> connect to the cluster hub. <b>Zoomed:</b> target real cities.
      </div>
    `;
    document.getElementById("leaveClusterBtn").onclick = () => leaveCluster(false);
  }

  // ======================
  // Tracks (black line + white lane number label)
  // ======================
  function calculateTrackCost(a, b, lanes=1){
    const km = (map.distance([a.lat,a.lon],[b.lat,b.lon]) / 1000) || 0;
    const constructionCost = km * CONFIG.TRACK_COST_PER_KM * lanes;
    const maintenanceCost = km * CONFIG.TRACK_MAINTENANCE_PER_KM * lanes;
    return { distanceKm: km, terrainDifficulty: 1.0, constructionCost, maintenanceCost, lanes };
  }

  function addTrack(fromId, toId, lanes=1, {silent=false} = {}){
    const a = state.nodes.get(fromId);
    const b = state.nodes.get(toId);
    if (!a || !b) return null;

    const key = edgeKey(fromId, toId);
    const trackId = `TK-${key}`;

    const prevTrack = state.tracks.has(trackId)
      ? { from: fromId, to: toId, lanes: Number(state.tracks.get(trackId)?.lanes || 1) }
      : null;

    // remove existing visual if overwriting
    if (state.tracks.has(trackId)) {
      const old = state.tracks.get(trackId);
if (old?._label) layers.trackLabels.removeLayer(old._label);
      state.tracks.delete(trackId);
    }

    const cost = calculateTrackCost(a, b, lanes);

    // allow budget to go negative (gameplay choice) but warn
    state.budget -= cost.constructionCost;

    const line = L.polyline([[a.lat,a.lon],[b.lat,b.lon]], {
  color: "#000",              // black tracks
  weight: 2 + lanes * 1.5,    // thickness reflects lanes a bit
  opacity: 0.95,
  lineCap: "round"
}).addTo(layers.tracks);

    // Lane label at the midpoint
const midLat = (a.lat + b.lat) / 2;
const midLon = (a.lon + b.lon) / 2;

const label = L.marker([midLat, midLon], {
  icon: L.divIcon({
    className: "",
    iconSize: [20, 20],
    iconAnchor: [10, 10],
    html: `<div class="track-lane-label">${lanes}</div>`
  }),
  interactive: false,
  keyboard: false
}).addTo(layers.trackLabels);



    line.on("click", () => {
      if (confirm("Delete this track segment?")) {
        layers.tracks.removeLayer(line);
        layers.trackLabels.removeLayer(label);
        state.tracks.delete(trackId);
        updateUI();
        renderLines();
        showToast("Track deleted", "warning");
      }
    });

state.tracks.set(trackId, {
  id: trackId,
  from: fromId,
  to: toId,
  lanes,
  cost,
  built: true,
  _layer: line,
  _label: label
});

    if (!silent) {
      undo_pushAction({
        type: "track_add",
        trackId,
        refund: cost.constructionCost || 0,
        prev: prevTrack
      });
    }



    if (!silent) showToast(`Built track: ${a.name} → ${b.name}`, "success");
    updateUI();
    renderLines();
    return trackId;
  }

  // Track build mode now CHAINS:
  // click A, click B => builds A→B, keeps B as next start.
  function handleTrackBuildClick(node){
    if (!state.pendingTrackNode) {
      state.pendingTrackNode = node;
      showToast(`Track: start = ${node.name}`, "info");
      updateUI();
      return;
    }

    const a = state.pendingTrackNode;
    const b = node;

    if (a.id === b.id) {
      showToast("Pick a different node", "warning");
      updateUI();
      return;
    }

    addTrack(a.id, b.id, state.pendingTrackLanes || 1);
    state.pendingTrackNode = b;
    showToast(`Track: next start = ${b.name}`, "info");
    updateUI();

  }

  // ======================
  // Lines (smart ordering + auto-track creation)
  // ======================
  function lineDefaults(type){
    if (type === "cargo") return { frequencyPerDay: 4, vehicleCapacity: 900, speedKmh: 80, color: "#ef4444" };
    if (type === "mixed") return { frequencyPerDay: 10, vehicleCapacity: 280, speedKmh: 120, color: "#6b7280" };
    return { frequencyPerDay: 18, vehicleCapacity: 360, speedKmh: 160, color: "#2b6cff" };
  }

function addLine(name, type="passenger", circular=false, overrides=null){
  const id = `LN-${Date.now()}`;
  const d = lineDefaults(type);

  const ln = {
    id,
    name,
    type,
    color: d.color,
    stops: [],
    circular: !!circular,
    frequencyPerDay: d.frequencyPerDay,
    vehicleCapacity: d.vehicleCapacity,
    speedKmh: d.speedKmh
  };

  // Apply safe overrides (only if valid numbers)
  if (overrides && typeof overrides === "object") {
    if (Number.isFinite(overrides.frequencyPerDay)) ln.frequencyPerDay = Math.max(0, overrides.frequencyPerDay);
    if (Number.isFinite(overrides.vehicleCapacity)) ln.vehicleCapacity = Math.max(1, overrides.vehicleCapacity);
    if (Number.isFinite(overrides.speedKmh)) ln.speedKmh = Math.max(10, overrides.speedKmh);
  }

  state.lines.set(id, ln);
  state.activeLine = id;

  renderLines();
  updateUI();
  showToast(`Created line: ${name}`, "success");
  return id;
}

  function pathLength(ids){
    let sum = 0;
    for (let i=0;i<ids.length-1;i++){
      const A = state.nodes.get(ids[i]);
      const B = state.nodes.get(ids[i+1]);
      if (!A || !B) continue;
      sum += map.distance([A.lat,A.lon],[B.lat,B.lon]);
    }
    return sum;
  }

  // 2-opt improvement to reduce criss-cross and shorten

// ======================
// Smart line geometry helpers (NO criss-cross, minimize detours)
// ======================

function clamp01(x){ return Math.max(0, Math.min(1, x)); }

// Pressure model (v1):
// - Demand is based on population (cities) or sumPop (clusters).
// - Supply is based on sum of (frequencyPerDay * vehicleCapacity) for lines that stop there.
// - Platforms cap how much frequency can be “handled” at the station.
// - Amenities increase effective handling a bit (comfort/circulation).
function computeStationPressure(){
  const DEMAND_PER_PERSON_PER_DAY = 0.04;   // tune later
  const MAX_TRAINS_PER_PLATFORM_PER_DAY = 10; // tune later

  // nodeId -> { demand, supply }
  const agg = new Map();

  // 1) Demand per node from population
  for (const n of state.nodes.values()){
    if (!n) continue;
    const id = String(n.id);
    const pop = Math.max(0, Number(n.population ?? n.sumPop ?? 0));
    if (pop <= 0) continue;

    const demand = pop * DEMAND_PER_PERSON_PER_DAY;
    agg.set(id, { demand, supply: 0 });
  }

  // 2) Supply per node from lines that stop there
  for (const line of state.lines.values()){
    if (!line || !Array.isArray(line.stops) || line.stops.length < 2) continue;

    const freq = Math.max(0, Number(line.frequencyPerDay || 0));
    const cap  = Math.max(0, Number(line.vehicleCapacity || 0));
    if (freq <= 0 || cap <= 0) continue;

    for (const rawId of line.stops){
      const id = String(rawId);

      // Ensure node exists in agg even if demand was 0
      if (!agg.has(id)) agg.set(id, { demand: 0, supply: 0 });

      const st = (typeof getStation === "function") ? getStation(id) : null;
      const platforms = Math.max(1, Number(st?.platforms || 1));
      const amenities = Math.max(0, Number(st?.amenities || 0));

      // Platforms cap usable frequency at the station (handled trains/day)
      const stationFreqCap = platforms * MAX_TRAINS_PER_PLATFORM_PER_DAY;
      const effectiveFreq = Math.min(freq, stationFreqCap);

      // Amenities increase effective handling slightly (comfort/circulation)
      const comfortMult = 1 + Math.min(0.6, amenities * 0.08);

      agg.get(id).supply += effectiveFreq * cap * comfortMult;
    }
  }

  // 3) Convert to pressure%
  state.stationPressure.clear();

  let worst = { id: null, pressurePct: 0 };
  for (const [id, v] of agg.entries()){
    const demand = Math.max(0, Number(v.demand || 0));
    const supply = Math.max(0, Number(v.supply || 0));

    // If no demand, no pressure (but still store)
    let pressurePct = 0;
    if (demand > 0) {
      const shortfall = clamp01((demand - supply) / demand); // 0..1
      pressurePct = Math.round(shortfall * 100);
    }

    state.stationPressure.set(id, { demand, supply, pressurePct });

    if (pressurePct > worst.pressurePct) worst = { id, pressurePct };
  }

  return worst; // can be used for a toast/debug later
}

function segLen(aId, bId){
  const A = state.nodes.get(aId), B = state.nodes.get(bId);
  if (!A || !B) return 0;
  return map.distance([A.lat, A.lon], [B.lat, B.lon]);
}

// Proper segment intersection test (in screen space for stability)
function segmentsIntersect(aId,bId,cId,dId){
  const A = state.nodes.get(aId), B = state.nodes.get(bId);
  const C = state.nodes.get(cId), D = state.nodes.get(dId);
  if (!A||!B||!C||!D) return false;

  const a = map.latLngToLayerPoint([A.lat,A.lon]);
  const b = map.latLngToLayerPoint([B.lat,B.lon]);
  const c = map.latLngToLayerPoint([C.lat,C.lon]);
  const d = map.latLngToLayerPoint([D.lat,D.lon]);

  function ccw(p1,p2,p3){
    return (p3.y - p1.y) * (p2.x - p1.x) > (p2.y - p1.y) * (p3.x - p1.x);
  }

  // share endpoints => ignore
  const shared =
    (aId===cId)||(aId===dId)||(bId===cId)||(bId===dId);
  if (shared) return false;

  return (ccw(a,c,d) !== ccw(b,c,d)) && (ccw(a,b,c) !== ccw(a,b,d));
}

function countCrossings(stops){
  let x = 0;
  for (let i=0;i<stops.length-1;i++){
    for (let j=i+2;j<stops.length-1;j++){
      // skip adjacent and skip first-last adjacency
      if (i===0 && j===stops.length-2) continue;
      if (segmentsIntersect(stops[i],stops[i+1],stops[j],stops[j+1])) x++;
    }
  }
  return x;
}

// Score = total length + huge penalty for crossings
function lineScore(stops){
  let len = 0;
  for (let i=0;i<stops.length-1;i++) len += segLen(stops[i], stops[i+1]);
  const crossings = countCrossings(stops);
  return len + crossings * 1e12; // crossings are basically forbidden
}

// 2-opt improvement to remove crossings + shorten route
function improveLineOrder(line){
  if (!line || !Array.isArray(line.stops) || line.stops.length < 4) return;

  let improved = true;
  let guard = 0;

  while (improved && guard < 80){
    improved = false;
    guard++;

    for (let i=0;i<line.stops.length-3;i++){
      for (let k=i+2;k<line.stops.length-1;k++){
        // don't break adjacency
        if (i===0 && k===line.stops.length-2) continue;

        const A = line.stops[i],     B = line.stops[i+1];
        const C = line.stops[k],     D = line.stops[k+1];

        const before = segLen(A,B) + segLen(C,D);
        const after  = segLen(A,C) + segLen(B,D);

        // If swapping reduces length OR fixes an intersection, do it
        const hadX = segmentsIntersect(A,B,C,D);
        if (after + 1e-6 < before || hadX) {
          // reverse the segment between B..C
          const middle = line.stops.slice(i+1, k+1).reverse();
          line.stops.splice(i+1, k - i, ...middle);
          improved = true;
        }
      }
    }
  }
}

// ======================
// FIXED: Smart add stop (prepend/append/insert + 2-opt cleanup)
// ======================
function addStopSmart(line, nodeId){
  if (!line || !Array.isArray(line.stops)) return;
  if (line.stops.includes(nodeId)) return;

  // 0-1 stops: just append
  if (line.stops.length < 2) {
    line.stops.push(nodeId);
    return;
  }

  let best = null;
  let bestScore = Infinity;

  // Candidate A: prepend
  {
    const cand = [nodeId, ...line.stops];
    const s = lineScore(cand);
    if (s < bestScore) { bestScore = s; best = cand; }
  }

  // Candidate B: append
  {
    const cand = [...line.stops, nodeId];
    const s = lineScore(cand);
    if (s < bestScore) { bestScore = s; best = cand; }
  }

  // Candidate C: insert between every pair
  for (let i = 0; i < line.stops.length - 1; i++) {
    const cand = line.stops.slice();
    cand.splice(i + 1, 0, nodeId);

    const s = lineScore(cand);
    if (s < bestScore) { bestScore = s; best = cand; }
  }

  line.stops = best || [...line.stops, nodeId];
  improveLineOrder(line);
}

  function autoLanesForLineType(type){
    if (type === "cargo") return CONFIG.AUTO_TRACK_LANES_CARGO;
    if (type === "mixed") return CONFIG.AUTO_TRACK_LANES_MIXED;
    return CONFIG.AUTO_TRACK_LANES_PASSENGER;
  }

// ======================
// Line rendering along built tracks (shortest path)
// ======================

function renderGraph_buildTrackAdj(){
  const adj = new Map();
  if (!map || !state.tracks || !state.nodes) return adj;

  for (const t of state.tracks.values()){
    const aId = t.from, bId = t.to;
    const a = state.nodes.get(aId);
    const b = state.nodes.get(bId);
    if (!a || !b) continue;

    const w = map.distance([Number(a.lat), Number(a.lon)], [Number(b.lat), Number(b.lon)]);
    if (!Number.isFinite(w) || w <= 0) continue;

    if (!adj.has(aId)) adj.set(aId, []);
    if (!adj.has(bId)) adj.set(bId, []);
    adj.get(aId).push({ to: bId, w });
    adj.get(bId).push({ to: aId, w });
  }
  return adj;
}

function renderGraph_shortestPath(adj, startId, goalId){
  if (!startId || !goalId) return null;
  if (startId === goalId) return [startId];
  if (!adj || !adj.size) return null;

  const dist = new Map();
  const prev = new Map();
  const visited = new Set();

  dist.set(startId, 0);
  const pq = [{ id: startId, d: 0 }]; // tiny graphs: simple array PQ is fine

  while (pq.length) {
    pq.sort((a,b) => a.d - b.d);
    const cur = pq.shift();
    if (!cur) break;

    const u = cur.id;
    if (visited.has(u)) continue;
    visited.add(u);

    if (u === goalId) break;

    const nbrs = adj.get(u);
    if (!nbrs) continue;

    for (const e of nbrs) {
      const nd = cur.d + e.w;
      const best = dist.has(e.to) ? dist.get(e.to) : Infinity;
      if (nd < best) {
        dist.set(e.to, nd);
        prev.set(e.to, u);
        pq.push({ id: e.to, d: nd });
      }
    }
  }

  if (!dist.has(goalId)) return null;

  // Reconstruct
  const path = [];
  let cur = goalId;
  while (cur != null) {
    path.push(cur);
    if (cur === startId) break;
    cur = prev.get(cur);
  }
  path.reverse();
  return path[0] === startId ? path : null;
}

function ensureLineTracks(line, adj){
  // Only auto-build a direct segment if there is NO existing route on tracks.
  if (!line || !Array.isArray(line.stops) || line.stops.length < 2) return;

  const lanes = autoLanesForLineType(line.type);

  const pairs = [];
  for (let i=0;i<line.stops.length-1;i++) pairs.push([line.stops[i], line.stops[i+1]]);
  if (line.circular && line.stops.length >= 3) pairs.push([line.stops[line.stops.length-1], line.stops[0]]);

  for (const [a,b] of pairs){
    // If there's already a route along tracks, DON'T create a shortcut.
    const route = renderGraph_shortestPath(adj, a, b);
    if (route && route.length >= 2) continue;

    // No route: fall back to creating a direct track segment (keeps old behavior)
    const key = edgeKey(a,b);
    const id = `TK-${key}`;
    if (!state.tracks.has(id)) addTrack(a, b, lanes, { silent:true });
  }
}

function renderLines(){
  layers.lines.clearLayers();

  // Build adjacency from currently-built tracks
  const adj = renderGraph_buildTrackAdj();

  for (const line of state.lines.values()){
    if (!Array.isArray(line.stops) || line.stops.length < 2) continue;

    // Ensure connectivity but don't create shortcuts if a route already exists
    ensureLineTracks(line, adj);

    // Build polyline points by routing along tracks between consecutive stops
    const latlngs = [];

    const pushPath = (pathIds) => {
      if (!Array.isArray(pathIds) || pathIds.length < 2) return false;
      const pts = [];
      for (const id of pathIds){
        const n = state.nodes.get(id);
        if (n) pts.push([Number(n.lat), Number(n.lon)]);
      }
      if (pts.length < 2) return false;

      // concat, avoiding duplicate point at joins
      if (!latlngs.length) latlngs.push(...pts);
      else latlngs.push(...pts.slice(1));
      return true;
    };

    for (let i=1; i<line.stops.length; i++){
      const a = line.stops[i-1];
      const b = line.stops[i];
      const path = renderGraph_shortestPath(adj, a, b);

      if (!pushPath(path)) {
        // fallback: direct segment if something is missing
        const A = state.nodes.get(a), B = state.nodes.get(b);
        if (A && B) {
          if (!latlngs.length) latlngs.push([A.lat, A.lon]);
          latlngs.push([B.lat, B.lon]);
        }
      }
    }

    if (line.circular && line.stops.length >= 3) {
      const a = line.stops[line.stops.length - 1];
      const b = line.stops[0];
      const path = renderGraph_shortestPath(adj, a, b);
      if (!pushPath(path)) {
        const A = state.nodes.get(a), B = state.nodes.get(b);
        if (A && B) latlngs.push([B.lat, B.lon]);
      }
    }

    if (latlngs.length < 2) continue;

    L.polyline(latlngs, {
      color: line.color,
      weight: line.id === state.activeLine ? 5 : 3.5,
      opacity: line.id === state.activeLine ? 0.90 : 0.62,
      dashArray: line.type === "cargo" ? "10,10" : null
    }).addTo(layers.lines)
      .bindTooltip(`${line.name} (${line.type}) • freq ${line.frequencyPerDay}/day • cap ${line.vehicleCapacity}${line.type==="cargo"?"t":" pax"}${line.circular ? " ⟳" : ""}`);
  }
}


// ======================
// Train dots (visual only): move along LINES, inherit line color
// ======================
const trainVis = {
  trains: [],
  rafId: 0,
  lastTs: 0,
  timeScale: 120,  // speeds up movement so you can see it
  dotRadius: 7,    // bigger dots
};

function trainVis_stop(){
  if (trainVis.rafId) cancelAnimationFrame(trainVis.rafId);
  trainVis.rafId = 0;
  trainVis.lastTs = 0;
}

function trainVis_clear(){
  try { layers.trains.clearLayers(); } catch(_) {}
  trainVis.trains.length = 0;
}

function trainVis_latLngAt(t, km){
  const cum = t.cumKm;
  const pts = t.pts;
  if (!cum || !pts || pts.length < 2) return null;

  // clamp
  if (km <= 0) return pts[0];
  if (km >= t.lenKm) return pts[pts.length - 1];

  // find segment (linear scan; routes are short)
  let i = 0;
  while (i < cum.length - 1 && cum[i + 1] < km) i++;

  const a = pts[i];
  const b = pts[i + 1];
  const segLen = (cum[i + 1] - cum[i]) || 1e-9;
  const f = (km - cum[i]) / segLen;

  return L.latLng(
    a.lat + (b.lat - a.lat) * f,
    a.lng + (b.lng - a.lng) * f
  );
}

function trainVis_tick(ts){
  const dt = Math.min(0.08, Math.max(0.0, (ts - (trainVis.lastTs || ts)) / 1000)); // clamp dt
  trainVis.lastTs = ts;

  for (const t of trainVis.trains) {
    const speedKmh = Math.max(10, Number(t.speedKmh || 120));
    const kmPerSec = (speedKmh / 3600) * trainVis.timeScale;

    t.posKm += kmPerSec * dt * t.dir;

    if (t.circular) {
      const Lk = t.lenKm || 1;
      t.posKm = ((t.posKm % Lk) + Lk) % Lk;
    } else {
      if (t.posKm > t.lenKm) {
        t.posKm = t.lenKm - (t.posKm - t.lenKm);
        t.dir = -1;
      }
      if (t.posKm < 0) {
        t.posKm = -t.posKm;
        t.dir = 1;
      }
    }

    const ll = trainVis_latLngAt(t, t.posKm);
    if (ll) t.marker.setLatLng(ll);
  }

  trainVis.rafId = requestAnimationFrame(trainVis_tick);
}

function trainVis_start(){
  if (trainVis.rafId) return;
  trainVis.lastTs = performance.now();
  trainVis.rafId = requestAnimationFrame(trainVis_tick);
}

function trainVis_rebuildFromLines(){
  // IMPORTANT: trains move ONLY on LINES (not on raw tracks)
  trainVis_clear();

  const lines = state.lines;
  if (!lines || typeof lines.values !== "function") { trainVis_stop(); return; }
  if (!map) { trainVis_stop(); return; }

  let count = 0;

  for (const line of lines.values()) {
    if (!line || !Array.isArray(line.stops) || line.stops.length < 2) continue;

    // Build polyline points from stops
    const pts = [];
    for (const stopId of line.stops) {
      const n = state.nodes.get(stopId);
      if (!n) continue;
      pts.push(L.latLng(Number(n.lat), Number(n.lon)));
    }
    if (pts.length < 2) continue;

    // If circular, close the loop visually
    const circular = !!line.circular;
    if (circular && pts.length >= 3) pts.push(L.latLng(pts[0].lat, pts[0].lng));

    // Cum distance along route
    const cumKm = [0];
    for (let i = 1; i < pts.length; i++) {
      const km = (map.distance([pts[i-1].lat, pts[i-1].lng], [pts[i].lat, pts[i].lng]) || 0) / 1000;
      cumKm[i] = cumKm[i-1] + Math.max(0, km);
    }
    const lenKm = cumKm[cumKm.length - 1] || 0;
    if (lenKm <= 0) continue;

    // How many dots for this line (cap for performance)
    const freq = Math.max(0, Number(line.frequencyPerDay || 0));
    const trainsOnLine = Math.max(1, Math.min(10, Math.round(freq / 4) || 1));

    const color = line.color || "#2b6cff";
    const speedKmh = Math.max(40, Number(line.speedKmh || 120));

    for (let k = 0; k < trainsOnLine; k++) {
      const startKm = lenKm * (k / trainsOnLine);

      const marker = L.circleMarker(pts[0], {
        radius: trainVis.dotRadius,
        color: "#ffffff",
        weight: 2,
        fillColor: color,
        fillOpacity: 0.95,
        interactive: false,
        pane: "markerPane",
      }).addTo(layers.trains);

      trainVis.trains.push({
        marker,
        pts,
        cumKm,
        lenKm,
        posKm: startKm,
        dir: 1,
        circular,
        speedKmh,
      });

      count++;
    }
  }

  if (count > 0) trainVis_start();
  else trainVis_stop();
}
trainVis_rebuildFromLines();
  

  // ======================
  // Node selection logic
  // ======================
  function selectNode(nodeId){
    const node = state.nodes.get(nodeId);
    if (!node) return;

    state.selectedNode = node;

    // Refresh cluster active styling if relevant
    if (map.getZoom() <= CONFIG.CLUSTER_VIEW_MAX_ZOOM) renderClusterMarkers();

    // Line build mode
if (state.activeLine && state.lines.has(state.activeLine) && state.lineBuildMode) {
  const line = state.lines.get(state.activeLine);
  const beforeStops = Array.isArray(line.stops) ? line.stops.slice() : [];

  addStopSmart(line, nodeId);

  // Only push undo if something actually changed
  if (Array.isArray(line.stops) && line.stops.length !== beforeStops.length) {
    undo_pushAction({
      type: "line_stops",
      lineId: line.id,
      beforeStops
    });
  }

  showToast(`Added stop: ${node.name}`, "success");
  renderLines();
  updateUI();
  return;
}

  // Track build mode
    if (state.activeTab === "tracks" && state.trackBuildMode) {
      handleTrackBuildClick(node);
      return;
    }

    map.setView([node.lat, node.lon], Math.max(map.getZoom(), 8));
  }

  // ======================
  // Simulation
  // ======================
  function simulateYear(){
    try {
      state.year++;
      state.budget += state.annualBudget;

      // Economy: uses tracks + lines properties (freq/cap/speed)
      computeEconomy(state, map);

// Station retail rent (added on top of economy.js results)
const rent = computeRetailRentEURPerYear();
state.revenue = (Number(state.revenue || 0) + rent);
state.profit = (Number(state.revenue || 0) - Number(state.costs || 0));

// Optional: make profit actually affect budget (feels better)
state.budget += state.profit;


let flows = null;
try {
  flows = computeFlows(state, map);
} catch (err) {
  console.warn("Dynamics computeFlows failed:", err);
  flows = null;
}

// Only overwrite last flows if the new result looks usable
const newList = Array.isArray(flows?.flows) ? flows.flows : null;
if (newList && newList.length > 0) {
  state._lastFlows = flows;
} else {
  // Keep previous flows so overlay doesn't disappear
  if (!state._lastFlows) state._lastFlows = flows; // first run
}

// Only update summary/economy if we have a flows object
if (flows) {
  state.flowSummary = {
    ...(state.flowSummary || {}),
    goodsDelivered: Number(flows.goodsDelivered || 0),
    goodsUnmet: Number(flows.goodsUnmet || 0),
    passengerTrips: Number(flows.passengerTrips || 0),
    passengerUnmet: Number(flows.passengerUnmet || 0),
    demandMetPct: Number(flows.demandMetPct || 0),

    deliveredGoodsEUR: Number(flows.deliveredGoodsEUR || 0),
    deliveredPassengersEUR: Number(flows.deliveredPassengersEUR || 0),
    lostDemandEUR: Number(flows.lostDemandEUR || 0),
    congestionPenaltyEUR: Number(flows.congestionPenaltyEUR || 0),
  };

  const addRev =
    Number(flows.deliveredGoodsEUR || 0) + Number(flows.deliveredPassengersEUR || 0);
  const addCost = Number(flows.congestionPenaltyEUR || 0);

  state.revenue = Number(state.revenue || 0) + addRev;
  state.costs = Number(state.costs || 0) + addCost;
  state.profit = state.revenue - state.costs;
}

// Always attempt to render overlay (uses state._lastFlows)
dynFlow_render();





      showToast(
        `Year ${state.year} simulated. Profit: ${formatCurrency(state.profit)} • Rent: ${formatCurrency(rent)}`,
        state.profit >= 0 ? "success" : "error"
      );
      computeStationPressure();
      updateUI();
    } catch (e) {
      console.error(e);
      showToast("Simulation crashed", "error");
      // If user can't open DevTools, show error text in panel footer:
      const panel = document.getElementById("controlPanel");
      panel.insertAdjacentHTML("beforeend", `<div class="hint" style="margin-top:10px;border-color:#fecaca;color:#991b1b;">${String(e)}</div>`);
    }
  }

// ======================
// Dynamics overlay: moving trains (Leaflet markers animated)
// ======================

state._dynFlow = {
  rafId: null,
  particles: [], // { marker, latlngs, cum, total, t0, speed, type }
};

function dynFlow_clear(){
  try { layers.flowOverlay.clearLayers(); } catch(_) {}
  state._dynFlow.particles = [];
  if (state._dynFlow.rafId) cancelAnimationFrame(state._dynFlow.rafId);
  state._dynFlow.rafId = null;
}

function dynFlow_buildCumDistances(latlngs){
  const cum = [0];
  let total = 0;
  for (let i=1;i<latlngs.length;i++){
    const a = latlngs[i-1], b = latlngs[i];
    const d = map.distance(a, b) || 0;
    total += d;
    cum.push(total);
  }
  return { cum, total };
}

function dynFlow_pointAt(latlngs, cum, total, dist){
  if (!latlngs || latlngs.length < 2 || total <= 0) return latlngs?.[0] || [0,0];

  // wrap
  let x = dist % total;
  if (x < 0) x += total;

  // find segment
  let i = 1;
  while (i < cum.length && cum[i] < x) i++;
  if (i >= cum.length) return latlngs[latlngs.length - 1];

  const d0 = cum[i-1], d1 = cum[i];
  const t = (d1 - d0) > 0 ? ((x - d0) / (d1 - d0)) : 0;

  const A = latlngs[i-1], B = latlngs[i];
  const lat = A[0] + (B[0] - A[0]) * t;
  const lon = A[1] + (B[1] - A[1]) * t;
  return [lat, lon];
}

function dynFlow_render(){
  const dyn = state.dynamics || {};
  if (!dyn.enabled || !dyn.showOverlay) {
    dynFlow_clear();
    return;
  }

  dynFlow_clear();

  const mode = dyn.mode || "both";
  const MAX_PARTICLES = 180;
  let created = 0;

  for (const line of state.lines.values()){
    if (created >= MAX_PARTICLES) break;
    if (!line || !Array.isArray(line.stops) || line.stops.length < 2) continue;

    // Mode filter by line type
    const isGoods = (line.type === "cargo");
    const isPax = (line.type === "passenger");
    const isMixed = (line.type === "mixed");

    const showThis =
      (mode === "both") ||
      (mode === "goods" && (isGoods || isMixed)) ||
      (mode === "passengers" && (isPax || isMixed));

    if (!showThis) continue;

    // Build latlngs from stops (this guarantees trains never run on tracks without a line)
    const latlngs = [];
    for (const id of line.stops){
      const n = state.nodes.get(id);
      if (n) latlngs.push([n.lat, n.lon]);
    }
    if (latlngs.length < 2) continue;

    // Circular lines loop; non-circular go out-and-back (handled in tick)
    if (line.circular && latlngs.length >= 3) latlngs.push(latlngs[0]);

    const { cum, total } = dynFlow_buildCumDistances(latlngs);
    if (total <= 0) continue;

    // Speed from line speedKmh
    const speedKmh = Math.max(20, Number(line.speedKmh || 120));
    const speed = (speedKmh * 1000) / 3600; // m/s

    // Frequency -> headway
    const freq = Math.max(0, Number(line.frequencyPerDay || 0));
    if (freq <= 0) continue;

    // Visual number of trains shown for this line (1..10)
    const trainCount = Math.max(1, Math.min(10, Math.round(freq)));

    const headwaySec = 86400 / freq; // timetable spacing (seconds/day)

    // Bigger dots
    const radius = (line.id === state.activeLine) ? 6.2 : 5.4;

    // Line color
    const color = line.color || "#2b6cff";

    // Create trains with staggered departures (timetable)
    const now = performance.now();
    for (let k=0; k<trainCount && created<MAX_PARTICLES; k++){
      const departOffsetSec = k * headwaySec; // seconds after "midnight"
      const marker = L.circleMarker(latlngs[0], {
        radius,
        color,
        weight: 0,
        fillColor: color,
        fillOpacity: 0.92,
        interactive: false
      }).addTo(layers.flowOverlay);

      state._dynFlow.particles.push({
        marker,
        latlngs,
        cum,
        total,
        speed,                 // m/s
        departOffsetSec,       // timetable offset
        isCircular: !!line.circular,
        lineId: line.id
      });

      created++;
    }
  }

  dynFlow_tick(); // start animation loop
}

function dynFlow_tick(){
  const dyn = state.dynamics || {};
  if (!dyn.enabled || !dyn.showOverlay) {
    dynFlow_clear();
    return;
  }

  // Accelerated "clock" so it feels alive:
  // 1 real second = 6 simulated minutes
  const timeScale = 360; // seconds-of-day per real second

  const nowMs = performance.now();
  const simDaySec = ((nowMs / 1000) * timeScale) % 86400;

  for (const p of state._dynFlow.particles) {
    if (!p || !p.marker) continue;

    const tSec = simDaySec - (p.departOffsetSec || 0);

    // If train hasn't "departed" yet this day, keep it at start station
    if (tSec < 0) {
      p.marker.setLatLng(p.latlngs[0]);
      continue;
    }

    const dist = tSec * (p.speed || 0); // meters traveled along route

    // Circular: loop around the route
    // Non-circular: go out-and-back (ping-pong)
    let d = dist;
    if (!p.isCircular) {
      const period = 2 * p.total;
      if (period > 0) {
        let m = d % period;
        if (m < 0) m += period;
        d = (m <= p.total) ? m : (2 * p.total - m);
      }
    }

    const pos = dynFlow_pointAt(p.latlngs, p.cum, p.total, d);
    p.marker.setLatLng(pos);
  }

  state._dynFlow.rafId = requestAnimationFrame(dynFlow_tick);
}

// ======================
// Mode bar + hotkeys
// ======================
let uiHotkeysInstalled = false;

function uiMode_compute(){
  // Track build mode has priority
  if (state.trackBuildMode) {
    const start = state.pendingTrackNode ? state.pendingTrackNode.name : "—";
    return {
      label: "BUILD TRACK",
      pill: "T",
      detail: `Chain start: ${start}`,
      cursor: "crosshair"
    };
  }

  // Line build mode (only if a line is selected)
  if (state.activeLine && state.lineBuildMode) {
    const ln = state.lines?.get?.(state.activeLine);
    return {
      label: "BUILD LINE",
      pill: "L",
      detail: `Active: ${ln?.name || state.activeLine}`,
      cursor: "copy"
    };
  }

  // Line selected, but building off
  if (state.activeLine && !state.lineBuildMode) {
    const ln = state.lines?.get?.(state.activeLine);
    return {
      label: "INSPECT (line selected)",
      pill: "I",
      detail: `Active: ${ln?.name || state.activeLine} • add stops OFF`,
      cursor: ""
    };
  }

  // Default
  return {
    label: "INSPECT",
    pill: "I",
    detail: "Click nodes to inspect/select",
    cursor: ""
  };
}

function uiMode_render(){
  const el = document.getElementById("modeBar");
  if (!el) return;

  const m = uiMode_compute();

  el.innerHTML = `
    <div class="row">
      <div class="mode">${m.label}</div>
      <span class="pill">${m.pill}</span>
    </div>
    <div class="detail">${m.detail}</div>
    <div class="keys">I Inspect • T Track • L Line • U Undo • Esc Cancel</div>
  `;

  // Cursor feedback on the map
  try {
    if (map && map.getContainer) map.getContainer().style.cursor = m.cursor || "";
  } catch(_) {}
}

function uiSetInspectMode(){
  state.trackBuildMode = false;
  state.pendingTrackNode = null;
  state.lineBuildMode = false;
  state.activeLine = null;

  try { renderLines?.(); } catch(_) {}
  updateUI();
  showToast("Inspect mode", "info");
}

function uiCancelBuildModes(){
  const wasAnything =
    !!state.pendingTrackNode || !!state.trackBuildMode || !!state.lineBuildMode;

  state.pendingTrackNode = null;
  state.trackBuildMode = false;
  state.lineBuildMode = false;

  try { renderLines?.(); } catch(_) {}
  updateUI();

  if (wasAnything) showToast("Cancelled build modes", "info");
}

function uiHotkeys_install(){
  if (uiHotkeysInstalled) return;
  uiHotkeysInstalled = true;

  window.addEventListener("keydown", (e) => {
    // allow Esc always, but otherwise ignore if typing
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
    const typing = (tag === "input" || tag === "textarea" || tag === "select");

    const key = (e.key || "").toLowerCase();

    // Esc cancels even while typing
    if (key === "escape") {
      e.preventDefault();
      uiCancelBuildModes();
      return;
    }

    if (typing) return;
    if (e.ctrlKey || e.metaKey || e.altKey) return;

    if (key === "i") {
      e.preventDefault();
      uiSetInspectMode();
      return;
    }

    if (key === "t") {
      e.preventDefault();
      // entering track mode should disable line building to prevent surprises
      state.lineBuildMode = false;

      // Prefer existing helper if present
      if (typeof setTrackBuildMode === "function") {
        setTrackBuildMode(!state.trackBuildMode);
      } else {
        state.trackBuildMode = !state.trackBuildMode;
        state.pendingTrackNode = null;
        updateUI();
      }
      return;
    }

    if (key === "l") {
      e.preventDefault();
      // toggles line building, but only if a line is selected
      if (!state.activeLine) {
        showToast("Select a line first", "warning");
        return;
      }
      // turning on line mode should turn off track mode
      state.trackBuildMode = false;
      state.pendingTrackNode = null;

      if (typeof toggleLineBuildMode === "function") toggleLineBuildMode();
      else {
        state.lineBuildMode = !state.lineBuildMode;
        updateUI();
      }
      return;
    }

    if (key === "u") {
      e.preventDefault();
      if (typeof undo_applyLast === "function") undo_applyLast();
      else showToast("Undo not available", "warning");
      return;
    }
  }, { passive: false });
}




  // ======================
  // UI actions
  // ======================
  function switchTab(tab){
    state.activeTab = tab;
    if (tab !== "tracks") {
      state.trackBuildMode = false;
      state.pendingTrackNode = null;
    }
    updateUI();
  }

  function setTrackBuildMode(on){
    state.trackBuildMode = !!on;
    state.pendingTrackNode = null;
    updateUI();
    showToast(on ? "Track mode ON: click nodes to chain-build" : "Track mode OFF", on ? "success" : "warning");
  }

  function setTrackLanes(n){
    state.pendingTrackLanes = clamp(Number(n)||1, 1, 8);
    updateUI();
  }

function createNewLine(){
  const name = document.getElementById("lineName")?.value?.trim() || "New Line";
  const type = document.getElementById("lineType")?.value || "passenger";
  const circular = !!document.getElementById("lineCircular")?.checked;

  // Read optional inputs
  const freqRaw = document.getElementById("lineFreq")?.value;
  const capRaw  = document.getElementById("lineCap")?.value;
  const spdRaw  = document.getElementById("lineSpeed")?.value;

  const freq = Number(freqRaw);
  const cap  = Number(capRaw);
  const spd  = Number(spdRaw);

  const overrides = {};
  if (Number.isFinite(freq)) overrides.frequencyPerDay = freq;
  if (Number.isFinite(cap)) overrides.vehicleCapacity = cap;
  if (Number.isFinite(spd)) overrides.speedKmh = spd;

  addLine(name, type, circular, overrides);

  // Optional: clear fields for convenience (safe)
  const lnEl = document.getElementById("lineName");
  if (lnEl) lnEl.value = "";
}

function selectLine(id){
  if (!id) {
    state.activeLine = null;
    renderLines();
    updateUI();
    showToast("No line selected (inspect mode)", "info");
    return;
  }

  state.activeLine = id;
  renderLines();
  updateUI();
}


  function toggleCircularActive(){
    const line = state.lines.get(state.activeLine);
    if (!line) return;
    line.circular = !line.circular;
    renderLines();
    updateUI();
    showToast(line.circular ? "Line set to circular" : "Line set to non-circular", "success");
  }

  function toggleLineBuildMode(){
    state.lineBuildMode = !state.lineBuildMode;
    updateUI();
    showToast(state.lineBuildMode ? "Line building ON" : "Line building OFF", "info");
  }

function setActiveLineColor(hex){
  const id = state.activeLine;
  const line = id ? state.lines.get(id) : null;
  if (!line) {
    showToast("Select a line first", "warning");
    return;
  }

  if (typeof hex !== "string" || !/^#([0-9a-fA-F]{6})$/.test(hex)) {
    showToast("Invalid color", "warning");
    return;
  }

  line.color = hex;

  renderLines();
  syncMarkerVisibility(); // refresh rings/markers if they use line colors
  updateUI();
  showToast("Line color updated", "success");
}


  function deleteActiveLine(){
    const id = state.activeLine;
    if (!id) return;
    if (!confirm("Delete active line?")) return;
    state.lines.delete(id);
    state.activeLine = null;
    renderLines();
    updateUI();
    showToast("Line deleted", "warning");
  }

  function clearAllTracks(){
    layers.tracks.clearLayers();
    layers.trackLabels.clearLayers();
    state.tracks.clear();
    state.pendingTrackNode = null;
    renderLines();
    updateUI();
    showToast("Cleared all tracks", "warning");
  }

// ======================
// Undo (last action)
// ======================
function undo_pushAction(action){
  if (!state.undo) state.undo = { stack: [], max: 60 };
  const st = state.undo.stack;
  st.push(action);
  const max = state.undo.max || 60;
  if (st.length > max) st.shift();
}

function undo_removeTrackById(trackId){
  const t = state.tracks.get(trackId);
  if (!t) return null;

  if (t._layer) layers.tracks.removeLayer(t._layer);

  // label may live in tracks OR trackLabels depending on your current code
  if (t._label) {
    layers.trackLabels.removeLayer(t._label);
    layers.tracks.removeLayer(t._label);
  }

  state.tracks.delete(trackId);
  return t;
}

// restore a previous track visually WITHOUT charging budget
function undo_drawTrackVisual(fromId, toId, lanes){
  const a = state.nodes.get(fromId);
  const b = state.nodes.get(toId);
  if (!a || !b) return null;

  const key = edgeKey(fromId, toId);
  const trackId = `TK-${key}`;

  const cost = calculateTrackCost(a, b, lanes);

  const line = L.polyline([[a.lat,a.lon],[b.lat,b.lon]], {
    color: "#000",
    weight: 2 + lanes * 1.5,
    opacity: 0.95,
    lineCap: "round"
  }).addTo(layers.tracks);

  const midLat = (a.lat + b.lat) / 2;
  const midLon = (a.lon + b.lon) / 2;

  const label = L.marker([midLat, midLon], {
    icon: L.divIcon({
      className: "",
      iconSize: [20, 20],
      iconAnchor: [10, 10],
      html: `<div class="track-lane-label">${lanes}</div>`
    }),
    interactive: false,
    keyboard: false
  });

  // prefer trackLabels layer if present
  if (layers.trackLabels && typeof layers.trackLabels.addLayer === "function") label.addTo(layers.trackLabels);
  else label.addTo(layers.tracks);

  line.on("click", () => {
    if (confirm("Delete this track segment?")) {
      undo_removeTrackById(trackId);
      updateUI();
      renderLines();
      showToast("Track deleted", "warning");
    }
  });

  state.tracks.set(trackId, {
    id: trackId,
    from: fromId,
    to: toId,
    lanes,
    cost,
    built: true,
    _layer: line,
    _label: label
  });

  return trackId;
}

function undo_applyLast(){
  const st = state.undo?.stack;
  if (!st || !st.length) {
    showToast("Nothing to undo", "info");
    return;
  }

  const action = st.pop();

  if (action.type === "track_add") {
    undo_removeTrackById(action.trackId);

    // If we overwrote a previous track, restore it
    if (action.prev && action.prev.from && action.prev.to) {
      undo_drawTrackVisual(action.prev.from, action.prev.to, action.prev.lanes || 1);
    }

    // Refund only what THIS build cost
    state.budget += Math.max(0, Number(action.refund || 0));

    state.pendingTrackNode = null;

    renderLines();
    updateUI();
    showToast("Undid track build", "success");
    return;
  }

  if (action.type === "line_stops") {
    const line = state.lines.get(action.lineId);
    if (line && Array.isArray(action.beforeStops)) {
      line.stops = action.beforeStops.slice();
    }

    renderLines();
    updateUI();
    showToast("Undid stop add", "success");
    return;
  }

  showToast("Nothing to undo", "info");
}


// ======================
// Optimizer (beta) - applies changes, not just suggestions
// ======================
function opt_scopeNodeIds(){
  // If inside a cluster: optimize over cities in that cluster
  if (state.activeClusterId && state.clusters && state.clusters.has(state.activeClusterId)) {
    const cl = state.clusters.get(state.activeClusterId);
    if (cl && cl.cityIds && typeof cl.cityIds.forEach === "function") return Array.from(cl.cityIds);
  }
  // Otherwise optimize over cluster hubs
  if (state.clusters && typeof state.clusters.keys === "function") return Array.from(state.clusters.keys());
  return [];
}

function opt_nodePop(id){
  const n = state.nodes?.get(id);
  return Math.max(0, Number(n?.population || 0));
}

function opt_distKm(aId, bId){
  if (!map || !map.distance) return Infinity;
  const a = state.nodes?.get(aId);
  const b = state.nodes?.get(bId);
  if (!a || !b) return Infinity;
  const d = map.distance([Number(a.lat), Number(a.lon)], [Number(b.lat), Number(b.lon)]);
  return Number.isFinite(d) ? d / 1000 : Infinity;
}

function opt_colorByIndex(i){
  const palette = ["#2b6cff","#10b981","#f59e0b","#ef4444","#a855f7","#06b6d4","#84cc16","#f97316"];
  return palette[i % palette.length];
}

function opt_bearingDeg(fromId, toId){
  const a = state.nodes?.get(fromId);
  const b = state.nodes?.get(toId);
  if (!a || !b) return 0;

  const lat1 = Number(a.lat) * Math.PI / 180;
  const lon1 = Number(a.lon) * Math.PI / 180;
  const lat2 = Number(b.lat) * Math.PI / 180;
  const lon2 = Number(b.lon) * Math.PI / 180;

  const y = Math.sin(lon2 - lon1) * Math.cos(lat2);
  const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
  const brng = Math.atan2(y, x) * 180 / Math.PI;

  return (brng + 360) % 360;
}


function opt_buildLinesForScope(nodeIds){
  // Keep it safe: cap extreme sizes
  const ids = nodeIds
    .filter(id => state.nodes?.has(id))
    .sort((a,b)=> opt_nodePop(b)-opt_nodePop(a));

  if (ids.length < 2) return [];

  const MAXN = 120;
  const useIds = ids.length > MAXN ? ids.slice(0, MAXN) : ids.slice();

  // How many lines to create
  const n = useIds.length;
  const numLines = clamp(Math.round(Math.sqrt(n)), 2, 12);

  const hubs = useIds.slice(0, numLines);
  const groups = new Map();
  for (const h of hubs) groups.set(h, []);

  // Assign each node to nearest hub
  for (const id of useIds) {
    let bestHub = hubs[0];
    let bestD = Infinity;
    for (const h of hubs) {
      const d = opt_distKm(id, h);
      if (d < bestD) { bestD = d; bestHub = h; }
    }
    groups.get(bestHub).push(id);
  }

  // Build route per hub via nearest-neighbor ordering
  const lines = [];
  let idx = 0;

  for (const [hub, members] of groups.entries()) {
    // ensure hub first
    const set = new Set(members);
    set.add(hub);
    const pool = Array.from(set);

    if (pool.length < 2) continue;

    const remaining = pool.filter(x => x !== hub);

    // Order stops by angle around the hub (much less “snake-y”)
    remaining.sort((a, b) => {
      const aa = opt_bearingDeg(hub, a);
      const bb = opt_bearingDeg(hub, b);
      if (aa !== bb) return aa - bb;
      return opt_distKm(hub, a) - opt_distKm(hub, b);
    });

    const route = [hub, ...remaining];


    // Set sensible service params based on group population
    let popSum = 0;
    for (const rid of route) popSum += opt_nodePop(rid);

    const freq = clamp(Math.round(popSum / 3_000_000) + 2, 2, 24);
    const cap = 350; // passenger default (safe)
    const spd = 160;

    lines.push({
      id: `L-AUTO-${Date.now().toString(36)}-${idx}`,
      name: `Auto Line ${idx + 1}`,
      type: "passenger",
      color: opt_colorByIndex(idx),
      stops: route,
      circular: false,
      frequencyPerDay: freq,
      vehicleCapacity: cap,
      speedKmh: spd
    });

    idx++;
  }

  return lines;
}

function opt_autoBuildNetwork(mode){
  const scopeIds = opt_scopeNodeIds();
  if (!scopeIds.length) { showToast("No nodes in scope to optimize", "warning"); return; }

  if (mode === "replace") {
    const ok = confirm("Replace ALL current lines with an auto-built network?");
    if (!ok) return;
  }

  const newLines = opt_buildLinesForScope(scopeIds);
  if (!newLines.length) { showToast("Optimizer could not build lines (need 2+ nodes)", "warning"); return; }

  if (mode === "replace") {
    state.lines.clear();
    state.activeLine = null;
  }

  for (const l of newLines) {
    state.lines.set(l.id, l);
  }

  state.activeLine = newLines[0]?.id || state.activeLine;

  renderLines();
  dynFlow_render?.(); // if present, refresh moving dots
  updateUI();
  showToast(`Optimizer applied: ${newLines.length} lines (${mode})`, "success");
}

function opt_boostFrequencies(){
  let changed = 0;
  for (const l of state.lines.values()){
    if (!l) continue;
    const f = Math.max(0, Number(l.frequencyPerDay || 0));
    if (!Number.isFinite(f)) continue;
    const nf = clamp(Math.round(f * 1.2), 0, 200);
    if (nf !== f) { l.frequencyPerDay = nf; changed++; }
  }
  renderLines();
  dynFlow_render?.();
  updateUI();
  showToast(changed ? `Boosted frequencies on ${changed} lines` : "No frequencies to boost", changed ? "success" : "info");
}


function kv(k, v){ return `<span class="k">${k}:</span> <span class="v">${v}</span>`; }

function renderDynamicsTab(){
  const s = state.flowSummary || {};
  const dyn = state.dynamics || {};

  return `
    <div class="section">
      <div class="hint">
        This tab shows <b>demand / exports / bottlenecks</b> once the simulation writes them.
        For now it’s a UI win + scaffolding.
      </div>
    </div>

    <div class="section">
      <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Overlay</div>

      <label style="display:flex;gap:10px;align-items:center;font-weight:900;color:#334155;">
        <input type="checkbox" ${dyn.enabled ? "checked" : ""} onchange="setDynamicsEnabled(this.checked)">
        Enable dynamics
      </label>

      <label style="display:flex;gap:10px;align-items:center;font-weight:900;color:#334155;margin-top:8px;">
        <input type="checkbox" ${dyn.showOverlay ? "checked" : ""} onchange="setDynamicsOverlay(this.checked)">
        Show flow overlay
      </label>

      <div style="margin-top:10px;">
        <div class="k">Mode</div>
        <select class="field" onchange="setDynamicsMode(this.value)">
          <option value="goods" ${dyn.mode==="goods"?"selected":""}>Goods</option>
          <option value="passengers" ${dyn.mode==="passengers"?"selected":""}>Passengers</option>
          <option value="both" ${dyn.mode==="both"?"selected":""}>Both</option>
        </select>
      </div>

      <button class="btn warning" onclick="simulateYear()">Simulate Next Year</button>
    </div>

    <div class="section">
      <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Network Effect (yearly)</div>

      <div style="margin-top:10px; line-height:1.7;">
        ${kv("Demand met", `${Number(s.demandMetPct||0).toFixed(1)}%`)}
        <br>${kv("Goods delivered", fmtNum(s.goodsDelivered||0))}
        <br>${kv("Goods unmet", fmtNum(s.goodsUnmet||0))}
        <br>${kv("Passenger trips", fmtNum(s.passengerTrips||0))}
        <br>${kv("Passenger unmet", fmtNum(s.passengerUnmet||0))}
      </div>
    </div>

    <div class="section">
      <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Economy Impact (yearly)</div>

      <div style="margin-top:10px; line-height:1.7;">
        ${kv("Delivered goods €", formatCurrency(s.deliveredGoodsEUR || 0))}
        <br>${kv("Delivered passengers €", formatCurrency(s.deliveredPassengersEUR || 0))}
        <br>${kv("Lost demand €", formatCurrency(s.lostDemandEUR || 0))}
        <br>${kv("Congestion penalty €", formatCurrency(s.congestionPenaltyEUR || 0))}
      </div>
    </div>


    <div class="section">
      <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Biggest Export & Biggest Need</div>

      <div style="margin-top:10px; line-height:1.7;">
        ${kv("Top export", `${s.topExportName || "—"} (${formatCurrency(s.topExportValue||0)})`)}
        <br>${kv("Top need", `${s.topNeedName || "—"} (${formatCurrency(s.topNeedValue||0)})`)}
      </div>

      <div class="hint" style="margin-top:10px;">
        When we add real “goods types”, this becomes a per-good export/need list.
      </div>
    </div>

    <div class="section">
      <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Bottleneck</div>

      <div style="margin-top:10px; line-height:1.7;">
        ${kv("Top bottleneck", `${s.topBottleneck || "—"}`)}
        <br>${kv("Utilization / flow", fmtNum(s.topBottleneckValue||0))}
      </div>
    </div>
  `;
}


  function updateUI(){
    const panel = document.getElementById("controlPanel");
    const linesArr = Array.from(state.lines.values());
    const linesList = linesArr.map(l => `
    <div class="item ${l.id===state.activeLine ? "active" : ""}" onclick="selectLine('${l.id}')">
    <div style="font-weight:1000;color:#0f172a">${l.name}${l.circular ? " ⟳" : ""}</div>
    <div style="font-size:12px;font-weight:900;color:#64748b"> 
    ${l.stops.length} stops • ${l.type} • ${l.frequencyPerDay}/day
    <div class="row" style="margin-top:10px;">
    <button class="btn secondary" onclick="saveGame()">Save</button>
    <button class="btn secondary" onclick="loadGame()">Load</button>
    </div>

        </div>
      </div>
    `).join("");
    const lineOptions = [
  `<option value="" ${!state.activeLine ? "selected" : ""}>(No line selected — Inspect)</option>`,
  ...linesArr.map(l => `<option value="${l.id}" ${l.id===state.activeLine ? "selected" : ""}>${l.name} • ${l.type}</option>`)
].join("");

const activeLineObj = state.activeLine ? state.lines.get(state.activeLine) : null;
const activeLineColor = (activeLineObj && activeLineObj.color) ? activeLineObj.color : "#2b6cff";

    const activeCluster = state.activeClusterId ? state.clusters.get(state.activeClusterId) : null;

    const econ = state.economy || {};
    const exporterName = econ.biggestExporter?.id ? (state.nodes.get(econ.biggestExporter.id)?.name || econ.biggestExporter.id) : "—";
    const importerName = econ.biggestImporter?.id ? (state.nodes.get(econ.biggestImporter.id)?.name || econ.biggestImporter.id) : "—";

    // --- Score (0..100): UI-only, robust defaults ---
    const ssum = state.flowSummary || {};
    const _lines = (state.lines instanceof Map) ? Array.from(state.lines.values()) : [];
    const _tracks = (state.tracks instanceof Map) ? Array.from(state.tracks.values()) : [];
    const _nodes = (state.nodes instanceof Map) ? state.nodes : new Map();

    // service capacity proxy (cap/day)
    let _capPerDay = 0;
    for (const l of _lines) {
      const f = Math.max(0, Number(l.frequencyPerDay || 0));
      const c = Math.max(0, Number(l.vehicleCapacity || 0));
      _capPerDay += f * c;
    }

    // network size proxy (track km)
    let _trackKm = 0;
    if (map && map.distance && _tracks.length) {
      for (const t of _tracks) {
        const a = _nodes.get(t.from);
        const b = _nodes.get(t.to);
        if (!a || !b) continue;

        const d = map.distance(
          [Number(a.lat), Number(a.lon)],
          [Number(b.lat), Number(b.lon)]
        );
        if (Number.isFinite(d)) _trackKm += d / 1000;
      }
    }

    const _demandMet = clamp(Number(ssum.demandMetPct || 0), 0, 100);

    const _deliveredEUR = Math.max(
      0,
      Number(ssum.deliveredGoodsEUR || 0) + Number(ssum.deliveredPassengersEUR || 0)
    );
    const _congEUR = Math.max(0, Number(ssum.congestionPenaltyEUR || 0));
    const _penRate = _deliveredEUR > 0 ? clamp(_congEUR / _deliveredEUR, 0, 1) : 0;
    const _reliability = Math.round(100 * (1 - _penRate));

    // profit score (smooth, handles negatives)
    const _profit = Number(state.profit || 0);
    const _profitScore = Math.round(50 + 50 * Math.tanh(_profit / 200000000)); // ±€200M scale

    // service score (log-scaled so it doesn't explode)
    const _serviceScore = Math.round(clamp(
      12 * Math.log10(1 + (_capPerDay / 1000)) +
      18 * Math.log10(1 + (_trackKm / 50)),
      0, 100
    ));

    const _totalScore = Math.round(clamp(
      0.30 * _profitScore +
      0.30 * _demandMet +
      0.25 * _serviceScore +
      0.15 * _reliability,
      0, 100
    ));

    const _scoreColor = _totalScore >= 70 ? "#10b981" : (_totalScore >= 45 ? "#f59e0b" : "#ef4444");

    const scorePanelHtml = `
      <div class="hint" style="margin-top:10px;">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
          <div style="font-weight:1000;color:#0f172a;">Score</div>
          <div style="font-weight:1000;color:${_scoreColor};font-size:18px;">${_totalScore}/100</div>
        </div>

        <div style="height:8px;"></div>
        <div style="height:10px;background:#e2e8f0;border-radius:999px;overflow:hidden;">
          <div style="height:10px;width:${_totalScore}%;background:${_scoreColor};"></div>
        </div>

        <div style="margin-top:10px;line-height:1.7;">
          ${kv("Profit score", fmtNum(_profitScore))}
          <br>${kv("Demand met", `${_demandMet.toFixed(1)}%`)}
          <br>${kv("Service score", fmtNum(_serviceScore))}
          <br>${kv("Reliability", `${fmtNum(_reliability)}%`)}
        </div>

        <div style="margin-top:8px;color:#64748b;font-weight:850;font-size:12px;">
          Score = weighted mix of profit, demand met, service capacity×network size, and congestion reliability.
        </div>
      </div>
    `;


    // --- Line effectiveness ranking (capacity-km/day) ---
    const lineEffect = [];
    for (const l of linesArr) {
      const stops = Array.isArray(l.stops) ? l.stops : [];
      if (stops.length < 2) continue;

      const freq = Math.max(0, Number(l.frequencyPerDay || 0));
      const defaultCap = (l.type === "cargo") ? 1200 : (l.type === "mixed") ? 700 : 350;
      const vehCap = Math.max(0, Number(l.vehicleCapacity || defaultCap));

      let km = 0;
      if (map && state.nodes) {
        for (let i = 1; i < stops.length; i++) {
          const a = state.nodes.get(stops[i - 1]);
          const b = state.nodes.get(stops[i]);
          if (!a || !b) continue;

          const d = map.distance(
            [Number(a.lat), Number(a.lon)],
            [Number(b.lat), Number(b.lon)]
          );
          if (Number.isFinite(d)) km += d / 1000;
        }

        // if circular, close the loop for length estimation
        if (l.circular && stops.length >= 3) {
          const a = state.nodes.get(stops[stops.length - 1]);
          const b = state.nodes.get(stops[0]);
          if (a && b) {
            const d = map.distance(
              [Number(a.lat), Number(a.lon)],
              [Number(b.lat), Number(b.lon)]
            );
            if (Number.isFinite(d)) km += d / 1000;
          }
        }
      }

      const capKmPerDay = km * freq * vehCap;

      lineEffect.push({
        id: l.id,
        name: l.name || l.id,
        type: l.type || "passenger",
        color: l.color || "#2b6cff",
        km,
        freq,
        vehCap,
        capKmPerDay
      });
    }

    lineEffect.sort((a, b) => (b.capKmPerDay || 0) - (a.capKmPerDay || 0));
    const topLines = lineEffect.slice(0, 8);

    const lineRankingHtml = topLines.length ? topLines.map(r => `
      <div class="item" onclick="selectLine('${r.id}')">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
          <div style="display:flex;align-items:center;gap:8px;min-width:0;">
            <span style="width:12px;height:12px;border-radius:4px;flex:0 0 12px;background:${r.color};border:1px solid rgba(0,0,0,0.2);"></span>
            <div style="font-weight:1000;color:#0f172a;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${r.name}</div>
            <span class="badge">${r.type}</span>
          </div>
          <div style="font-weight:1000;color:#0f172a;white-space:nowrap;">${fmtNum(Math.round((r.capKmPerDay || 0) / 1000))}k</div>
        </div>
        <div style="margin-top:4px;font-size:12px;font-weight:900;color:#64748b;">
          ${(Number.isFinite(r.km) ? r.km : 0).toFixed(1)} km • ${fmtNum(Math.round(r.freq || 0))}/day • cap ${fmtNum(Math.round(r.vehCap || 0))}
        </div>
      </div>
    `).join("") : `
      <div style="padding:12px;color:#64748b;font-weight:1000;">
        Create a line with 2+ stops to see rankings.
      </div>
    `;


    // --- Network KPIs (UI-only; safe defaults) ---
    const tracksCount = state.tracks?.size || 0;
    const nodesCount = state.nodes?.size || 0;
    const linesCount = linesArr.length;

    let totalTrainsPerDay = 0;
    let totalCapacityPerDay = 0;
    let totalStops = 0;

    const stationMoves = new Map(); // nodeId -> trains/day (sum of frequencies)
    for (const l of linesArr) {
      const f = Math.max(0, Number(l.frequencyPerDay || 0));
      totalTrainsPerDay += f;
      totalCapacityPerDay += f * Math.max(0, Number(l.vehicleCapacity || 0));
      totalStops += Array.isArray(l.stops) ? l.stops.length : 0;

      if (Array.isArray(l.stops)) {
        for (const sid of l.stops) {
          stationMoves.set(sid, (stationMoves.get(sid) || 0) + f);
        }
      }
    }

    const avgStopsPerLine = linesCount ? (totalStops / linesCount) : 0;

    let busiestStationId = null;
    let busiestMoves = 0;
    for (const [sid, mv] of stationMoves.entries()) {
      if (mv > busiestMoves) { busiestMoves = mv; busiestStationId = sid; }
    }
    const busiestStationName = busiestStationId && state.nodes?.get(busiestStationId)
      ? (state.nodes.get(busiestStationId).name || busiestStationId)
      : "—";

    let trackKm = 0;
    if (map && state.tracks && typeof state.tracks.values === "function") {
      for (const t of state.tracks.values()) {
        const a = state.nodes?.get(t.from);
        const b = state.nodes?.get(t.to);
        if (!a || !b) continue;

        const d = map.distance(
          [Number(a.lat), Number(a.lon)],
          [Number(b.lat), Number(b.lon)]
        );
        if (Number.isFinite(d)) trackKm += d / 1000;
      }
    }


    panel.innerHTML = `
      <div class="section">
        <h3 class="title">Railway Network Simulator</h3>
        <p class="sub">
          Year: <b>${state.year}</b> • Budget: <b>${formatCurrency(state.budget)}</b>
          ${activeCluster ? `<span class="badge">In: ${activeCluster.hubName}</span>` : `<span class="badge">Spain</span>`}
        </p>

      <div class="tabs">
  <div class="tab ${state.activeTab==="network"?"active":""}" onclick="switchTab('network')">Network</div>
  <div class="tab ${state.activeTab==="tracks"?"active":""}" onclick="switchTab('tracks')">Tracks</div>
  <div class="tab ${state.activeTab==="economy"?"active":""}" onclick="switchTab('economy')">Economy</div>
  <div class="tab ${state.activeTab==="dynamics"?"active":""}" onclick="switchTab('dynamics')">Dynamics</div>
</div>
      </div>

      ${state.activeTab==="network" ? `
        <div class="section">
          <div class="hint">
            <b>Clusters are dots:</b> left-click selects, right-click zooms in.<br>
            <b>Smart lines:</b> stops are auto-ordered to reduce criss-cross, and tracks are auto-built between stops.
          </div>

          <button class="btn success" onclick="simulateYear()">Simulate Next Year</button>
<button class="btn secondary" onclick="undo_applyLast()">Undo last action</button>

        </div>

        <div class="section">
          <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Create Line</div>
          <input id="lineName" class="field" placeholder="Line name" />
          <div style="height:8px"></div>
          <select id="lineType" class="field">
            <option value="passenger">Passenger</option>
            <option value="cargo">Cargo</option>
            <option value="mixed">Mixed</option>
          </select>

          <div style="height:8px"></div>
          <div class="row">
            <input id="lineFreq" class="field" type="number" min="0" max="200" step="1" placeholder="Trips/day (e.g. 18)">
            <input id="lineCap" class="field" type="number" min="1" max="5000" step="1" placeholder="Capacity (pax or tons)">
          </div>
          <div style="height:8px"></div>
          <input id="lineSpeed" class="field" type="number" min="40" max="320" step="5" placeholder="Speed km/h (e.g. 160)">

          <div style="height:8px"></div>
          <label style="display:flex;gap:10px;align-items:center;font-weight:900;color:#334155;">
            <input id="lineCircular" type="checkbox" />
            Circular line
          </label>

          <button class="btn" onclick="createNewLine()">Create Line</button>
        </div>

<button class="btn secondary" onclick="toggleLineBuildMode()">
  ${state.lineBuildMode ? "Add Stops: ON" : "Add Stops: OFF"}
</button>

${state.selectedNode ? (() => {
  const st = getStation(state.selectedNode.id);
  const cP = stationUpgradeCost("platforms", st);
  const cA = stationUpgradeCost("amenities", st);
  const cR = stationUpgradeCost("retail", st);
 const p = state.stationPressure.get(String(state.selectedNode.id)) || { demand: 0, supply: 0, pressurePct: 0 };


  return `
    <div class="section">
      <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Station: ${state.selectedNode.name}</div>
      <div class="hint" style="line-height:1.7;">
        ${kv("Level", fmtNum(st.level))}
        <br>${kv("Platforms", fmtNum(st.platforms))}
        <br>${kv("Amenities", fmtNum(st.amenities))}
        <br>${kv("Retail", fmtNum(st.retail))}
      </div>

<div class="hint" style="margin-top:8px; line-height:1.7;">
  ${kv(
    "Pressure",
    `<b style="color:${
      p.pressurePct >= 70 ? "#ef4444" :
      p.pressurePct >= 35 ? "#f59e0b" :
                            "#10b981"
    }">${p.pressurePct}%</b>`
  )}
  <br>${kv("Demand / day", fmtNum(Math.round(p.demand || 0)))}
  <br>${kv("Supply / day", fmtNum(Math.round(p.supply || 0)))}
</div>


      <div class="row" style="margin-top:10px;">
        <button class="btn secondary" onclick="upgradeStation('platforms')">+ Platform (${formatCurrency(cP)})</button>
        <button class="btn secondary" onclick="upgradeStation('amenities')">+ Amenities (${formatCurrency(cA)})</button>
      </div>
      <button class="btn secondary" onclick="upgradeStation('retail')">+ Retail (${formatCurrency(cR)})</button>

      <div class="hint" style="margin-top:10px;">
        Platforms will later increase how many trains can be handled without “delay”.
        Amenities reduce crowd pressure.
        Retail generates yearly rent revenue.
      </div>
    </div>
  `;
})() : ""}

<div class="section">
  <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Lines</div>

  <div class="hint" style="margin-bottom:10px;">
    <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
      <div style="font-weight:1000;color:#0f172a;">Active line</div>
      <button class="btn secondary" style="width:auto;padding:8px 10px;margin-top:0;"
        onclick="selectLine('')">No line selected</button>
    </div>

    <div style="height:8px"></div>

    <select class="field" onchange="selectLine(this.value)">
      ${lineOptions}
    </select>

<div style="height:10px"></div>

<label style="display:flex;gap:10px;align-items:center;font-weight:900;color:#334155;">
  <span style="min-width:70px;">Color</span>
  <input
    type="color"
    value="${activeLineColor}"
    ${activeLineObj ? "" : "disabled"}
    onchange="setActiveLineColor(this.value)"
    style="width:48px;height:34px;border:0;background:transparent;padding:0;cursor:pointer;"
  />
  <span style="font-weight:1000;color:#64748b;">${activeLineObj ? activeLineColor : "Select a line"}</span>
</label>


    <div style="margin-top:8px;color:#64748b;font-weight:850;font-size:12px;">
      Tip: choose “No line selected” to click nodes without adding stops.
    </div>
  </div>

  <div class="list">${linesList || `<div style="padding:14px;color:#64748b;font-weight:1000;">No lines yet</div>`}</div>

  <div class="row" style="margin-top:10px;">
    <button class="btn secondary" onclick="toggleCircularActive()">Toggle circular</button>
    <button class="btn danger" onclick="deleteActiveLine()">Delete line</button>
  </div>
</div>

      ` : ""}

      ${state.activeTab==="tracks" ? `
        <div class="section">
          <div class="hint">
            Track mode chain-builds: A→B, then B→C automatically.<br>
            Tracks are drawn in <b>black</b>. Lane count is shown as a <b>white number</b>.
          </div>

          <button class="btn ${state.trackBuildMode ? "warning" : "success"}"
            onclick="setTrackBuildMode(${!state.trackBuildMode})">
            ${state.trackBuildMode ? "Track Mode: ON" : "Track Mode: OFF"}
          </button>

          <div style="margin-top:10px;">
            <div class="k">Lanes</div>
            <select class="field" onchange="setTrackLanes(this.value)">
              <option value="1" ${state.pendingTrackLanes===1?"selected":""}>1 lane</option>
              <option value="2" ${state.pendingTrackLanes===2?"selected":""}>2 lanes</option>
              <option value="3" ${state.pendingTrackLanes===3?"selected":""}>3 lanes</option>
              <option value="4" ${state.pendingTrackLanes===4?"selected":""}>4 lanes</option>
              <option value="5" ${state.pendingTrackLanes===5?"selected":""}>5 lanes</option>
              <option value="6" ${state.pendingTrackLanes===6?"selected":""}>6 lanes</option>
            </select>
          </div>

          <div class="hint" style="margin-top:10px;">
            Current start node: <b>${state.pendingTrackNode ? state.pendingTrackNode.name : "—"}</b>
          </div>
<button class="btn secondary" onclick="undo_applyLast()">Undo last action</button>

          <button class="btn danger" onclick="clearAllTracks()">Clear ALL tracks</button>
        </div>
      ` : ""}

      ${state.activeTab==="economy" ? `
        <div class="section">
          <div class="hint">
            Economy now uses <b>flows</b> (passenger-km & ton-km) limited by <b>service capacity</b> (freq × vehicle capacity) and <b>track capacity</b> (lanes).
          </div>
<div style="margin-top:10px;" class="hint">
  <div style="font-weight:1000;color:#0f172a;margin-bottom:6px;">Network KPIs</div>
  <div>${kv("Stations loaded", fmtNum(nodesCount))}</div>
  <div>${kv("Tracks built", fmtNum(tracksCount))}</div>
  <div>${kv("Track length", fmtNum(Number(trackKm.toFixed(1))) + " km")}</div>
  <div>${kv("Lines", fmtNum(linesCount))}</div>
  <div>${kv("Trains/day", fmtNum(Math.round(totalTrainsPerDay)))}</div>
  <div>${kv("Capacity/day", fmtNum(Math.round(totalCapacityPerDay)))}</div>
  <div>${kv("Avg stops/line", fmtNum(Number(avgStopsPerLine.toFixed(1))))}</div>
  <div>${kv("Busiest station", busiestStationName==="—" ? "—" : (busiestStationName + " (" + fmtNum(Math.round(busiestMoves)) + "/day)"))}</div>
</div>

          <div style="margin-top:10px;">
            <div>${kv("Annual revenue", formatCurrency(state.revenue))}</div>
            <div>${kv("Annual costs", formatCurrency(state.costs))}</div>
            <div>${kv("Annual profit", `<span style="color:${state.profit>=0?"#10b981":"#ef4444"}">${formatCurrency(state.profit)}</span>`)}</div>
          </div>

${scorePanelHtml}

          <div style="margin-top:10px;" class="hint">
            <div>${kv("Passenger-km moved", fmtNum(Math.round(econ.paxKmMoved || 0)))}</div>
            <div>${kv("Cargo ton-km moved", fmtNum(Math.round(econ.tonKmMoved || 0)))}</div>
            <div>${kv("Biggest exporter", `${exporterName} (${formatCurrency(econ.biggestExporter?.exports || 0)})`)}</div>
            <div>${kv("Biggest needs", `${importerName} (${formatCurrency(econ.biggestImporter?.imports || 0)})`)}</div>
          </div>

          <div style="margin-top:12px;">
            <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Most effective lines</div>
            <div class="list" style="max-height:240px;">${lineRankingHtml}</div>
            <div style="margin-top:8px;color:#64748b;font-weight:850;font-size:12px;">
              Effectiveness = route km × trains/day × vehicle capacity (capacity-km/day). Click a line to select it.
            </div>
          </div>

          <div style="margin-top:12px;" class="section">
            <div style="font-weight:1000;color:#0f172a;margin-bottom:8px;">Optimizer (beta)</div>

            <div class="hint">
              Builds a network automatically over the current scope:
              <b>clusters</b> when zoomed out, or <b>cities</b> when inside a cluster.
              <br>“Replace” will overwrite your current lines.
            </div>

            <div class="row" style="margin-top:10px;">
              <button class="btn secondary" onclick="opt_autoBuildNetwork('add')">Auto-build (Add)</button>
              <button class="btn danger" onclick="opt_autoBuildNetwork('replace')">Auto-build (Replace)</button>
            </div>

            <button class="btn secondary" onclick="opt_boostFrequencies()">Boost frequencies (+20%)</button>
          </div>



          <button class="btn warning" onclick="simulateYear()">Simulate Next Year</button>
        </div>


      ` : ""}
${state.activeTab==="dynamics" ? renderDynamicsTab() : ""}
    `;
  }

function ensureDefaultTestLine(){
  // If there are already lines (or a save was loaded), do nothing.
  if (state.lines.size > 0) return;

  // Use clusters (works zoomed out) – pick a few big ones
  const clusters = Array.from(state.clusters.values())
    .slice()
    .sort((a,b) => (Number(b.population||0) - Number(a.population||0)))
    .slice(0, 6);

  if (clusters.length < 2) return;

  // Order them west->east to make a nicer looking first line
  clusters.sort((a,b) => (Number(a.lon||0) - Number(b.lon||0)));

  const id = addLine("Test Line", "passenger", false, {
    frequencyPerDay: 6,
    vehicleCapacity: 220,
    speedKmh: 180
  });

  const line = state.lines.get(id);
  if (!line) return;

  line.stops = clusters.slice(0, 4).map(c => String(c.id));

  state.activeLine = id;
  renderLines();
  updateUI();
    uiMode_render();
    uihotkeys_install();
}

  // ======================
  // Init
  // ======================
  async function boot(){
    initMap();

    const cities = await loadJSON("./cities_es.json");
    state.cities = Array.isArray(cities) ? cities : (Array.isArray(cities?.cities) ? cities.cities : cities);

    buildClusters(state.cities);
    renderClusterMarkers();
    ensureDefaultTestLine();

    syncMarkerVisibility();
    updateClusterBar();
    updateUI();

    showToast(`Loaded cities: ${fmtNum(state.cities.length)} • clusters: ${fmtNum(state.clusters.size)}`, "success");
  }

  // expose globals for inline onclick
  window.switchTab = switchTab;
  window.simulateYear = simulateYear;
  window.setTrackBuildMode = setTrackBuildMode;
  window.setTrackLanes = setTrackLanes;
  window.createNewLine = createNewLine;
  window.selectLine = selectLine;
  window.setActiveLineColor = setActiveLineColor;
  window.toggleCircularActive = toggleCircularActive;
  window.toggleLineBuildMode = toggleLineBuildMode;
  window.deleteActiveLine = deleteActiveLine;
  window.clearAllTracks = clearAllTracks;
  window.upgradeStation = upgradeStation;
window.opt_autoBuildNetwork = opt_autoBuildNetwork;
window.opt_boostFrequencies = opt_boostFrequencies;
window.undo_applyLast = undo_applyLast;



function setDynamicsEnabled(on){
  state.dynamics.enabled = !!on;
  updateUI();
  showToast(state.dynamics.enabled ? "Dynamics enabled" : "Dynamics disabled", "info");
  dynFlow_render();
}

function setDynamicsOverlay(on){
  state.dynamics.showOverlay = !!on;
  updateUI();
  showToast(state.dynamics.showOverlay ? "Overlay ON" : "Overlay OFF", "info");
  dynFlow_render();
}

function setDynamicsMode(mode){
  state.dynamics.mode = mode;
  updateUI();
  showToast(`Mode: ${mode}`, "info");
  dynFlow_render();
}

window.setDynamicsEnabled = setDynamicsEnabled;
window.setDynamicsOverlay = setDynamicsOverlay;
window.setDynamicsMode = setDynamicsMode;


  boot().catch(err => {
    console.error(err);
    showToast("Failed to load data files", "error");
    document.getElementById("controlPanel").innerHTML = `
      <div class="section">
        <h3 class="title">Load error</h3>
        <div class="hint">
          ${String(err)}<br><br>
          Make sure these files sit next to <code>index.html</code>:<br>
          • <b>cities_es.json</b><br>
          • <b>economy.js</b><br><br>
          Run a local server, e.g. <code>python -m http.server 8000</code>
        </div>
      </div>
    `;
  });

function saveGame(){
  const data = {
    year: state.year,
    budget: state.budget,
    revenue: state.revenue,
    costs: state.costs,
    profit: state.profit,
    activeClusterId: state.activeClusterId,

    // tracks + lines are Maps, convert to arrays
    tracks: Array.from(state.tracks.values()).map(t => ({
      id: t.id, from: t.from, to: t.to, lanes: t.lanes
    })),
    lines: Array.from(state.lines.values()).map(l => ({
      id: l.id, name: l.name, type: l.type, color: l.color,
      stops: l.stops, circular: l.circular
    }))
  };

  localStorage.setItem("railSimSave", JSON.stringify(data));
  showToast("Saved!", "success");
}

function loadGame(){
  const raw = localStorage.getItem("railSimSave");
  if (!raw) { showToast("No save found", "warning"); return; }

  const data = JSON.parse(raw);

  state.year = data.year ?? state.year;
  state.budget = data.budget ?? state.budget;
  state.revenue = data.revenue ?? 0;
  state.costs = data.costs ?? 0;
  state.profit = data.profit ?? 0;
  state.activeClusterId = data.activeClusterId ?? null;

  // clear visuals + state
  layers.tracks.clearLayers();
  layers.lines.clearLayers();
  state.tracks.clear();
  state.lines.clear();

  // rebuild tracks (visual + state)
  for (const t of (data.tracks || [])) addTrack(t.from, t.to, t.lanes || 1);

  // rebuild lines
  for (const l of (data.lines || [])) {
    state.lines.set(l.id, {
      id: l.id, name: l.name, type: l.type, color: l.color,
      stops: Array.isArray(l.stops) ? l.stops : [],
      circular: !!l.circular,
      cursorStopId: null
    });
  }

  // set active line if any
  const firstLine = Array.from(state.lines.keys())[0] || null;
  state.activeLine = firstLine;

  // restore cluster view if needed
  if (state.activeClusterId) {
    const cl = state.clusters.get(state.activeClusterId);
    if (cl) map.fitBounds(cl.bounds.pad(0.25), { maxZoom: 11 });
  } else {
    map.setView(CONFIG.SPAIN_VIEW.center, CONFIG.SPAIN_VIEW.zoom);
  }

  renderLines();
  syncMarkerVisibility();
  updateClusterBar();
  updateUI();
  showToast("Loaded!", "success");
}

// expose to onclick buttons
window.saveGame = saveGame;
window.loadGame = loadGame;

</script>
</body>
</html>
