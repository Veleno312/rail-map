You are Codex working inside this repo (current structure):

rail-map/
  index.html
  cities_es.json
  custom_places.json
  app/
    core.js
    init.js
    map_layers.js
    network.js
    sim.js
    ui.js
    service_clock.js
    (and others)

Goal: Replace the current “clusters/cities as simulation nodes” with a station-first transport model:

1) Base layer (truth): Nodes = stations, Edges = track segments
2) Demand layer: cells (Spain uses comarcas polygons)
3) Demand assignment: cells → stations using gravity/scoring (access time + rail connectivity + service quality + congestion)
4) Feedback loop: editing network/stations/lines recomputes catchments and underserved; overlays update

Constraints:
- Keep existing UI and map working (Leaflet).
- Preserve existing “line build” workflow but enforce that line stops are stations only.
- Keep backwards compatibility for saves if possible (or migrate with a clear migration).
- Do NOT delete existing cluster logic immediately; keep it as an optional overlay/view, but simulation must not depend on it.

Deliverables:
- Code changes across app/*.js
- New files in app/ for station/demand graph
- Add UI controls to toggle overlays and force recomputation
- Add docs in README describing model and how to use

------------------------------------------------------------
A. NEW CORE DATA MODEL (in state)
------------------------------------------------------------

Modify the global state object (wherever it is defined; likely in app/core.js or app/ui.js) so it includes:

state.stations: Map<stationId, Station>
state.tracks: Map<trackId, Track> (already exists; ensure it connects station ids)
state.cells: Map<cellId, Cell> (demand cells)
state.cellToStationAllocation: Map<cellId, Array<{stationId, share, pax, freight, score}>>
state.stationLoad: Map<stationId, {pax, freight, loadRatio, congestionPenalty}>
state.underservedByCell: Map<cellId, number>  // used for heat overlay
state.viewMode: "stations" | "cities" | "clusters"  // display only
state.mapLayers: {
  showStations: boolean,
  showTracks: boolean,
  showLines: boolean,
  showTrains: boolean,
  showComarcaBorders: boolean,
  showDemandHeat: boolean,
  showCatchments: boolean,
  showUnderserved: boolean
}
state.simConfig: {
  accessSpeedKmh: number,         // e.g. 50
  maxAccessKm: number,            // e.g. 60
  gravityAlpha: number,           // access-time decay, e.g. 2.2
  railBeta: number,               // rail-time factor, e.g. 0.6 (optional)
  candidateStationsK: number,      // e.g. 12
  congestionGamma: number,         // e.g. 2.0
  serviceQualityWeight: number     // e.g. 0.25
}

Stations are the ONLY simulation nodes. Cities/clusters are overlays/demand helpers only.

------------------------------------------------------------
B. STATION DATA (v1 = derived from cities, later can be real)
------------------------------------------------------------

Create app/stations.js that exports:

- buildStationsFromCities(cities, {populationThreshold}) -> Map
- toggleStation(stationId) or createStationFromCity(cityId)
- getStationLatLng(station)

Implementation v1:
- Use cities_es.json to seed stations:
  - stationId = "ST-" + city.id
  - include cities with population >= 20_000 as stations
- Provide a UI action to toggle a city’s station status:
  - In Cities view, clicking a city shows “Make/Remove Station”
  - If removed, it is no longer a station node; lines cannot stop there.

IMPORTANT:
- Existing lines that reference non-station nodes must be migrated:
  - Either (a) auto-convert referenced city nodes into stations, OR
  - (b) remove invalid stops and warn user.
Pick (a) for a smoother transition.

------------------------------------------------------------
C. TRACK GRAPH + ROUTING
------------------------------------------------------------

Create app/graph.js:

- buildAdjacencyFromTracks(state.stations, state.tracks) -> adjacency
- dijkstraTravelTime(fromStationId, toStationId, adjacency, edgeTimeFn) -> {timeMin, path}
- multiSourceDijkstra(sources[], adjacency, edgeTimeFn) -> Map<stationId, timeMin>

Edge weight:
- trackTimeMin = (distanceKm / effectiveSpeedKmh) * 60
- effectiveSpeedKmh = min(track.maxSpeedKmh (if present) else default, line speed if line is used)
For infrastructure-only connectivity, just use track speed / a default speed class (e.g. 120).

Compute distanceKm if missing using haversine between station coords.

------------------------------------------------------------
D. DEMAND CELLS FROM COMARCAS
------------------------------------------------------------

Create app/cells.js:

- loadComarcasGeoJSON(url) -> GeoJSON
- buildCellsFromGeoJSON(geojson) -> Map<cellId, Cell>

Cell fields:
{
  id, name,
  centroidLat, centroidLon,
  pop, jobs, industryShares, growth
}

If comarcas.geojson has no population fields, approximate using:
- city population sums within polygon (point-in-polygon for cities), OR
- fallback: a small default (e.g. 5_000) so system still runs

Prefer: detect likely population keys:
- "population", "pob", "POB", "POP", etc
If none found, use the city-sum fallback.

------------------------------------------------------------
E. DEMAND ASSIGNMENT (cells -> stations)
------------------------------------------------------------

Create app/demand_assign.js with main function:

recomputeDemandModel(state, map) -> updates:
- state.cellToStationAllocation
- state.stationLoad
- state.underservedByCell
- (optional) state.catchmentByCell = dominant station id

Steps:

1) Build candidate stations per cell:
- Compute straight-line distance from cell centroid to each station
- Filter by maxAccessKm; if none, take nearest K anyway (so remote cells still pick something)
- Keep top K by distance

2) Compute access time:
accessMin = (distanceKm / accessSpeedKmh) * 60

3) Compute serviceQuality(station):
Use current lines in state.lines:
- service = sum over lines serving station of:
  - departures/day or frequencyPerDay if available else count of departures array
  - capacity proxy: line_dailyCapacity(line) if exists in core.js
serviceQuality = 1 + serviceQualityWeight * log(1 + service)

4) Compute congestion penalty:
After an initial pass, estimate stationAssignedDemand and stationCapacity:
- capacity = sum of line_dailyCapacity(line) for lines serving station (pax + freight separately if you want)
- loadRatio = demand / max(1, capacity)
- congestionPenalty = 1 / (1 + loadRatio^congestionGamma)

Do it in two-pass:
- Pass A: allocate ignoring congestion to get initial loads
- Compute congestionPenalty
- Pass B: allocate again with congestion included

5) Compute score and allocate:
score = exp(-gravityAlpha * accessMin/60) * serviceQuality * congestionPenalty
Normalize scores for cell across candidate stations
Allocate cell passenger demand:
paxDemand = pop * paxFactor (e.g. 0.35 trips/day equivalent, tunable)
Allocate freight demand:
freightDemand = pop * freightFactor OR from industry shares (placeholder OK)

Store allocation array per cell:
[{stationId, share, pax, freight, score}...]

6) Underserved:
Define servedness as sum of allocated shares * exp(-gravityAlpha * accessTimeHours)
Or simpler:
bestAccessMin = min accessMin to a station
servedness = exp(-gravityAlpha * bestAccessMin/60)
underserved = pop * (1 - servedness)
Store in state.underservedByCell

7) Catchment (optional overlay):
dominant station = station with max share
state.catchmentByCell[cellId] = stationId

Trigger recomputeDemandModel when:
- station toggled/created/deleted
- track added/removed/upgraded
- line created/edited (stops, frequency/departures, carriages/speed)
- load game / new game
Add a button “Recompute demand” for manual forcing.

------------------------------------------------------------
F. ENFORCE “LINE STOPS MUST BE STATIONS”
------------------------------------------------------------

Wherever line building adds a stop (likely app/network.js / app/ui.js):
- currently it adds nodeId from state.nodes
Change so:
- only allow adding stationId from state.stations
- if user clicks a city, show message “Not a station. Convert to station first.”
- provide UI action to “Convert city to station”.

Rendering trains and lines:
- Must use station lat/lon (not cluster/city nodes)
- Keep city/cluster rendering as overlays but do not use them for routes.

IMPORTANT migration:
- state.nodes currently includes clusters/cities. Keep it for overlays.
- Add state.stations separately and use that for simulation and line stops.

------------------------------------------------------------
G. MAP OVERLAYS / LAYERS
------------------------------------------------------------

In app/map_layers.js:
- Add Leaflet layer groups:
  layers.comarcaBorders
  layers.demandHeat
  layers.catchments

Implement:
1) Comarca borders:
- Draw polygons with light stroke, no fill when showComarcaBorders

2) Demand heat / underserved:
- Shade polygons based on state.underservedByCell
- Use a simple color scale function (do not introduce heavy deps)

3) Catchments:
- Option A: color polygons by dominant station (hash stationId -> color)
- Option B: draw centroid -> dominant station lines (thin lines) for debugging

Stations marker styling:
- Stations are distinct markers (different icon)
- Cities/clusters remain as dots if viewMode enabled

Update syncMarkerVisibility so:
- viewMode controls which markers appear
- simulation markers remain consistent

------------------------------------------------------------
H. UI CHANGES
------------------------------------------------------------

In app/ui.js:
Add to Network tab:
- Dropdown: viewMode (clusters/cities/stations)
- Checkboxes for overlays: comarca borders, demand heat, catchments
- Button: “Recompute demand”
- Small readouts:
  - total underserved (sum over cells)
  - top 5 underserved cells
  - top 5 overloaded stations (by loadRatio)

Selection inspector:
- If station selected: show assigned pax/freight, #lines serving, congestion
- If cell selected: show pop, best station, underserved score, top 3 allocations

------------------------------------------------------------
I. SAVE/LOAD MIGRATION
------------------------------------------------------------

Modify saveGame/loadGame in app/init.js:
Include:
- station list (or station toggles set)
- simConfig
- mapLayers
- viewMode
- demand model outputs are derivable; don’t save them (recompute on load)

When loading an old save:
- if lines reference old node ids (cities), auto-convert those into stations (create station entries).
- Ensure state.lines.stops becomes station IDs.

After loadGame, call recomputeDemandModel and refresh overlays.

------------------------------------------------------------
J. TESTS / ACCEPTANCE CHECKLIST (manual)
------------------------------------------------------------

1) App loads and shows map.
2) Stations view: only stations visible; building a line can only add station stops.
3) Cities view: clicking a city allows “Convert to station”; after converting, it appears in Stations view.
4) Comarca borders toggle works.
5) Demand heat toggle works; underserved map changes when adding stations or lines.
6) Recompute button updates station loads and underserved.
7) Save & load preserves station toggles, lines, and view settings; demand recomputes on load.

------------------------------------------------------------
K. IMPORTANT: KEEP EXISTING FEATURES WORKING
------------------------------------------------------------

- Do not break simulateYear() in app/sim.js
- Keep economy.js integration, but update it so it reads station loads if needed
- Existing moving train overlay (dynFlow_render in sim.js) must render using station stop coordinates.

------------------------------------------------------------
Implementation notes:
- Use no new external libs.
- Use small helper functions: haversineKm, pointInPolygon (basic), centroid of polygon.
- Keep changes well-scoped: new modules in app/ and minimal edits to existing.



PHASE 2 (Data upgrade): Replace “stations derived from cities” and “abstract tracks” with REAL station + railway infrastructure data, while keeping Phase 1’s model (cells→stations assignment, station-only line stops, underserved feedback loop) intact.

Repo context (same as before):
rail-map/
  cities_es.json
  custom_places.json
  comarcas.geojson
  app/...

Goal of Phase 2:
- Use REAL railway stations (points) and REAL rail track segments (edges) for Spain first.
- Keep demand cells as comarcas (or grid later).
- Keep the assignment model, but improve reachability and travel time using the real track graph.
- Keep UI working and allow fallbacks if data is missing.

NO new external libraries. Keep performance reasonable.

========================================================
1) NEW DATA INPUTS (Spain first)
========================================================

Add a new folder:
data/es/
  stations_es.json
  rail_edges_es.json

These are “processed” lightweight files that the app can load directly (do NOT ship raw OSM PBF; too big and complex).

Define formats:

A) stations_es.json
[
  {
    "id": "st_es_000001",
    "name": "Madrid-Puerta de Atocha",
    "lat": 40.4066,
    "lon": -3.6894,
    "country": "ES",
    "tags": {
      "operator": "ADIF",
      "type": "railway_station",
      "uic_ref": "xxxxxx"
    }
  },
  ...
]

B) rail_edges_es.json
Edges connect station IDs OR connect to “junction nodes” (see below).
Prefer station-to-station edges for a simple first version.
[
  {
    "id": "edge_es_000001",
    "a": "st_es_000001",
    "b": "st_es_000102",
    "distance_km": 6.1,
    "max_speed_kmh": 120,
    "track_type": "conventional",
    "electrified": true,
    "gauge": "iberian",
    "capacity": 12,
    "maintenance_cost": 1.0
  },
  ...
]

If you can’t reliably map all edges directly between stations (common), use a second structure:

C) rail_nodes_es.json (junction graph)
[
  {"id":"rn_es_000001","lat":...,"lon":...,"kind":"junction"},
  {"id":"st_es_000001","lat":...,"lon":...,"kind":"station"}  // stations may be included as nodes too
]

D) rail_links_es.json
[
  {"id":"rl_es_000001","a":"rn_es_000001","b":"rn_es_000002","distance_km":...,"max_speed_kmh":...}
]

Then have a mapping from stations to nearest rail node:
stations_es.json adds:
  "rail_node_id": "rn_es_000123"

Codex should implement BOTH ingestion paths:
- If rail_edges_es.json exists -> use station-to-station
- Else if rail_nodes_es.json + rail_links_es.json exists -> use node graph + station mapping

========================================================
2) LOADER + COUNTRY SWITCHING
========================================================

Create app/data_registry.js:
- getCountryDataConfig(countryCode) -> file paths to stations/tracks
- default to ES in current project

Create app/load_real_infra.js:
- async loadStations(countryCode)
- async loadRailGraph(countryCode)
- returns {stationsMap, graphAdjacency, edgeMeta}

On init/new game:
- if data/es exists, use it
- else fallback to Phase 1 station-from-cities + synthetic tracks (keep old behavior as fallback)

========================================================
3) REPLACE “DERIVED STATIONS” WITH REAL STATIONS (ES)
========================================================

Update app/stations.js:
- If real stations loaded for current country:
  - state.stations is set from stations_es.json
  - city-to-station toggling UI becomes:
    - “Build new station here” (creates a CUSTOM station)
    - “Disable station” (for gameplay)
- Keep a “custom stations” store:
  data/custom_stations.json OR persist in save file:
  state.customStations: Map
  state.disabledStations: Set<stationId>

Station identity:
- Use stable IDs from stations_es.json
- Custom stations use prefix "st_custom_"

========================================================
4) TRACK GRAPH: USE REAL INFRA FOR TRAVEL TIME + REACHABILITY
========================================================

Update app/graph.js:
- Build adjacency from real rail edges/links
- Weight = travel time minutes:
  timeMin = (distance_km / effective_speed_kmh) * 60
- effective_speed_kmh:
  if max_speed_kmh exists -> use it
  else:
    conventional default 110, highspeed default 250
- Add penalties if desired:
  - non-electrified penalty
  - gauge mismatch penalty (optional later)

Precompute:
- For demand assignment you need station-to-station travel times sometimes.
Add:
- computeStationTravelTimesFromHub(hubStationIds[]) using multiSourceDijkstra
- OR compute per-station centrality only when needed

Keep it fast:
- Do NOT compute all-pairs shortest paths.
- Use:
  - multi-source to key hubs, and/or
  - per-cell only compute access + nearest K stations by access, and optionally one dijkstra from each candidate station to a small set of “major centers”.

========================================================
5) ACCESS MODEL: IMPROVE CELL->STATION ACCESS
========================================================

In Phase 1, access time is straight-line / road-speed proxy.

Phase 2 upgrades:
- Keep straight-line as base.
- Add a “means” toggle:
  simConfig.accessMode = "straight" | "hybrid"
Hybrid:
- If station is within maxAccessKm -> straight
- Else apply a penalty (rural isolation) rather than infinite rejection:
  accessMin = straightMin * 1.35 + 20

Still no real road graph (out of scope for Phase 2), but this yields better realism.

========================================================
6) SERVICE QUALITY: BASE IT ON ACTUAL LINES USING REAL GRAPH
========================================================

Update serviceQuality(station):
- Use existing line objects in state.lines
- A station is served if it appears as a stop on any line
- service = sum(line.frequencyPerDay * line.capacityPerTrain) (or best available proxies)
- quality = 1 + W * log(1 + service)

Also compute line travel time using real rail graph between consecutive stops:
- For each line segment (stop[i] -> stop[i+1]), run dijkstra on rail graph to get segment time
- Cache results per pair (stationIdA|stationIdB) to avoid repeated dijkstra
- This allows schedule simulation to reflect infrastructure upgrades

========================================================
7) DEMAND ASSIGNMENT: ADD RAIL CONNECTIVITY TERM (OPTIONAL BUT DESIRED)
========================================================

In app/demand_assign.js scoring:
score = exp(-alpha * accessHours)
      * exp(-beta * railHubHours(station))     // NEW connectivity term
      * serviceQuality(station)
      * congestionPenalty(station)

Define railHubHours(station) cheaply:
- Choose 5-10 fixed “major centers” for ES:
  - pick top N stations by “importance” tag or nearest to biggest cities (Madrid, Barcelona, Valencia, Sevilla, Bilbao…)
- Compute travel time from every station to nearest hub using multiSourceDijkstra once per recompute.
- railHubHours = timeToNearestHub / 60
This makes “isolated-but-has-one-AVE-stop” visible: if a station has AVE but poor mesh to hubs, it won’t magically dominate.

========================================================
8) VISUALIZATION: SHOW REAL TRACKS
========================================================

Add a layer: layers.railInfra
- Draw polylines for each edge/link
- Light styling to avoid clutter
- Toggle in UI: “Show real rail infra”

If using node+links, draw link geometries:
- If only endpoints exist, draw straight segments (ok)
- If you have shape points in processed data, draw those (optional)

========================================================
9) EDITOR TOOLS: UPGRADE TRACK / ADD SPUR / BUILD STATION
========================================================

Add simple tools (minimal viable):
- Build station (custom): click map -> create station + optionally connect to nearest rail node (if using node graph) by a short connector edge with low speed.
- Upgrade track: click an edge -> increase max_speed_kmh or capacity (store modifications in save).
- Toggle station enabled/disabled.

Persist edits:
- state.trackOverrides: Map<edgeId, {max_speed_kmh?, capacity?, disabled?}>
- state.stationOverrides: {disabledStations Set, customStations Map}

Graph builder must apply overrides every rebuild.

========================================================
10) SAVE/LOAD + MIGRATION
========================================================

Save file must include:
- current country
- disabledStations
- customStations
- trackOverrides
- lines + schedules (existing)
- UI viewMode + mapLayers + simConfig

On load:
- load base ES infra, then apply overrides, then rebuild adjacency, then recompute demand.

If old saves referenced derived stations:
- attempt a mapping:
  - if stop id starts with "ST-" (city-derived), try to match nearest real station within 5km
  - if match found, replace stop id
  - else create a custom station at the old coordinates
Log a warning in UI toast: “Migrated X stops; Y became custom.”

========================================================
11) ACCEPTANCE CHECKLIST
========================================================

- With ES real infra present:
  - Stations view shows real stations.
  - Real rail infra toggles and draws edges.
  - Lines compute segment travel times via rail graph.
  - Demand heat + underserved changes if you disable a station or upgrade a track.
- Without ES infra:
  - Phase 1 fallback still works.

========================================================
12) NOTES FOR CODING
========================================================

- No new libs.
- Keep all new logic in new modules under app/:
  load_real_infra.js
  data_registry.js
  graph.js (extended)
  demand_assign.js (extended)
- Keep changes to existing files minimal and well-commented.
- Prefer caching (Map) for dijkstra results between station pairs used by lines.
- Ensure UI remains responsive: recompute demand on explicit button or on “commit changes”, not every mouse move.

END PHASE 2 TASK.